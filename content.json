{"meta":{"title":"Gloria","subtitle":"zxr's blog","description":"sadad","author":"Zxr","url":"http://jabbla.github.io"},"pages":[{"title":"关于我","date":"2016-08-13T07:21:24.000Z","updated":"2016-08-14T10:35:20.689Z","comments":true,"path":"about/index.html","permalink":"http://jabbla.github.io/about/index.html","excerpt":"","text":"爱篮球，爱滑雪，爱R&amp;B 爱前端，爱挑战，爱刺激 沉迷地狱，无法自拔，^_^"}],"posts":[{"title":" Canvas 知识体系简单总结","slug":"Canvas-知识体系简单总结","date":"2016-08-04T07:09:00.000Z","updated":"2016-08-14T10:13:39.842Z","comments":true,"path":"2016/08/04/Canvas-知识体系简单总结/","link":"","permalink":"http://jabbla.github.io/2016/08/04/Canvas-知识体系简单总结/","excerpt":"知识点零零散散，一个上午整理了一下，内容不多,方便记忆。 本文不是教程，如需教程移步 MDN Canvas教程","text":"知识点零零散散，一个上午整理了一下，内容不多,方便记忆。 本文不是教程，如需教程移步 MDN Canvas教程 本文原创，如需转载，请注明出处 前言 知识点零零散散，一个上午整理了一下，内容不多,方便记忆。 本文不是教程，如需教程移步 MDN Canvas教程 Canvas 能干什么个人把它分为以下几点 一个画板，能绘制复杂的图形，并应用各种样式。 能在画板中放置图片，并可操作图片的尺寸和每个像素。 鼠标事件能够访问到画板中的相应区域。 能把画板中的图画，转换为DataURL的形式。 体系概览 把Canvas想象成一个画板 一个绘制状态，可类比画图工具中的工具栏 绘图元素，包括简单的图形，线条，复杂的组合，和图片 绘制模式，比如画板中的图形存在绘制的先后顺序，而存在重叠部分，该如何显示存在重叠的图形，这是绘制模式要解决的问题 裁切路径，只让画板的部分可见 像素操作，操作ImageData的像素，画板的一部分 区域访问，鼠标事件能够获取到所在的区域 绘制元素 需要说明的是image的类型 HTMLImageElement HTMLVideoElement HTMLCanvasElement ImageBitmap 绘制状态 需说明的是，一个canvas只有一组绘制状态 区域访问 addHitRegion({id:’abc’})鼠标事件能够获取到所在的区域 绘制模式 globalCompositeOperation比如画板中的图形存在绘制的先后顺序，而存在重叠部分，该如何显示存在重叠的图形，这是绘制模式要解决的问题 裁剪路径 clip()只让画板的部分可见 像素操作","categories":[{"name":"学习","slug":"学习","permalink":"http://jabbla.github.io/categories/学习/"}],"tags":[{"name":"canvas","slug":"canvas","permalink":"http://jabbla.github.io/tags/canvas/"},{"name":"html5","slug":"html5","permalink":"http://jabbla.github.io/tags/html5/"}]},{"title":"Promise思考及强化实现","slug":"思考及强化实现","date":"2016-08-01T14:40:53.000Z","updated":"2016-08-14T10:01:29.202Z","comments":true,"path":"2016/08/01/思考及强化实现/","link":"","permalink":"http://jabbla.github.io/2016/08/01/思考及强化实现/","excerpt":"做了Sudoku项目后，很头疼的问题就是代码维护，很大一部分原因是回调嵌套太多，影响代码的可读性,增加了维护难度, 尤其是后端的数据库操作，用nodeJs通常会写许多回调嵌套。这次终于打算揭竿起义。","text":"做了Sudoku项目后，很头疼的问题就是代码维护，很大一部分原因是回调嵌套太多，影响代码的可读性,增加了维护难度, 尤其是后端的数据库操作，用nodeJs通常会写许多回调嵌套。这次终于打算揭竿起义。 本文原创，如需转载请注明出处 我需要什么做了Sudoku项目后，很头疼的问题就是代码维护，很大一部分原因是回调嵌套太多，影响代码的可读性,增加了维护难度,尤其是后端的数据库操作，用nodeJs通常会写许多回调嵌套。这次终于打算揭竿起义。 第二次修改,废话不多说，直接进入正题先看下面这段代码12345678910111213function do()&#123; //查找数据库 setTimeout(()=&gt;&#123; console.log('收到数据'); //修改字段，并保存 setTimeout(()=&gt;&#123; console.log('保存成功') //发送响应给前端 &#125;,1000) setTimeout &#125;,1000)&#125;do() 模拟了非常简单的一个从前端接受请求到发送响应回到前端的过程，这个代码是非常简单的，不过看起来并不是，而且一旦需求更复杂，这样风格的代码肯定会让我非常头疼 我需要的代码风格 每个异步过程独立成块，不再是嵌套风格 异步返回结果的处理过程独立于异步过程 可伸缩，直接扩展异步结果处理过程,并不与之前的混在一起,实现细分，独立成块 每个异步过程存在依赖 好吧，发现promise满足我的所有需求，拿来现成用？这一点都不好玩，所以研究了一下promise的用法，下面是我简易的需求说明 需求说明（参考ES6的实现效果） 每个promise实例 resolve动作 reject动作 promise实例 then方法注册resolve回调，reject回调 A实例执行完回调，then()会返回一个B实例 B实例跟A一样，同样有 resolve动作 reject动作 调用B的then()方法同样会注册resolve回调，reject回调 影响B动作的因素有4个(下面详细讲解) 有catch同then一样，但是只能注册一个错误回调 a实例如过程上依赖于另外一个b实例,则可被当做其resolve参数传递，并且b实例成功好事滚粗依赖于 a 的状态 一旦实例状态发生改变,状态不会再改变 ##影响B实例的因素 1.A的resolve回调和reject回调是否有异常抛出是：B执行reject动作 否：B执行resolve动作 2.A的reject动作是否有回调是：回到1. 、 否：B执行reject动作 3.A的resolve动作是否有回调是：回到1 否： B执行resolve动作 4.A的回调中return 另一个promise实例CC resolve: B resolve C reject: B reject 具体实现Promise实例所有的属性12345678910111213141516171819class Promise&#123; //构造函数 fn为构建实例的异步过程 constructor(fn)&#123; //必须为函数类型 if(typeof fn !== 'function') throw new Error('not a function'); this.success = []; this.sucArg = null; this.fail = []; this.failArg = null; this.state = 0; this.parent = null; //fork promise分支 this.fork = []; //传递的error setTimeout(()=&gt;&#123; fn(myPromise.resolve.bind(this),myPromise.reject.bind(this)) &#125;,0); &#125;&#125; Promise实例的方法，then(),catch()123456789101112131415161718192021222324 //onFulfilled成功处理函数，onRejected滚粗处理函数 then(onFulfilled,onRejected)&#123; /*参数格式限制*/let fork = new myPromise(()=&gt;&#123;&#125;);if(typeof onFulfilled ==='function')&#123; this.success.push(onFulfilled); fork.forkSuc = onFulfilled;&#125;if(typeof onRejected ==='function')&#123; this.fail.push(onRejected); fork.forkRej = onRejected;&#125; this.fork.push(fork);return fork; &#125; catch(onRejected)&#123; //参数必须函数let fork = new myPromise(()=&gt;&#123;&#125;);if(typeof onRejected !=='function') return this;this.fail.push(onRejected);fork.forkRej = onRejected; this.fork.push(fork);return fork; &#125; Promise静态方法resolve,reject123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596 static resolve(value)&#123; if(this.state!==0) return;//参数不是myPromise实例if(value instanceof myPromise)&#123; //如参数是一个promise实例 value.parent = this; if(value.state===1)&#123; //实例状态为成功 myPromise.resolve.call(this,value.successArg); &#125;else if(value.state===-1)&#123; //实例状态为失败 myPromise.reject.call(this,value.failArg); &#125;&#125;else&#123; if(!this.success.length)&#123; for(let fn of this.fork)&#123; myPromise.resolve.call(fn,value); &#125; &#125;else&#123; this.sucArg = value; let cur = 0; for(let fn of this.success)&#123; if(this.fork.length&amp;&amp;fn===this.fork[cur].forkSuc)&#123; let error,preArg,bool; try&#123; preArg = fn(value); if(preArg instanceof myPromise)&#123; let index = cur; bool = true; preArg.success.push(()=&gt;&#123; myPromise.resolve.call(this.fork[index],preArg.sucArg); &#125;); preArg.fail.push(()=&gt;&#123; myPromise.reject.call(this.fork[index],preArg.failArg); &#125;) &#125; &#125;catch(err)&#123; error = err||null; &#125; if(!bool)&#123; error? myPromise.reject.call(this.fork[cur],error): myPromise.resolve.call(this.fork[cur],preArg); &#125; cur++; &#125;else&#123; fn(value); &#125; &#125; &#125; //当前promise变为fulfilled this.state = 1; //如存在parent,则parent.resolve(value) if(this.parent) myPromise.resolve.call(this.parent,value);&#125; &#125; static reject(value)&#123; if(this.state!==0) return;//参数是myPromise实例if(value instanceof myPromise)&#123; value.parent = this; myPromise.reject.call(this);&#125;else&#123; if(!this.fail.length)&#123; for(let fn of this.fork)&#123; myPromise.reject.call(fn,value) &#125; &#125;else&#123; this.failArg = value; let cur = 0; for(let fn of this.fail)&#123; if(this.fork.length&amp;&amp;fn===this.fork[cur].forkRej)&#123; let error,preArg,bool; try&#123; preArg = fn(value); if(preArg instanceof myPromise)&#123; let index = cur; bool = true; preArg.success.push(()=&gt;&#123; myPromise.resolve.call(this.fork[index],preArg.sucArg); &#125;); preArg.fail.push(()=&gt;&#123; myPromise.reject.call(this.fork[index],preArg.failArg); &#125;) &#125; &#125;catch(err)&#123; error = err||null; &#125; if(!bool)&#123; error? myPromise.reject.call(this.fork[cur],error): myPromise.resolve.call(this.fork[cur],preArg); &#125; cur++; &#125;else&#123; fn(value); &#125; &#125; &#125; this.state = -1; if(this.parent) myPromise.reject.call(this.parent,value);&#125; &#125; 好了，就这么多，这是个简易的Promise实现，如有错误，或者什么建议QQ:387857274欢迎讨论","categories":[{"name":"学习","slug":"学习","permalink":"http://jabbla.github.io/categories/学习/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://jabbla.github.io/tags/javascript/"},{"name":"promise","slug":"promise","permalink":"http://jabbla.github.io/tags/promise/"},{"name":"es6","slug":"es6","permalink":"http://jabbla.github.io/tags/es6/"}]},{"title":"Sublime效率开发实践","slug":"Sublime效率开发实践","date":"2016-05-14T08:21:00.000Z","updated":"2016-08-14T09:50:24.578Z","comments":true,"path":"2016/05/14/Sublime效率开发实践/","link":"","permalink":"http://jabbla.github.io/2016/05/14/Sublime效率开发实践/","excerpt":"如何让写代码更有快感呢，那就是多使用快捷键，练习传说中的微操 会持续更新·····","text":"如何让写代码更有快感呢，那就是多使用快捷键，练习传说中的微操 会持续更新····· 快捷键只列了自己不熟悉的功能，Preferences–&gt;key binding中有全面的 1234567891011121314151617181920ctr+shift+o 新建窗口ctr+o 提示打开文件ctr+n 新建文件ctr+s 保存文件ctr+shift+s 另存为ctr+F4 关闭文件ctr+w 关闭标签ctr+k+b (喜欢ctr按住)侧边栏隐藏/显示F11 全屏模式shift+F11 加强版全屏模式ctr+shift+z 恢复修改ctr+k+v (喜欢ctr按住)选择复制Home 去到一行的开头End 去到一行的结尾ctr+Home 去到文件的开头ctr+End 去到文件的结尾ctr+pageup 上一个标签ctr+pagedown下一个标签 快速生成代码片段在package Control中寻找相应的Snippets进行安装 Bootstrap3 Snippets Balbel Snippets 安装Emmet插件 写Html结构的利器(太酷了,强烈推荐) Emmet官网","categories":[{"name":"开发","slug":"开发","permalink":"http://jabbla.github.io/categories/开发/"}],"tags":[{"name":"效率工具","slug":"效率工具","permalink":"http://jabbla.github.io/tags/效率工具/"}]},{"title":"Hexo常用指令","slug":"Hexo常用指令","date":"2016-05-10T07:24:00.000Z","updated":"2016-08-14T10:09:07.917Z","comments":true,"path":"2016/05/10/Hexo常用指令/","link":"","permalink":"http://jabbla.github.io/2016/05/10/Hexo常用指令/","excerpt":"Hexo常用指令 大部分都是从官网复制粘贴，会持续更新 此后会写一篇，修改Hexo主题的教程，或者Hexo工作流程剖析","text":"Hexo常用指令 大部分都是从官网复制粘贴，会持续更新 此后会写一篇，修改Hexo主题的教程，或者Hexo工作流程剖析 Hexo的目录结构:12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes 1234567891011121314151617181920package.json&#123; \"name\": \"hexo-site\", \"version\": \"0.0.0\", \"private\": true, \"hexo\": &#123; \"version\": \"\" &#125;, \"dependencies\": &#123; \"hexo\": \"^3.0.0\", \"hexo-generator-archive\": \"^0.1.0\", \"hexo-generator-category\": \"^0.1.0\", \"hexo-generator-index\": \"^0.1.0\", \"hexo-generator-tag\": \"^0.1.0\", \"hexo-renderer-ejs\": \"^0.1.0\", \"hexo-renderer-stylus\": \"^0.2.0\", \"hexo-renderer-marked\": \"^0.2.4\", \"hexo-server\": \"^0.1.2\" &#125;&#125; scaffoldsScaffold folder. When you create a new post, Hexo bases the new file on the scaffold. sourceSource folder. This is where you put your site’s content. Hexo ignores hidden files and files or folders whose names are prefixed with _ (underscore) - except the _posts folder. Renderable files (e.g. Markdown, HTML) will be processed and put into the public folder, while other files will simply be copied. themesTheme folder. Hexo generates a static website by combining the site contents with the theme. Commandsnew1$ hexo new [layout] &lt;title&gt; Creates a new article. If no layout is provided, Hexo will use the default_layout from _config.yml. If the title contains spaces, surround it with quotation marks. generate1$ hexo generate Generates static files. Option Description12-d, --deploy Deploy after generation finishes-w, --watch Watch file changes publish1$ hexo publish [layout] &lt;filename&gt; Publishes a draft. server1$ hexo server Starts a local server. By default, this is at http://localhost:4000/. Option Description123-p, --port Override default port-s, --static Only serve static files-l, --log Enable logger. Override logger format. deploy1$ hexo deploy Deploys your website. Option Description1-g, --generate Generate before deployment render1$ hexo render &lt;file1&gt; [file2] ... Renders files. Option Description1-o, --output Output destination migrate1$ hexo migrate &lt;type&gt; Migrates content from other blog systems. clean1$ hexo clean Cleans the cache file (db.json) and generated files (public). list1$ hexo list &lt;type&gt; Lists all routes. version1$ hexo version Displays version information. Customize config file path1$ hexo --config custom.yml Uses a custom config file (instead of _config.yml). Display drafts1$ hexo --draft Displays draft posts (stored in the source/_drafts folder). Customize CWD1$ hexo --cwd /path/to/cwd Customizes the path of current working directory.","categories":[{"name":"学习","slug":"学习","permalink":"http://jabbla.github.io/categories/学习/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://jabbla.github.io/tags/hexo/"}]},{"title":"常见的几种数组排序算法JS实现","slug":"常见的几种数组排序算法JS实现","date":"2016-03-24T12:09:29.000Z","updated":"2016-08-14T10:04:42.968Z","comments":true,"path":"2016/03/24/常见的几种数组排序算法JS实现/","link":"","permalink":"http://jabbla.github.io/2016/03/24/常见的几种数组排序算法JS实现/","excerpt":"常见的几种数组排序算法JS实现 一些简单的排序js实现(小菜一只，大神勿喷)","text":"常见的几种数组排序算法JS实现 一些简单的排序js实现(小菜一只，大神勿喷) 快速排序 从给定的数据中，随机抽出一项，这项的左边放所有比它小的，右边放比它大的，然后再分别这两边执行上述操作，采用的是递归的思想，总结出来就是 实现一层，分别给两边递归，设置好出口 1234567891011121314151617181920212223242526272829303132333435function fastSort(array,head,tail)&#123; //考虑到给每个分区操作的时候都是在原有的数组中进行操作的，所以这里head,tail来确定分片的位置 /*生成随机项*/ var randomnum = Math.floor(ranDom(head,tail)); var random = array[randomnum]; /*将小于random的项放置在其左边 策略就是通过一个临时的数组来储存分好区的结果，再到原数组中替换*/ var arrayTemp = []; var unshiftHead = 0; for(var i = head;i &lt;= tail;i++)&#123; if(array[i]&lt;random)&#123; arrayTemp.unshift(array[i]); unshiftHead++; &#125;else if(array[i]&gt;random)&#123; arrayTemp.push(array[i]); &#125; /*当它等于的时候放哪，这里我想选择放到队列的前面，也就是从unshift后的第一个位置放置*/ if(array[i]===random)&#123; arrayTemp.splice(unshiftHead,0,array[i]); &#125; &#125; /*将对应项覆盖原来的记录*/ for(var j = head , u=0;j &lt;= tail;j++,u++)&#123; array.splice(j,1,arrayTemp[u]); &#125; /*寻找中间项所在的index*/ var nowIndex = array.indexOf(random); /*设置出口，当要放进去的片段只有2项的时候就可以收工了*/ if(arrayTemp.length &lt;= 2)&#123; return; &#125; /*递归，同时应用其左右两个区域*/ fastSort(array,head,nowIndex); fastSort(array,nowIndex+1,tail); &#125; 插入排序 思想就是在已经排好序的数组中插入到相应的位置，以从小到大排序为例，扫描已经排好序的片段的每一项，如大于，则继续往后，直到他小于一项时，将其插入到这项的前面 12345678910111213141516171819function insertSort(array)&#123; /*start根据已排列好的项数决定*/ var start=1; /*按顺序，每一项检查已排列好的序列*/ for(var i=start; i&lt;array.length; start++,i++)&#123; /*跟已排好序的序列做对比，并插入到合适的位置*/ for(var j=0; j&lt;start; j++)&#123; /*小于或者等于时（我们是升序）插入到该项前面*/ if(array[i]&lt;=array[j])&#123; console.log(array[i]+' '+array[j]); array.splice(j,0,array[i]); /*删除原有项*/ array.splice(i+1,1); break; &#125; &#125; &#125; &#125; 冒泡排序 故名思意 ，就是一个个冒泡到最前端或者最后端，主要是通过两两依次比较，以升序为例，如果前一项比后一项大则交换顺序，一直比到最后一对 12345678910111213function bubbleSort(array)&#123; /*给每个未确定的位置做循环*/ for(var unfix=array.length-1; unfix&gt;0; unfix--)&#123; /*给进度做个记录，比到未确定位置*/ for(var i=0; i&lt;unfix;i++)&#123; if(array[i]&gt;array[i+1])&#123; var temp = array[i]; array.splice(i,1,array[i+1]); array.splice(i+1,1,temp); &#125; &#125; &#125; &#125; 选择排序 将当前未确定块的min或者max取出来插到最前面或者后面 123456789101112131415161718function selectSort(array)&#123; /*给每个插入后的未确定的范围循环，初始是从0开始*/ for(var unfixed=0; unfixed&lt;array.length; unfixed++)&#123; /*设置当前范围的最小值和其索引*/ var min = array[unfixed]; var minIndex = unfixed; /*在该范围内选出最小值*/ for(var j=unfixed+1; j&lt;array.length; j++)&#123; if(min&gt;array[j])&#123; min = array[j]; minIndex = j; &#125; &#125; /*将最小值插入到unfixed，并且把它所在的原有项替换成*/ array.splice(unfixed,0,min); array.splice(minIndex+1,1); &#125; &#125; 总结一下，实现思想是很简单的,难点在于如何创造思想，还有就是个人的测试能力，和编程习惯，做注释其实不是仅仅为了别人看得更方便，而是自己思路的记录，有些人编着编着容易断片，注释起到了很好的引导作用","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://jabbla.github.io/tags/javascript/"},{"name":"算法","slug":"算法","permalink":"http://jabbla.github.io/tags/算法/"}]},{"title":"我所理解的JS执行环境和作用域链","slug":"我所理解的JS执行环境和作用域链","date":"2016-03-22T12:45:22.000Z","updated":"2016-08-14T09:55:50.195Z","comments":true,"path":"2016/03/22/我所理解的JS执行环境和作用域链/","link":"","permalink":"http://jabbla.github.io/2016/03/22/我所理解的JS执行环境和作用域链/","excerpt":"看了一些网上的关于JS机制的文章,结合自己在书上看的和自己的理解,把吸收到的捋捋直","text":"看了一些网上的关于JS机制的文章,结合自己在书上看的和自己的理解,把吸收到的捋捋直 执行流 JS包含在HTML文件里的外部文件里或者内嵌script中,每个文件或者代码块都是单独扫描的1234&lt;script&gt; fn1() //fn1 function fn1()&#123;alert('fn1');&#125;&lt;/script&gt; 123456&lt;script&gt; fn1() //error&lt;/script&gt;&lt;script&gt; function fn1()&#123;alert('fn1');&#125;&lt;/script&gt; 浏览器扫描此代码块 然后将具名函数的声明做预处理,然后代码按顺序执行 注意是在同一代码块中哦,浏览器对每个代码块或者文件都是单独扫描的,也就是说预处理的作用范围是单个代码块 之后按照全局顺序开始执行代码,执行流下行 执行环境每个函数都有自己的执行环境,当执行流进入函数时,会为函数生成一个执行环境和执行环境关联的变量对象,变量对象中存着定义在执行环境中的所有变量和函数,JS的全局环境是window对象执行环境栈 为保证代码有序地执行,通过执行流流过的顺序,执行环境依次入栈出栈12345var a = 0;function hello()&#123; a = a+1;&#125;hello() 全局环境入栈-&gt;执行到第5行把hello()执行环境推到栈顶-&gt;hello()出栈,执行流重新回到上一层环境 作用域链12345var a = 0;function hello()&#123; a = a+1;&#125;hello() 当执行流到达第2行时,它不会进入hello()因为它还没有被调用,只是把hello()函数上的作用域链的钩子指向全局函数的变量对象 当执行流到达第5行时,创建hello()的执行环境,生成自己的变量对象,并将作用域链的钩子挂到此时的 全局变量对象上 其实也就这么点东西,还是得多做做题,加深对这些概念的理解,深入学习,下午看的主要结论就是,概念看了谁都懂,主要还是得做一些不那么常规的题巩固记忆,和加深对概念的认识,OK.","categories":[{"name":"学习","slug":"学习","permalink":"http://jabbla.github.io/categories/学习/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://jabbla.github.io/tags/javascript/"}]},{"title":"当我们说Line-Height时候,都会谈论到神马","slug":"当我们说line-height时候-都会谈论到神马","date":"2016-03-20T07:14:05.000Z","updated":"2016-08-14T10:04:01.365Z","comments":true,"path":"2016/03/20/当我们说line-height时候-都会谈论到神马/","link":"","permalink":"http://jabbla.github.io/2016/03/20/当我们说line-height时候-都会谈论到神马/","excerpt":"作为一个初入前端的小鲜肉,这几天被line-height折腾得够呛 所以本着 你丫欺负我,我就刨你家祖坟的精神 今天就查查你家户口本","text":"作为一个初入前端的小鲜肉,这几天被line-height折腾得够呛 所以本着 你丫欺负我,我就刨你家祖坟的精神 今天就查查你家户口本 文中如果有什么不对的地方加我QQ387857274欢迎指正哦,前端爱好者也可以加一下,相互交流嘛个人认为,要想把这货彻底弄清楚就要,得先认识一下’基线’ 什么是基线红色这条线就是基线 是不是很像英语作业本中的线格,没错就是那玩意基线就是用来定位文字在一行中的显示位置,也就是说,一旦一行的基线的位置固定了,文字的位置也就固定了 line-height与基线的关系讲一讲绿线是什么鬼 绿线其实是我意淫出来的0.0 绿线的用处主要就是确定每行content_area,应该和好多文章中所提到的行内框相似 绿线的跨度是由该行内font-size最大的那个元素决定绿线的跨度的改变也会影响基线的位置好比姚明很高,所以他的屁股也会很高 绿线跟line-height有什么关系上方区域和下方区域的高度是一致的,我手残只能这样了 那么上方区域或者下方区域是如何计算的呢,就是((line-height)-绿线的跨度)/2也就是说这行的上方区域和上一行的下方区域共同组成行间距一号,同样下方区域和下一行的上方区域组成行间距二号 好吧这里好像跟基线并没有半毛钱关系,我承认,不过也可认为是姚明和他屁股的关系,line-height 会决定本行的位置,同时也就是会影响基线 基线会影响谁呢大家都知道,有inline,inline-block,block三种东西 一. inline我们把它看做一个由内容撑开的元素,被基线影响 二. inline-block中存在基线,其中的inline元素也被基线影响,不过inline-block会继承父元素的line-height 这里大家可能会产生疑问,看图,红色是父级元素pp设置line-height之前 p设置line-height:600px后;两个盒子的基线被拉到下面 这里有一些关于一行的基线到底归谁管的问题,请往下看 三. block跟inline-block是一样一样的区别在于block这货一下占一行 一行的基线到底归谁管 你可以笼统地说是line-height,这句话本身是没什么问题的,不过现实情况要比想象的要复杂一点,还有就是图片和空的inline-block也会影响基线的位置(很诡异吧,我也觉得) 情况1 还是上面的图,当两个inlin-block不设置任何line-height的时候 &gt; p元素设置line-height:600px;可以看到第一行的基线沉下去了 情况2 当只有黄色inline-block设置line-height的时候,同时绿色的本身&gt; 基线会向整体基线靠拢 情况3 当两个货都设置不同的line-height呢绿色会调整自己的位置使自身基线向行基线靠拢 情况4 当存在空的inline-bolck时,也会把基线下沉 情况5 当行中加入图片后,本行的基线会随图片的高度而下沉,其它元素的基线也同时超主基线靠拢 这里得到的结论是:该行的line-height最终结果是子元素中最大的line-height,然后其它元素的line-height设置完成之后基线会朝整行基线靠拢心得就是还是慎用inline-block,个人认为float比inline-block好太多,能不用就不用以上都是个人观点 这是我研究一早上的结果,想交流的小伙伴可以加我qq387857274,共同进步关于更详细的知识内容见下面的参考资料参考链接CSS深入理解之line-height","categories":[{"name":"学习","slug":"学习","permalink":"http://jabbla.github.io/categories/学习/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://jabbla.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"http://jabbla.github.io/tags/CSS/"}]}]}