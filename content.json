{"meta":{"title":"Gloria","subtitle":"zxr's blog","description":"sadad","author":"Zxr","url":"http://jabbla.github.io"},"pages":[{"title":"关于我","date":"2016-08-13T07:21:24.000Z","updated":"2016-08-20T13:32:57.764Z","comments":true,"path":"about/index.html","permalink":"http://jabbla.github.io/about/index.html","excerpt":"","text":"爱篮球，爱滑雪，爱R&amp;B 爱前端，爱挑战，爱刺激 沉迷地狱，无法自拔，^_^"}],"posts":[{"title":"SVG元素上的transform","slug":"SVG元素上的transform","date":"2016-09-06T04:41:00.000Z","updated":"2016-09-06T04:43:53.826Z","comments":true,"path":"2016/09/06/SVG元素上的transform/","link":"","permalink":"http://jabbla.github.io/2016/09/06/SVG元素上的transform/","excerpt":"同HTML元素一样，我们可以通过transform函数操作SVG元素。然而transform在SVG元素和HTML元素上的工作方式会有一些差别。","text":"同HTML元素一样，我们可以通过transform函数操作SVG元素。然而transform在SVG元素和HTML元素上的工作方式会有一些差别。首先，IE不支持SVG元素的CSS transform属性，但是如果只是应用一些2D变换，为了适配IE,我们可以使用SVG的transform属性。 SVG的transform属性中的所有函数的参数只能是纯数字，比如说，我们不能在translate函数中使用%单位（虽说在火狐浏览器中的css transform属性也不能使用—此处有链接—），rotate，skew角度只能使用deg单位，我们能在css transform属性中可以使用的所有其它单位在这里都不能使用。 注：火狐浏览器现在已经支持transform-origin上应用带有%的值，不过与chorme不同的是，火狐的%是相对于svg画布而不是元素自身。 而且蛋疼的是，JS的特征检测会有问题（通过js读取在外部css文件中设置的transform属性会返回与其等价的矩阵），所以我们需要另外一种检测IE的方法，或者直接在html上书写transform属性。 SVG元素和HTML元素工作方式的差异，主要是由元素坐标系的不同造成的。无论是HTML元素还是SVG元素，都有一个自己的坐标系。对于HTML元素，初始的坐标原点在元素的中心。对于SVG元素，其坐标系原点是在svg画板的（0，0）处（假设在svg标签内祖先元素和自身都不存在任何变换）。如果SVG元素的中心点不在画板的(0,0)点，像rotate,scale或者skew这些变换的结果，都会与HTML元素上应用的结果大不一样。 为了更好地理解这些差异，让我们来看看transform函数是如何工作的。 transform函数是如何工作的我们要清楚在一个存在嵌套的元素上应用变换会有叠加效果。也就是说，在一个包含后代的元素上应用变换，后代元素也会根据自己的坐标系产生相应的变换。为了方便起见，我们后面的例子都是以祖先元素不存在变换，并且其中不包含任何子孙元素为前提的。 位移translation会在相同的方向上以相同的距离移动元素上的所有点，并且会保留元素上除了位置信息的所有其它信息。这种位移可以被解释成移动一个元素的坐标原点，所以位置是相对于那个坐标原点的任何元素都会被移动。这种位移之后的效果并不依赖于坐标系的位置。 translate transform: HTML 元素 (左边) vs SVG 元素 (右边) 上面的图片展示了当translate分别应用到HTML元素和SVG元素上的区别。 正如我们看到的，它们的区别在于各自坐标系的位置。HTML元素的坐标原点在自身50% 50%处，SVG元素的坐标原点在SVG画布0 0处，不过无论坐标原点处在什么位置，它们最后呈现的效果都是一样的。 对于HTML和SVG元素，我们都可以在 CSS transform 中使用3种2D的位移函数：translateX(tx),translateY(ty)和translate(tx[, ty])。前两个分别作用在 X方向 和 Y方向(相对于元素自身的坐标系)。需要注意的是，如果在translate之前存在另外的变换，X方向，Y方向就可能不再代表着水平方向，垂直方向。而第三个位移函数则同时在x,y方向上分别移动tx,ty个单位，ty是可选的，如果不明确指定，默认是0。 SVG元素除了CSS tranform属性，还有SVG tranform属性。在这个例子中，我们在tranform属性中只定义了translate，SVG属性中可以使用逗号分隔，或者空格分隔，其中1代表着1px，下面的两种为SVG元素应用位移的方式是等价的： 使用CSS transform:1234rec &#123; /* doesn't work in IE */ transform: translate(295px, 115px);&#125; 使用SVG transform:1&lt;rect width='150' height='80' transform='translate(295 115)' /&gt; 注：SVG transform 和 CSS transform 将会被合并 连续的translate()将会被相加在一起，比如我们可以书写一个与translate(tx1 + tx2, ty1 + ty2)等价的链式写法translate(tx1, ty1) translate(tx2, ty2)，注意，这种等价关系只有当两个translate()之间没有任何其它的转换的情况下成立。从translate(tx, ty)返回到初始状态，应用translate(-tx, -ty)即可。 旋转2D旋转会基于一个固定点将元素及其子孙元素旋转一定的角度（固定点的位置在旋转前后不会被改变），旋转后的效果会因固定点位置的变化而不同。就像位移一样，旋转不会扭曲元素，元素自身的属性不会发生变化。rotate()同样具有可加性，在相反的方向应用相同角度的rotate()就能返回到初始状态。 上面展示了在两种不同元素上应用rotate()的区别。旋转一个元素，其自身的坐标系会基于原点旋转相同的角度，同时也会应用到后代元素。 一个元素上的所有点都会绕着自身的坐标原点旋转，HTML元素的坐标原点在50% 50%处，SVG元素的坐标原点则是在SVG画板的0 0处。 CSS transform中的2D旋转函数就是rotate(angle)。angle可以是多种单位的值： degrees，radians，turn,grad,我们也可以使用calc()(比如calc(.25turn - 30deg) )，这个属性现在只能在Chorme 38+/Opera 25+使用， 如果angle是正值，将会沿着顺时针方向旋转（反之，则会是逆时针）。 在SVG的transform属性中的旋转函数是这样的：rotate(angle[ x y])，angle的值与CSS transform属性中的一样(必须是无单位的degree值，正值表示顺时针旋转，负值反之，可选的x y表示旋转时固定点的位置，其值默认是该元素坐标系的原点)，如果只有x，则变换无效。 与translate()一样，参数可以使用逗号或者空格分隔。 指定x y不代表该元素的坐标原点被移动到了x y上，就像元素一样，其坐标系也同时绕着x y点旋转。 也就是说，我们可以使用两种方法旋转一个SVG元素(效果可以在上面的图片中看到)。 使用CSS transform:1234rect &#123; /* doesn't work in IE */ transform: rotate(45deg);&#125; 使用SVG transform属性：12&lt;!-- works everywhere --&gt;&lt;rect x='65' y='65' width='150' height='80' transform='rotate(45)' /&gt; 我们可以在CSS transform中指定transform-origin属性来模拟SVG中的x y参数，长度单位是相对于元素坐标系而言的，百分比单位则是以元素自身为基准，完美！！不过也有一些需要注意的地方。 首先，transform-origin，rotate()中指定固定点，两者是不一样的，比如我们需要绕着元素的50% 50%点旋转SVG元素，下面是两种实现方式：12345678rect &#123; transform: rotate(45deg); /* doesn't work as intended in Firefox * % values are taken relative to the SVG, not the element * which actually seems to be correct */ transform-origin: 50% 50%;&#125; 1234&lt;rect x='65' y='65' width='150' height='80' transform='rotate(45 140 105)' /&gt;&lt;!-- 140 = 65 + 150/2 --&gt;&lt;!-- 105 = 65 + 80/2 --&gt; 在Chorme中两者实现了相同的效果，如下图 围绕一个固定点旋转一个 SVG 元素: 使用 CSS (左边) vs. 使用SVG transform(右边) 正如上图所展示的，第一个CSS transform例子会将元素的坐标系原点移动到自身的50% 50%位置，然后基于坐标系原点旋转，第二个SVG transform例子则是仅仅将元素中心点的位置作为旋转的固定点，自身的坐标系并没有因此改变，所以所有基于自身坐标系的变换都不会发生变化。 为了加深理解，我们再应用一个相同角度45°，相反方向的roatate()：1234rect &#123; transform: rotate(45deg) rotate(-45deg); transform-origin: 50% 50%; /* Chrome, Firefox behaves differently */&#125; 1234&lt;rect x='65' y='65' width='150' height='80' transform='rotate(45 140 105) rotate(-45)' /&gt;&lt;!-- 140 = 65 + 150/2 --&gt;&lt;!-- 105 = 65 + 80/2 --&gt; 在SVG元素上链式调用旋转: CSS transforms (左边) vs. SVG transform (右边) 如图所示，在CSS transform中，设置transform-origin为50% 50%，两次的rotate()会相互抵消，因为两次的旋转都是围绕坐标系原点50% 50%，而在SVG transform中，第一次指定了旋转的固定点在元素中心，而第二次并没有指定，所以默认以元素坐标系原点为固定点。如果想实现预期的效果可以指定第二个为:rotate(-45 140 105)而不是rotate(-45)。 我们能为SVG transform的每个roatate()指定不同的固定点，但是只能为CSS transform的每个rotate()指定一个transform-origin。如果想实现一个矩形先绕右下角的点旋转90°,再绕右上角旋转90°，对于SVG tranform来说很容易实现，为每个rotate()指定不同的固定点就可以了：12345678910&lt;rect x='0' y='80' width='150' height='80' transform='rotate(90 150 160) rotate(90 150 80)'/&gt;&lt;!--bottom right: x = x-offset + width = 0 + 150 = 150 y = y-offset + height = 80 + 80 = 160top right: x = x-offset + width = 0 + 150 = 150 y = y-offset = 80--&gt; 链式调用不同固定点的rotate (SVG transform ) 我们如何做到在CSS transform中实现相同的效果呢？第一步很简单，我们可以指定transform-origin为right bottom，但是第二步呢？如果只是简单地链式书写在第一个的后面， 元素会以right bottom为固定点再次旋转90°。 为了忽略transform-origin的位置，我们需要再添加3个变换，第 一个就是 translate(x, y) ，为了与第二次的旋转固定点对应，我们使用 translate(x, y) 使元素的坐标系原点和我们希望的固定点重合，第二个就是旋转，第三个是translate(-x, -y)(第一次变换的相反操作)。 下面是上面例子的代码：1234567891011rect &#123; /* doesn't work as intended in Firefox * % values are taken relative to the SVG, not the element * which actually seems to be correct */ transform-origin: right bottom; /* or 100% 100%, same thing */ transform: rotate(90deg) translate(0, -100%) /* go from bottom right to top right */ rotate(90deg) translate(0, 100%);&#125; 下面这张图片展示了上面代码的步骤： 链式CSS transform的工作流程 然而在火狐浏览器中,transform-origin只能使用长度单位，translate()中的百分比单位也不能使用。 注：在火狐浏览器中transform-origin已经支持百分比单位了，但是它的行为与chorme不太一样，所以我们不建议您使用这个方法。 缩放缩放会在相应的方向上应用缩放因子，然后改变元素所有点到其坐标系原点到的距离。除非各个方向的缩放因子都是相同的，不然该元素的形状必定被改变。 在(-1,1)范围之内的缩放因子会缩小元素，范围之外的因子则会放大元素。一个负值的因子不仅会改变元素的大小，还会基于坐标系原点镜像处理所有的点。如果因子不等于1，那么在相应的方向上就会出现缩放的情况。 一个缩放函数的效果会依赖元素坐标系原点的位置，对于同一个元素，两个具有相同缩放因子的缩放函数，会因为不同的坐标系原点表现出不同的效果。 scale transform: HTML 元素 (左边) vs SVG 元素 (右边) 上图是分别在HTML元素和SVG元素上应用缩放的不同结果，两者拥有完全相同的缩放因子，不同的是，HTML元素的坐标系原点在元素50% 50%处，而SVG元素的坐标原点则是SVG画板的0 0处。 在CSS transform中有3种2D的缩放函数： scale(sx[, sy]) scaleX(sx) scaleX(sx) scaleY(sy)。第一个函数，会同时在x和y方向上应用sx和sy缩放因子，sy是可选的，如果该函数只有一个参数，会默认是sx的值。其它两个函数是分别在两个方向进行缩放，scaleX(sx) scaleY(sy)分别等价于scale(sx,1) scale(1,sy)，如果在此之前存在其它的变换，那么相应的x和y方向将不再是水平和垂直的。 在SVG transform中，只有scale(sx[ sy])。同样，可以使用空格或者逗号分隔参数。 对于SVG元素来说，以下的两种缩放方法是等价的： 使用CSS transform:1234rect &#123; /* doesn't work in IE */ transform: scale(2, 1.5);&#125; 使用SVG transform:12&lt;!-- works everywhere --&gt;&lt;rect x='65' y='65' width='150' height='80' transform='scale(2 1.5)' /&gt; 在同一个元素上应用上面两种方法会产生相同的效果，就像上一个图片中的右边的区域。如果我想实现像应用在HTML元素上一样的效果呢？来看一看我是如何让实现的。 我们可以使用CSS transform中的transform-origin改变元素的坐标原点，或者使用translate() scale() translate()这样的组合，在第二种方法中，我们先将元素坐标系原点移动到元素的50% 50%位置，然后应用缩放，最后做与第一个位移相反的操作。如果使用SVG transform属性，我们只能使用前面CSS transform中的第二种方式，类似的方法，下面是具体的代码。 使用CSS transform中的transform-origin：123456789rect &#123; /* doesn't work in IE */ transform: scale(2, 1.5); /* doesn't work as intended in Firefox * % values are taken relative to the SVG, not the element * which actually seems to be correct */ transform-origin: 50% 50%;&#125; 在CSS transform中链式调用：123456rect &#123; /* doesn't work in IE */ transform: translate(140px, 105px) scale(2 1.5) translate(-140px, -105px);&#125; 在SVG transform中链式调用:123&lt;rect x='65' y='65' width='150' height='80' transform='translate(140 105) scale(2 1.5) translate(-140 -105)'/&gt;&lt;!-- works everywhere --&gt; 下面的demo将会展示链式调用的工作过程（点击播放►按钮开始） See the Pen Chaining on SVG elements to scale wrt a certain point by Ana Tudor (@thebabydino) on CodePen. 还有就是，两个连续的scale()如scale(sx1, sy1) scale(sx2, sy2),可以写成scale(sx1*sx2, sy1*sy2)。scale(1/sx1, 1/sy1)可以对scale(sx1,sy1)做相反的操作。如果所有的scale()参数的绝对值等于1，那么这个元素不产生任何的缩放。 倾斜倾斜操作会将元素上所有点的坐标值在相应的方向上移动一段距离，这段距离取决于倾斜的角度而和每个点到倾斜轴的距离。也就是说，在一个方向上倾斜，另一个方向上的所有点相应的坐标值不会被改变。倾斜一个元素必定会扭曲这个元素，这点和旋转不太一样，倾斜一个矩形，这个矩形会变成不等边的平行四边形，倾斜一个圆，这个圆会变成椭圆。倾斜操作过后，角度(对于倾斜角α，矩形的直角将会变成90° ± α)或者长度都会发生变化，但是元素的原始区域会被保留。 另外，与位移，旋转不一样的是，倾斜不具有可加性，连续两次α1 α2的倾斜，不等于一次α1+α2的倾斜。 下面的demo展示了倾斜的工作方式，你可以调整倾斜轴，倾斜角度，瞧瞧它们是如何作用于初始正方形的： See the Pen How the skew transform works by Ana Tudor (@thebabydino) on CodePen. 倾斜的角度等于初始轴与终轴的夹角(非倾斜轴)，如果应用[0°, 90°]夹角的倾斜，元素上所有点倾斜轴方向上的坐标会加上与其非倾斜轴方向坐标符号相等的值，如果是[-90°, 0°]，则该值的符号相反。 如果我们应用一个在X轴方向上的倾斜，元素y轴方向的坐标保持不变，X轴方向的坐标会增加或者减少d，这个d取决于倾斜角度和该点y轴上的坐标，顶边和底边的长度不变，两侧的长度会随着倾斜角度的增加而增加，当角度为±90°时两侧将会是无限长，当角度慢慢靠近±180°的时候，两侧的长度将会逐渐减少。 注：(90°, 180°]之间的角α等同于α - 180°（落在区间(-90°, 0°]），同样，如果α在(-180°, -90°]之间，则等同于α + 180°(落在区间[0°, 90°)) 同样，如果我们应用一个在y轴方向上的倾斜，元素X轴方向的坐标保持不变，y轴方向的坐标会增加或者减少d，这个d取决于倾斜角度和该点X轴上的坐标，两侧的长度不变，上下的长度会随着倾斜角度的增加而增加，当角度为±90°时上下将会是无限长，当角度慢慢靠近±180°的时候，上下的长度将会逐渐减少。 倾斜操作与旋转操作一样，元素的坐标原点都会影响最终的呈现效果，对同一个元素在相同的轴方向上做相同倾斜操作，会产生不同的结果： skew transform: HTML元素 (左边) vs SVG元素 (右边) 以上是分别对HTML元素和SVG元素做相同的倾斜操作后的图片，相同的角度，相同的倾斜轴，不同的是，它们的坐标原点不一样。HTML元素在其50% 50%处，SVG元素在SVG画布的0 0处。 方便起见，在这我们只关注元素上的一个点：右上角。两者右上角在垂直方向上始终保持不变，在水平方向上，HTML元素中向左平移，SVG元素中向右平移，右下角都向右平移。为什么会这样？ 就像前面提到的，X轴方向的倾斜，y轴方向的坐标保持不变，X轴方向的坐标会增加或者减少d，这个d取决于倾斜角度和该点y轴上的坐标。如果倾斜角在[0°, 90°]之间，则d的符号与y坐标相同，如果在[-90°, 0°]之间，则相反。 在这个例子中，倾斜角是60°，所以在这里右上角y轴方向的坐标是导致两者不同的关键，在HTML元素中，由于坐标系原点在元素中央，所以右上角的y坐标为负值，在SVG元素中，坐标系原点在SVG画板的0 0处，所以右上角y坐标为正值。像上面所说的，这样分别加在两者右上角d的符号也是相反的，也就造成了HTML元素的右上角向左移动，SVG元素的右上角向右移动。 无论是CSS transform还是SVG transform，都有两个倾斜函数:skewX(angle)和skewY(angle)，前者的倾斜轴是X轴，后者的倾斜轴是y轴。 在CSS transform中，angle的单位可以是deg rad turn grad ,还能使用calc()(需要牢记的是，只有Blink内核的浏览器支持在calc()中计算角度) 在SVG transform中，倾斜角度都是没有单位的deg值。 也就是说有两种方法书写上一张图片中右边的效果： 使用CSS transform:123rect &#123; transform: skewX(60deg); /* doesn't work in IE */&#125; 使用SVG transform:12&lt;!-- works everywhere --&gt;&lt;rect x='65' y='65' width='150' height='80' transform='skewX(60)' /&gt; 如果我想实现像应用在HTML元素上一样的效果呢？就像旋转一样，存在3种方式： 使用CSS transform的transform-origin(不建议使用):123456789rect &#123; /* doesn't work in IE */ transform: skewX(60deg); /* doesn't work as intended in Firefox * % values are taken relative to the SVG, not the element * which actually seems to be correct */ transform-origin: 50% 50%;&#125; 在CSS transform中链式调用：123456rect &#123; /* doesn't work in IE */ transform: translate(140px, 105px) skewX(60deg) translate(-140px, -105px);&#125; 在SVG transform中链式调用:123&lt;!-- works everywhere --&gt;&lt;rect x='65' y='65' width='150' height='80' transform='translate(140 105) skewX(60) translate(-140 -105)' /&gt; 下面的demo将会展示链式调用的工作过程（点击播放►按钮开始） See the Pen Chaining on SVG elements to skew wrt a certain point by Ana Tudor (@thebabydino) on CodePen. 缩短调用链我们可以通过链式调用，在SVG元素上实现在HTML元素上进行rotate scale skew操作一样的效果，使用SVG transform也能做到兼容IE浏览器。然而，你不觉得这样的写法很丑陋么？难道就没有更加简便的方式？ 如果我们可以将元素的坐标系原点移动到元素自身的50% 50%处，那么调用链会大大缩短，像下面这样：123&lt;rect x='-75' y='-40' width='150' height='80' transform='translate(140 105) rotate(45)'/&gt;&lt;!-- 75 = 150/2, 40 = 80/2 --&gt; See the Pen Chaining on SVG elements to rotate wrt a certain point #1 by Ana Tudor (@thebabydino) on CodePen. 如果使用SVG元素的viewBox属性，第一个translate也能被精简掉。viewBox属性中有4个值，前两个指定了SVG画布的左上角在显示区域的位置，后两个则是SVG画布显示区域的width和height，如果没有明确指定viewBox，画布的位置就是在显示区域的0 0处。 下面的两张图片能很好地展现viewBox=&#39;-140 -105 280 210&#39;使用前和使用后的区别。 viewBox使用前 vs. viewBox使用后 回到刚才的话题，如果想将SVG画布的坐标原点0 0移动到矩形的中心点，我们可以像下面这样设置viewBox:123&lt;svg viewBox='-140 -105 650 350'&gt; &lt;rect x='-75' y='-40' width='150' height='80' transform='rotate(45)'/&gt;&lt;/svg&gt; See the Pen Setting proper viewBox to rotate wrt a certain point #1 by Ana Tudor (@thebabydino) on CodePen. 实际使用将SVG画布的原点移动到元素的中心点，可以大大简化SVG图形的变换操作。下面的demo展示了3个四角星(点击播放/暂停)，最初都在中央，然后各自旋转，平移，倾斜，缩放，当中并没有使用transform-origin或者链式调用： See the Pen SVG Stars - final by Ana Tudor (@thebabydino) on CodePen. 让我们看一看，这个demo是如何一步一步工作的。 非常轻松地画出四角星（其实就是一个包含8个点的多边形） See the Pen 4 point star - the points by Ana Tudor (@thebabydino) on CodePen. 有3个这样的星星，我不想连续3次重复定义这个多边形，所以使用了1个&lt;defs&gt;和3个&lt;use&gt;:1234567891011&lt;svg viewBox='-512 -512 1024 1024'&gt; &lt;defs&gt; &lt;polygon id='star' points='250,0 64,64 0,250 -64,64 -250,0 -64,-64 0,-250 64,-64'/&gt; &lt;/defs&gt; &lt;g&gt; &lt;use xlink:href='#star'/&gt; &lt;use xlink:href='#star'/&gt; &lt;use xlink:href='#star'/&gt; &lt;/g&gt;&lt;/svg&gt; 首先，星星需要从0放大到1:12345678use &#123; animation: ani 4s linear infinite;&#125;@keyframes ani &#123; 0% &#123; transform: scale(0); &#125; 25%, 100% &#123; transform: scale(1); &#125;&#125; 上面的代码实现的效果： See the Pen SVG Stars - step #1 by Ana Tudor (@thebabydino) on CodePen. 下一步就是为我们的动画增加旋转效果，同时我希望每一个星星都有不同的旋转角度，下面是代码：123456789101112131415161718$n: 3;$α: 360deg/$n;$β: random($α/1deg)*1deg;@for $i from 1 through $n &#123; $γ: $β + ($i - 1)*$α; use:nth-of-type(#&#123;$i&#125;) &#123; fill: hsl($γ, 100%, 80%); animation: ani-#&#123;$i&#125; 4s linear infinite; &#125; @keyframes ani-#&#123;$i&#125; &#123; 0% &#123; transform: scale(0); &#125; 25% &#123; transform: scale(1); &#125; 50%, 100% &#123; transform: rotate($γ); &#125; &#125;&#125; 实现的效果如下： See the Pen SVG Stars - step #2 by Ana Tudor (@thebabydino) on CodePen. 下一步，平移，旋转：12345678@keyframes ani-#&#123;$i&#125; &#123; 0% &#123; transform: scale(0); &#125; 25% &#123; transform: scale(1); &#125; 50% &#123; transform: rotate($γ); &#125; 75%, 100% &#123; transform: rotate($γ) translate(13em) scale(.2); &#125;&#125; See the Pen SVG Stars - step #3 by Ana Tudor (@thebabydino) on CodePen. 好了，我们还需要与缩放配合，添加倾斜效果：1234567891011121314151617181920@keyframes ani-#&#123;$i&#125; &#123; 0% &#123; transform: scale(0); &#125; 25% &#123; transform: scale(1); &#125; 50% &#123; transform: rotate($γ); &#125; 75% &#123; transform: rotate($γ) translate(13em) scale(.2); &#125; 83% &#123; transform: rotate($γ) translate(13em) scale(.2) skewY(30deg) scaleX(.866); &#125; 91% &#123; transform: rotate($γ) translate(13em) scale(.2) skewY(60deg) scaleX(.5); &#125; 100% &#123; transform: rotate($γ) translate(13em) scale(.2) skewY(90deg) scaleX(0); &#125;&#125; 我在原来的基础上添加一些帧。当倾斜角线性变化的时候，其缩放因子会像余弦函数一样变化，如下图一样： 三角函数 正弦 (蓝色) 余弦 (红色) 在火狐浏览器中，这个纯CSS的demo有点蛋疼，然后因为IE不支持SVG元素上的CSS transform,所以这个demo在IE上也不能运行，使其兼容IE只能使用SVG transform，然后配合javascript动态地改变那些值，下面是这个兼容版本(点击开始)： See the Pen Stars - JS version by Ana Tudor (@thebabydino) on CodePen.","categories":[{"name":"译文","slug":"译文","permalink":"http://jabbla.github.io/categories/译文/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://jabbla.github.io/tags/CSS/"},{"name":"SVG","slug":"SVG","permalink":"http://jabbla.github.io/tags/SVG/"}]},{"title":"HTML元素上的SVG滤镜","slug":"HTML元素上的SVG滤镜","date":"2016-08-30T03:28:00.000Z","updated":"2016-08-30T03:33:21.968Z","comments":true,"path":"2016/08/30/HTML元素上的SVG滤镜/","link":"","permalink":"http://jabbla.github.io/2016/08/30/HTML元素上的SVG滤镜/","excerpt":"上周看到有一篇关于CSS滤镜效果函数的文章，其中的效果函数相对来说比较容易理解，而且上手难度低。但是，这种方式仅仅是添加CSS滤镜效果众多方式中最弱的一种。今天让我们来看一看滤镜基元，这是为图片和元素添加滤镜效果另外一种更加强大的方法。","text":"上周看到有一篇关于CSS滤镜效果函数的文章，其中的效果函数相对来说比较容易理解，而且上手难度低。但是，这种方式仅仅是添加CSS滤镜效果众多方式中最弱的一种。今天让我们来看一看滤镜基元，这是为图片和元素添加滤镜效果另外一种更加强大的方法。相较于效果函数，滤镜基元为我们提供了更多的东西。一方面原因是滤镜基元有更多的效果。另一方面是在两者相似的地方，滤镜基元为我们提供了更多的使用方式。 滤镜基元其实比较复杂，很难在一篇文章中展现它的全貌，在这里需要说一声抱歉。 我发现官方文档的描述比较模糊，而且缺乏一些帮助我们理解的例子。我也查过一些资料，但是大多数都是在讨论SVG滤镜本身。不过，高兴的是，我可以轻松地让例子跑起来了，这个例子会在下面给出。有一点不太满意的地方是，它不是在所有的浏览器中都能运行。但是我相信，未来这些浏览器都会支持。 什么是CSS滤镜基元？滤镜基元和效果函数并没有多么不同。在许多方面，他们只是用不同方式做着同样的事情。基元最初是被作为SVG滤镜开发的，之后被扩展到不仅仅支持SVG图片。 像效果函数一样，滤镜基元是一种不需要图片编辑器就可以添加滤镜效果的一种方法。这使得它更加灵活，并且不具破坏性。它被写在SVG标记中，然后可以通过CSS filter属性的url值应用到图片或者元素上。123.filtered &#123; filter: url(path-to-filter-primitives);&#125; 滤镜基元的概念不再像以前那样复杂。它只是与效果函数的书写方式不一样，它还提供了更多的选项，然后以不同的方式将滤镜应用于目标元素。例子或许是帮你弄清它是什么及其工作方式的最佳方法。 如果您从未接触过CSS滤镜相关的内容，建议您可以点击这里进行了解 使用SVG滤镜基元hue-rotate是一个效果函数，你可以像下面这样使用它：1filter: hue-rotate(60deg); 等价的滤镜基元会是下面这样：1&lt;feColorMatrix type=\"hueRotate\" values=\"60\"/&gt; 这是一个标记，而不是CSS，它有一个新名字，你可以看到type属性有一个和效果函数的函数名相似的值，我们还需要更多的代码来让上面的基元工作，但是我想你已经知道了基元和效果函数的关联。 HTML结构很简单：123&lt;div class=\"filtered\"&gt; &lt;img src=\"images/strawberry-fields.jpg\" /&gt;&lt;/div&gt; CSS同样很简单：1filter: url(filters.svg#filter-primitives); 我使用了filter属性的url值，并且将url指向filters.svg文件。在这个文件中，我通过id名为filter-primitives调用了具体的滤镜。 到目前为止，步骤都很简单，现在我们需要定义相应的滤镜。这里是完整的filters.svg文件1234567891011121314&lt;?xml version=\"1.0\"?&gt;&lt;!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"&gt;&lt;svg xmlns=\"http://www.w3.org/2000/svg\"&gt;&lt;defs&gt; &lt;filter id=\"filter-primitives\"&gt; &lt;feGaussianBlur stdDeviation=\"3\" /&gt; &lt;feColorMatrix type=\"hueRotate\" values=\"270\"/&gt; &lt;feColorMatrix type=\"saturate\" values=\"0.75\"/&gt; &lt;feBlend mode=\"multiply\"/&gt; &lt;/filter&gt;&lt;/defs&gt;&lt;/svg&gt; 这个文件首先定义了自己是用xml语言书写的SVG文档。接下来是SVG对象。滤镜定义在defs元素中。它的id就是我们刚才在CSS中引用的那个。这里我应用了4个滤镜基元。我希望各自都可以最大化发挥各自的作用。 还有一些需要注意的事情，就是同时使用了hue-rotate和saturate，每一个都是独一无二的滤镜，但是不仅仅局限于hue 和 saturation，它还有一个luminanceToAlpha值，你也可以直接将一个矩阵赋值给它。 我知道你已经习惯使用ps或者其它图片编辑器，同样需要注意的是，这里虽然没有所有的混合滤镜，但是我们有 normal、 multiply、 screen、 darken和 lighten。 让我们来看一个例子。我会将滤镜应用在下面这张图片： HTML结构很简单：123&lt;div class=\"filtered\"&gt; &lt;img src=\"images/strawberry-fields.jpg\" /&gt;&lt;/div&gt; CSS同样很简单：1filter: url(filters.svg#filter-primitives); 我使用了filter属性的url值，并且将url指向filters.svg文件。在这个文件中，我通过id名为filter-primitives调用了具体的滤镜。 到目前为止，步骤都很简单，现在我们需要定义相应的滤镜。这里是完整的filters.svg文件1234567891011121314&lt;?xml version=\"1.0\"?&gt;&lt;!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"&gt;&lt;svg xmlns=\"http://www.w3.org/2000/svg\"&gt;&lt;defs&gt; &lt;filter id=\"filter-primitives\"&gt; &lt;feGaussianBlur stdDeviation=\"3\" /&gt; &lt;feColorMatrix type=\"hueRotate\" values=\"270\"/&gt; &lt;feColorMatrix type=\"saturate\" values=\"0.75\"/&gt; &lt;feBlend mode=\"multiply\"/&gt; &lt;/filter&gt;&lt;/defs&gt;&lt;/svg&gt; 这个文件首先定义了自己是用xml语言书写的SVG文档。接下来是SVG对象。滤镜定义在defs元素中。它的id就是我们刚才在CSS中引用的那个。这里我应用了4个滤镜基元。我希望各自都可以最大化发挥各自的作用。 还有一些需要注意的事情，就是同时使用了hue-rotate和saturate，每一个都是独一无二的滤镜，但是不仅仅局限于hue 和 saturation，它还有一个luminanceToAlpha值，你也可以直接将一个矩阵赋值给它。 我知道你已经习惯使用ps或者其它图片编辑器，同样需要注意的是，这里虽然没有所有的混合滤镜，但是我们有 normal、 multiply、 screen、 darken和 lighten。 应用上面的滤镜会得到下面这张图片： 上面的例子能完美地在Firefox运行，但是在Chrome Canary和Safari中就悲剧了。为了让上面的例子也能在这两个浏览器中正常运行，于是，我将所有的代码都写在了index.html中。1234567891011121314&lt;svg&gt; &lt;image x=\"0\" y=\"0\" width=\"800\" height=\"600\" xlink:href=\"images/strawberry-fields.jpg\" filter=\"url(#filter-primitives)\"&gt;&lt;/image&gt;&lt;/svg&gt;&lt;svg&gt; &lt;defs&gt; &lt;filter id=\"filter-primitives\"&gt; &lt;feGaussianBlur stdDeviation=\"0\" /&gt; &lt;feColorMatrix type=\"hueRotate\" values=\"270\"/&gt; &lt;feColorMatrix type=\"saturate\" values=\"0.75\"/&gt; &lt;feBlend mode=\"multiply\"/&gt; &lt;/filter&gt; &lt;/defs&gt;&lt;/svg&gt; 所有的东西都在同一个文件中，而不是通过CSS链接外部文件。滤镜没有变。图片元素由原始的HTML图片变为SVG图片。 有趣的是，这个例子在Firefox里居然是。。。。滤镜确实应用在了图片上，但是Firefox只会显示裁切过的图片，就像下面这样： 图片和div容器已经被全尺寸渲染，但是图片会被裁切成宽高为300px和150px的区域。我现在还不知道这是为什么。。 如果有人知道，可以在这里分享一下。 其它例子这里有一些我查阅资料时候碰到的其它例子。 SVG Filter Effects in IE10 Applying SVG effects to HTML content Gaussian Blur and CSS3/SVG Filters SVG-Wow 可以从每一个的标题看出来，它们可以汇总成三方面，SVG滤镜，CSS和SVG运用相同滤镜时使用上的细微差别，和不同浏览器对不同方式的支持程度。 滤镜基元清单有许多我没有在上面使用到的滤镜基元都和效果函数很相似，或者说相似到能够让我们很容易理解它们到底是做什么的。还有不少的更加复杂一些的滤镜基元，但是我已经没有机会再去研究他们了 混合和合并效果 feBlend feComposite feMerge 色彩效果 feColorMatrix feComponentTransfer feFlood (flood-color and flood-opacity) 光照和光源效果 feDiffuseLighting feSpecularLighting feDistantLight fePointLight feSpotLight 其它特殊效果 feConvolveMatrix feDisplacementMap feTurbulence feGaussianBlur feImage feMorphology feTile feOffset feDropShadow 自定义效果 feCustom 总结在这里我向可能引起的困惑道歉。由于官方文档缺少相关的例子，对我来说确实不是那么清晰，除此之外查阅到的资料都是讨论SVG滤镜的。这和我想要的确实有很密切的联系，但是不是同一件事情。 如果我们坚持这个滤镜效果规范，那么滤镜基元就是储存在单独文件中的SVG标记，使用filter: url()，他们可以应用在所有图片或者HTML文档中的其它元素。当SVG滤镜被储存在HTML中时，它只能应用在SVG元素上。 当我努力让它们工作，而且它们确实那样做的时候，很容易看到效果是有多么的强大。希望在不久的将来，我能够清除现在的所有困惑,然后对它们有更加深刻的理解。","categories":[{"name":"译文","slug":"译文","permalink":"http://jabbla.github.io/categories/译文/"}],"tags":[{"name":"CSS3","slug":"CSS3","permalink":"http://jabbla.github.io/tags/CSS3/"},{"name":"SVG","slug":"SVG","permalink":"http://jabbla.github.io/tags/SVG/"}]},{"title":"解决Sass媒体查询的重复问题，优化工作流程","slug":"解决Sass媒体查询的重复问题，优化工作流程","date":"2016-08-24T00:27:00.000Z","updated":"2016-08-24T00:32:06.021Z","comments":true,"path":"2016/08/24/解决Sass媒体查询的重复问题，优化工作流程/","link":"","permalink":"http://jabbla.github.io/2016/08/24/解决Sass媒体查询的重复问题，优化工作流程/","excerpt":"解决Sass媒体查询的重复问题，优化工作流程(第3弹)W3CPlus:http://www.w3cplus.com/preprocessor/the-solution-to-media-queries-in-sass.html","text":"解决Sass媒体查询的重复问题，优化工作流程(第3弹)W3CPlus:http://www.w3cplus.com/preprocessor/the-solution-to-media-queries-in-sass.html在Sass中有很多方法可以解决媒体查询这个问题，但是其中一些方法存在相同的问题。一开始我会还原这个问题，然后提供我的解决方案，最后列出这个方案对工作流程的好处。 问题假如我们把网站的Sass样式分离成多个像header.scss,hero.scss,cards.scss等等这样的组件。为他们添加各自的响应式样式最简洁的做法是，在各自的组件文件中添加相应的响应式样式。为了实现这样的效果，最简单的做法就是，定义一系列针对不同尺寸屏幕的mixin然后使用@content。12345678910@mixin tablet &#123; @media (min-width: 768px) and (max-width: 1024px) &#123; @content; &#125;&#125; @mixin desktop &#123; @media (min-width: 1024px) &#123; @content; &#125;&#125; 这些mixin会将外部传进来的样式片段，放置在@content出现的地方。就像这样使用：123456789p &#123; font-size: 16px; @include tablet &#123; font-size: 18px; &#125; @include desktop &#123; font-size: 20px; &#125;&#125; 这样很好，很整齐。它告诉我们，一个p元素里对两个不同的设备有不同的响应式设计。但是这样带来的问题是，在编译后CSS文件中，每个mixin中的媒体查询会重复地出现，就像这样:12345678910111213p &#123; font-style: 18px;&#125;@media (min-width: 768px) and (max-width: 1023px) &#123; p &#123; font-style: 20px; &#125;&#125; @media (min­width: 1024px) &#123; p &#123; font-style: 25px; &#125;&#125; 上面是https://davidwalsh.name/write-media-queries-sass的例子，只是为了举例说明这个问题。 这个例子仅仅涵盖了一个p标签，当存在很多需要响应式设计的元素的时候，这里将存在大量的重复。 对于小型网站，这样简单地将媒体查询mixin放在元素中可能并没有什么不妥，但是如果是大型网站，这样做会使CSS文件很快臃肿起来。如果Sass团队能解决这个问题，那再好不过了，但是我确定，这对编译速度来说是个很大的挑战。 简单的3步实现的解决方案在这个解决方案中，你可以将响应式样式放在每个组件中相应位置，并且没有重复的媒体查询，一切看起来都很完美，整齐，且易于维护。 步骤 1. 创建一个 media-queries.scss 文件为了避免重复的媒体查询，并且让代码看起来更整齐，我们在一个单独的Sass文件中定义媒体查询，然后调用这个文件。media-queries.scss (or .sass):1234567// small screen size (sm)@media (min-width: 801px) &#123;&#125;// medium screen size (md)@media (min-width: 992px) &#123;&#125; 为了看起来简单一点，在这里仅仅为小尺寸和中等尺寸屏幕定义了两个主要的断点。 步骤 2. 为每个元素创建一个响应式mixin就拿banner.scss来说，利用移动优先原则，在文件的底部定义一系列响应式mixin。这些mixin将会在media-queries.scss中相应的断点处调用。 确保为mixin添加一个能反映出相应断点的后缀，像前面的例子中的，small(sm)，medium(md)。比如说，如果一段样式处于小尺寸屏幕的断点，这个mixin名字就可以取为，元素的名称+sm后缀。 在mixin中为你准备适配的屏幕尺寸添加所有相应的样式。如：12345678910111213141516.banner &#123; text-align: center; font-size: 14px;&#125;// called in media-queries.scss@mixin banner--sm() &#123; .banner &#123; font-size: 20px; &#125;&#125;@mixin banner--md() &#123; .banner &#123; text-align: left; font-size: 25px; &#125;&#125; 步骤 3. 在media-queries.scss中调用这些mixin回到media-queries.scss文件，我们可以在指定的媒体查询中，调用相应的mixin。123456789// small screen size (sm)@media (min-width: 801px) &#123; @include banner--sm();&#125;// medium screen size (md)@media (min-width: 992px) &#123; @include banner--md()&#125; 好了，现在所有的响应式样式片段都定义在相应在的组件文件当中，然后被调用在媒体查询中相应断点处。整个编译后的css文件中没有重复的，冗余的媒体查询语句。 media-queries.scss输出的CSS文件123456789101112@media (min-width: 801px) &#123; .banner &#123; font-size: 20px; &#125;&#125;@media (min-width: 992px) &#123; .banner &#123; text-align: left; font-size: 25px; &#125;&#125; 最后，在每个断点处会调用很多个mixin，这样编译后的css文件就不会变得臃肿，同时你也很清楚所有的响应式样式片段在什么地方：1234567891011@media (min-width: 801px) &#123; @include home-cta--sm(); @include twitter-testimonials--sm(); @include site-footer--sm(); @include feature-section--sm(); @include feature-item--sm(); @include post-meta--sm(); @include social-share--sm(); @include hero--sm(); @include feature-page--sm();&#125; 优点在压缩文件体积方面，效果并不是很明显，但是对我来说，能减则减。另外一方面，重复的媒体查询并不会太大地影响性能。 优点主要还是体现在优化工作流程方面。 团队易读性 和 标准实践回到最初嵌套的媒体查询方法，我也喜欢这个方法，但是如果在一个非常庞大的组件文件中的不同层级使用这种嵌套，会使代码非常不整齐。当然，也可以结合BEM，使得嵌套的层数不超过2层。这种搭配BEM的解决方案其实还不错。 尽管如此，你和你的同事还是要上下滚动来查找哪些元素存在响应式设计。因为你必须弄清那些存在响应式设计的元素，这样，组件文件又不应该过长。使用我的解决方案，你和你的团队会很清楚在任意一个文件中元素媒体查询语句的位置。而且你可以在媒体查询区域寻找元素，如果没有，那么这个元素不会对任何的断点作出响应。 组件文件布局： 也可以在media-queries.scss文件中，查找那些存在响应式设计的元素。我们已经在一个组件数量超过30个的网站运用了这种方法，它的可伸缩性很好。 可以很好地利用移动优先原则最后，如果使用了移动优先原则，在组件文件中你将会从上到下依次看到小屏幕到大屏幕对应的样式。这样就会减少对不同屏幕尺寸所在位置的额外关注。 使用移动优先原则，从上到下将会看到屏幕尺寸的依次递增: 一些缺点这个方案也有一些缺点。比如，当我们删除了一个元素，就必须回到media.scss文件中删除相应的调用，不然就会抛出一个编译错误，不过也有一点好处是，你不用太过注意它，反正都会抛出错误提醒你。还有就是，可能会忘记在media-queries.scss添加mixin。 重构的时候也会比嵌套的媒体查询更麻烦。 在实际开发当中，特别是在回顾的时候，拥有一个结构良好的，有组织的媒体查询方法可以简化工作并且让我们更迅速地debug。 感谢您的阅读","categories":[{"name":"译文","slug":"译文","permalink":"http://jabbla.github.io/categories/译文/"}],"tags":[{"name":"Sass","slug":"Sass","permalink":"http://jabbla.github.io/tags/Sass/"}]},{"title":"Sass：@mixin和@extend该如何选择","slug":"Sass：-mixin和-extend该如何选择","date":"2016-08-21T13:30:00.000Z","updated":"2016-08-21T13:44:07.768Z","comments":true,"path":"2016/08/21/Sass：-mixin和-extend该如何选择/","link":"","permalink":"http://jabbla.github.io/2016/08/21/Sass：-mixin和-extend该如何选择/","excerpt":"Sass译文第二弹W3CPlus:http://www.w3cplus.com/preprocessor/sass-mixin-or-extend.html","text":"Sass译文第二弹W3CPlus:http://www.w3cplus.com/preprocessor/sass-mixin-or-extend.html Sass：@mixin？@extend？该如何选择Mixins允许我们在项目中复用样式片段，可以传递参数这个特性使得它们非常灵活，强大。同样，我们也可以使用@extend命令让一个选择器继承其它选择器去复用样式片段。有的时候Mixin和extend好像做了同样的事情，那我们应该选择哪一个呢？ 这个问题我会在本文的最后给出答案。在这之前，我先谈一谈关于@mixin指令的一些事情。 除了传递参数，我想让你知道如何给一个mixin传递CSS片段，了解这个片段的作用域。然后我会回到刚才的问题，将@extend和@mixin进行对比，帮助你了解他们的使用场景。 向Mixin传递样式片段除了传递参数，也可以直接传递一个样式片段给Mixin。在Mixin中，添加@content;语句，然后传递的样式片段就会代替@content;出现在相应的位置。 12345678910111213@mixin button &#123; font-size: 1em; padding: 0.5em 1.0em; text-decoration: none; color: #fff; @content; &#125;.button-green &#123; @include button &#123; background: green &#125;&#125; .button-green中调用了Mixin。@include指令传递了一个将背景色设置为绿色的CSS片段，然后这个片段就会代替@content语句出现在mixin中相应的位置 The Sass compiles to:这段Sass被编译成：1234567.button-green &#123; font-size: 1em; padding: 0.5em 1.0em; text-decoration: none; color: #fff; background: green; &#125; 如果是设置成这样，也可以只放一个@content语句在mixin中，然后使用@include传递包括选择器在内的所有东西。12345678910111213@mixin button &#123; @content; &#125;@include button &#123; .background-green &#123; font-size: 1em; padding: 0.5em 1.0em; text-decoration: none; color: #fff; background: green; &#125;&#125;; 这段Sass编译出来的结果跟刚才一样 当然也可以像最开始那样，把一些样式片段放在mixin中，然后使用@include传递另外的样式。但是要时刻警惕，这些样式都需要一个选择器，下面的例子就是一个反面教材，它是不会工作的。1234567891011@mixin button &#123; font-size: 1em; padding: 0.5em 1.0em; text-decoration: none; color: #fff; @content; &#125;@include button &#123; background: green; &#125;; 这段代码，编译过程中会抛出错误，因为没有一个选择器去应用这些样式。 你可能想知道，何时使用@content而不是仅仅传递一个参数值。下面是Christian Reuter提供的一些使用场景。 嵌套（内联）的媒体查询 keyframes 上下文差异化 结合@at-root书写BEM 变量作用域 和 内容片段当一个内容片段传进mixin的时候，它的作用域是在定义它的地方，而不是在mixin里面。也就是说，传进去的内容片段不能使用在mixin中定义的变量。 1234567891011$color: green;@mixin button($color: #fff) &#123; color: $color; @content; border: 1px solid $color; &#125;.button-green &#123; @include button &#123;background: $color;&#125; &#125; 在这个例子中，在最外层和mixin的参数中都有定义变量$color。这两个变量分别有不同的色值。 在mixin中，$color变量的值是#fff。在传递给.button-green的内容片段中，$color将会使用在最外层定义的green值 所以，上面的Sass会被编译成下面这段CSS 12345.button-green &#123; color: #fff; background: green; border: 1px solid #fff; &#125; 用@include传递进的内容片段将会使用最外层变量的green值，然后代替@content出现在mixin，mixin中的其它地方，字体颜色，边框颜色都使用mixin中定义的#fff值 应该使用 @mixin 还是 @extend@mixin和@extend都能帮助你模块化代码，然后更加方便地在样式表中复用一些样式片段。 你可能会问，到底什么时候使用@mixin，什么时候使用@extend? 不急，我们先看看一些代码编译出来是什么样的。1234567891011.button &#123; background: green; &#125;.button-1 &#123; @extend .button; &#125;.button-2 &#123; @extend .button; &#125; Using @extend produces DRY CSS. 使用@extend产生 DRY CSS风格的代码。 123.button, .button-1, .button-2 &#123; background: green; &#125; 注意，样式片段没有重复，这就是DRY。但是@mixin就不能产生DRY式的代码。 1234567891011@mixin button &#123; background-color: green; &#125;.button-1 &#123; @include button; &#125; .button-2 &#123; @include button; &#125; 这段使用@mixin的Sass编译出来的样子： 1234567891011.button &#123; background-color: green; &#125;.button-1 &#123; background-color: green; &#125;.button-2 &#123; background-color: green; &#125; 可以看到，相同的样式片段在不同的选择器中重复多次，这也导致了编译出来的CSS不是DRY形式的。 这可能会暗示你应该一直使用@extend，但是@extend也有一些缺点。@extend会增加选择器之间的联系，然后把他们堆在一起。 被继承的选择器和继承别人的选择器可能会在样式表的不同位置，这就导致维护困难，放置顺序，或者需要差异化的一些问题 @extend命令不够灵活。不能向它传递参数，它原本是啥样就是啥样。这里还有一些在@media中使用@extend的限制，比如，不能横跨多个@media指令使用@extend。 还有一个重要的问题就是@extend增加了选择器之间的联系。当你正在为一些相关的元素设置样式，就拿一组按钮来说，使用@extend让他们共享样式看起来合情合理。但是如果这些被复用的样式片段并不仅仅局限于相关的元素，那么使用@mixin或许更好。 @mixin主要的优势就是它能够接受参数。如果想传递参数，你会很自然地选择@mixin而不是@extend。 如果没有任何参数，使用@extend来创造DRY应该是个不错的选择。不过要注意的是，使用gzip压缩过的文件可能会破坏代码中的DRY。 当文件很小的时候，编译完成代码中有重复的片段并不是一件坏事。不过如果源文件中存在这样的重复片段，会使得代码很难维护。使用@mixin会减少编译后文件中DRY式的代码。但是，如果gzip的算法对重复片段的优化工作做得比较好，那么编译后的代码不会变得肿胀。 @mixin会更强大，更灵活，它与gzip的组合跟@extend的主要优势相比，一点都不会逊色。 结束语除了给一个@mixin传递参数之外，还能直接传递样式片段。你可能不会经常这么做，但是在一些使用场景中这么做更有意义 在大作数情况下@mixin会比@extend更好，但是它们俩都有自己的一席之地。当样式和选择器之间的关系在某些方面比较紧密的时候，使用@extend。除此之外，你可以使用@mixin在任何地方。 原文链接: http://vanseodesign.com/css/sass-mixin-or-extend/","categories":[{"name":"译文","slug":"译文","permalink":"http://jabbla.github.io/categories/译文/"}],"tags":[{"name":"Sass","slug":"Sass","permalink":"http://jabbla.github.io/tags/Sass/"}]},{"title":"为什么你要开始学习Sass","slug":"为什么你要开始学习Sass","date":"2016-08-19T07:10:00.000Z","updated":"2016-08-20T12:32:53.336Z","comments":true,"path":"2016/08/19/为什么你要开始学习Sass/","link":"","permalink":"http://jabbla.github.io/2016/08/19/为什么你要开始学习Sass/","excerpt":"自己的第一篇译文，希望能帮助到需要的童鞋w3cplus: http://www.w3cplus.com/preprocessor/why-should-you-start-learning-sass.html","text":"自己的第一篇译文，希望能帮助到需要的童鞋w3cplus: http://www.w3cplus.com/preprocessor/why-should-you-start-learning-sass.html 为什么你要开始学习Sass本文不会像一些其它文章一样，教你如何开始使用Sass，我会告诉你为什么使用Sass，我到底喜欢它什么。 我最初是在一个Laravel项目中，结识了Sass，Larvel是个PHP框架，内建有Elixir服务支持Sass。你可能觉得说这个玩意跟我们没啥关系，但是重点是Larvel支持Sass,使Sass非常容易上手，这就促使我去尝试使用Sass,慢慢了解到它的很多优点。 之前，我总觉得，写脚本在css里会把本应简单的事情变复杂，然后不确定是否应该花时间去学习它。但是我慢慢发现，它的用处巨大，还好当初没有放弃。 Sass 就是 CSS首先，你要知道的是，Sass其实就是CSS，这里可能会有很多的议论，但是如果你并不想使用Sass的诸多特性，你也可以只在Sass的样式表中书写CSS，这一点问题都没有，然后当你需要一些Sass特性的时候，你可以拿起来写。 Import(引入)回到当初的Larvel项目，一开始我用传统的方式书写CSS文件，最后发现文件内容非常的长。当时觉得，这没有什么问题，但是过了一段时间之后，发现在这个CSS文件里我很难回想起各个规则的位置。ok,Sass来了，它允许你创建多个文件，然后在一个文件中引入。也就是说你可以把长长的CSS文件，分割成几个以各自逻辑命名，组织的文件。这样，以后我们要完善更改样式表就变得更容易了。 对我来说，在一个项目中，经常会为网格，颜色，基础的布局创建文件，等等。当然，你也可以引入很多个需要的文件，只要你愿意。 Variables(变量)如果你习惯编程，你应该对变量不陌生。你可以定义一个变量，赋值，然后就能复用它。这是一个非常有用的特性，因为在书写CSS的颜色属性时候，你不需要再去重复写多个一样的hex，rgb值，你可以把它写在一个变量里。 这样做的好处就是，当你的客户想把红色设置稍微粉一点，你只需在变量定义的地方修改颜色的值。另外一个好处就是，相比hex值，变量名更好记，这就减少了前后不一致的错误。 Nesting(嵌套)你如果做响应式设计，我猜你会在CSS中的一些地方用到媒体查询。我曾经很发愁，媒体查询到底应该在CSS文件中的什么位置，最后我选择放在样式表的最底部，为不同的屏幕宽度，单独拿出一块区域。这么做的问题是，这些样式规则和原始的规则是分离的，维护起来会比较困难。 Sass的嵌套特性允许你可以通过在class中放置媒体查询来为这个class书写媒体查询。 这就表明，你可以在把一个class的所有规则，包括媒体查询放在一个地方，这样阅读和维护都会变得更加容易，你就不用反复地上下查看这个文件了。 像媒体查询一样，你也可以在使用&amp;添加如hover,active这样的状态规则。 Extend（继承）Sass有很多其它很酷的东西，但是我只在这里多说一个。当你存在两个class，它们有一些不同，但是也存在很多相似的地方，你可能会把所有样式重复声明两次,但是更好的做法是创建一个基础的class，然后在第二个class中使用extend继承。也就是说它继承了第一class的样式，同时可以添加额外的样式，或者对某些样式进行重写。 这点其实非常有用，比如说一些具有标准样式的按钮，同时存在不同颜色的差别，你可以声明一个具有标准样式的class，在按钮中继承这个class，然后设置不同的背景色。 在这篇文章当中，我觉得已经有足够多使用Sass的原因了。最后，非常希望可以帮助你发现Sass能带给你的便利。 原文链接：https://medium.com/@chrisrhymes/why-should-you-start-learning-sass-e3d83f2553c2#.4k65q0gwp","categories":[{"name":"译文","slug":"译文","permalink":"http://jabbla.github.io/categories/译文/"}],"tags":[{"name":"Sass","slug":"Sass","permalink":"http://jabbla.github.io/tags/Sass/"}]},{"title":"Sudoku数据处理流程","slug":"Sudoku数据处理流程","date":"2016-08-18T12:32:00.000Z","updated":"2016-08-20T12:43:17.732Z","comments":true,"path":"2016/08/18/Sudoku数据处理流程/","link":"","permalink":"http://jabbla.github.io/2016/08/18/Sudoku数据处理流程/","excerpt":"Sudoku这个项目陆陆续续地写了有2个星期了,断断续续地，今天终于做完最后一个模块，该放一放了，现在理一下项目的数据和数据处理流程，之后再填功能思路会更清晰一点","text":"Sudoku这个项目陆陆续续地写了有2个星期了,断断续续地，今天终于做完最后一个模块，该放一放了，现在理一下项目的数据和数据处理流程，之后再填功能思路会更清晰一点 后端数据数据库A. UserModel,用户模型 1234567891011121314151617181920212223242526272829userName: String, //用户名password: String, //密码email: String, //邮箱gameInfo: &#123; //用户的游戏记录 level4:&#123; min: Number, //最短时间 avg: Number, //平均时间 &#125;, level3:&#123; min: Number, avg: Number, &#125;, level2:&#123; min: Number, avg: Number, &#125;, level1:&#123; min: Number, avg: Number, &#125;,&#125;current: &#123; //用户所处当前关卡信息 mission: String, //所在关卡 time: Number, //已用时间 board: &#123; //棋盘数据 'row+col': 0 &#125;,&#125; B. LevelModel,等级模型123456level: Number //等级boards: [board,board] //数量不固定//BoardsubLevel: Number //子关卡board: String //棋盘数据字符串 排行榜数据rank.json123level:[&#123;userName:'username',level:'修罗'&#125;],cap:[&#123;userName:'username',cap:800&#125;],real:[&#123;userName:'username',real:800&#125;], 后端数据其实就是1231.UserCollection //用户集合2.LevelCollection //关卡集合3.rank.json //定时生成的排行榜 前端数据保存在cookies的数据C123456userName //用户名password //密码email //邮箱gameInfo //游戏信息current //当前关卡信息rankInfo //排行榜信息 经处理后的数据D123456789101112131415161718192021222324userName //用户名level //等级cap //能力值real //水平值num //小关卡层数levelNum //大关卡层数detail:&#123; //游戏信息 First:&#123; min:'...分...秒', avg:'...分...秒', &#125;, Sec:&#123;...&#125;, Thir:&#123;...&#125;, Forth:&#123;...&#125;,&#125;current //当前关卡名称boardInfo:&#123; mission //当前关卡名称 time //已用时间 board:&#123; //已填位置 'row+col':0 &#125; &#125; 开始游戏发送数据E123userName //用户名level //所在大关卡subLevel //所在小关卡 更新游戏信息发送数据F1234userName //用户名time //所用时间complete //是否完成board //当前用户已填位置 开始游戏接收数据G12board //原始棋盘信息boardInfo //用户已填位置 数据处理流程/signin1FE--(userName,password)--&gt;BE--C--&gt;FE--&gt;D /signup1FE--(userName,password,email)--&gt;BE--C--&gt;FE--&gt;D /admin1FE--(level,board)--&gt;BE /user/findInfo1FE--E--&gt;BE--G--&gt;FE /user/update1FE--F--&gt;BE--(404/200)--&gt;FE 欢迎访问Sudoku(数独游戏)，多提提意见啦,有什么好的想法也可以QQ我 持续更新","categories":[{"name":"开发","slug":"开发","permalink":"http://jabbla.github.io/categories/开发/"}],"tags":[{"name":"全栈","slug":"全栈","permalink":"http://jabbla.github.io/tags/全栈/"},{"name":"Sudoku","slug":"Sudoku","permalink":"http://jabbla.github.io/tags/Sudoku/"}]},{"title":" Canvas 知识体系简单总结","slug":"Canvas-知识体系简单总结","date":"2016-08-04T07:09:00.000Z","updated":"2016-08-20T12:39:31.897Z","comments":true,"path":"2016/08/04/Canvas-知识体系简单总结/","link":"","permalink":"http://jabbla.github.io/2016/08/04/Canvas-知识体系简单总结/","excerpt":"知识点零零散散，一个上午整理了一下，内容不多,方便记忆。本文不是教程，如需教程移步 MDN Canvas教程本文原创，如需转载，请注明出处","text":"知识点零零散散，一个上午整理了一下，内容不多,方便记忆。本文不是教程，如需教程移步 MDN Canvas教程本文原创，如需转载，请注明出处 Canvas 能干什么个人把它分为以下几点1234一个画板，能绘制复杂的图形，并应用各种样式。能在画板中放置图片，并可操作图片的尺寸和每个像素。鼠标事件能够访问到画板中的相应区域。能把画板中的图画，转换为DataURL的形式。 体系概览 把Canvas想象成一个画板123456一个绘制状态，可类比画图工具中的工具栏绘图元素，包括简单的图形，线条，复杂的组合，和图片绘制模式，比如画板中的图形存在绘制的先后顺序，而存在重叠部分，该如何显示存在重叠的图形，这是绘制模式要解决的问题裁切路径，只让画板的部分可见像素操作，操作ImageData的像素，画板的一部分区域访问，鼠标事件能够获取到所在的区域 绘制元素 需要说明的是image的类型1234HTMLImageElementHTMLVideoElementHTMLCanvasElementImageBitmap 绘制状态 需说明的是，一个canvas只有一组绘制状态 区域访问12addHitRegion(&#123;id:&apos;abc&apos;&#125;)鼠标事件能够获取到所在的区域 绘制模式12globalCompositeOperation比如画板中的图形存在绘制的先后顺序，而存在重叠部分，该如何显示存在重叠的图形，这是绘制模式要解决的问题 裁剪路径12clip()只让画板的部分可见 像素操作","categories":[{"name":"学习","slug":"学习","permalink":"http://jabbla.github.io/categories/学习/"}],"tags":[{"name":"canvas","slug":"canvas","permalink":"http://jabbla.github.io/tags/canvas/"},{"name":"html5","slug":"html5","permalink":"http://jabbla.github.io/tags/html5/"}]},{"title":"Promise思考及强化实现","slug":"思考及强化实现","date":"2016-08-01T14:40:53.000Z","updated":"2016-08-20T12:39:40.759Z","comments":true,"path":"2016/08/01/思考及强化实现/","link":"","permalink":"http://jabbla.github.io/2016/08/01/思考及强化实现/","excerpt":"做了Sudoku项目后，很头疼的问题就是代码维护，很大一部分原因是回调嵌套太多，影响代码的可读性,增加了维护难度,尤其是后端的数据库操作，用nodeJs通常会写许多回调嵌套。这次终于打算揭竿起义。","text":"做了Sudoku项目后，很头疼的问题就是代码维护，很大一部分原因是回调嵌套太多，影响代码的可读性,增加了维护难度,尤其是后端的数据库操作，用nodeJs通常会写许多回调嵌套。这次终于打算揭竿起义。 本文原创，如需转载请注明出处 我需要什么做了Sudoku项目后，很头疼的问题就是代码维护，很大一部分原因是回调嵌套太多，影响代码的可读性,增加了维护难度,尤其是后端的数据库操作，用nodeJs通常会写许多回调嵌套。这次终于打算揭竿起义。 第二次修改,废话不多说，直接进入正题先看下面这段代码12345678910111213function do()&#123; //查找数据库 setTimeout(()=&gt;&#123; console.log('收到数据'); //修改字段，并保存 setTimeout(()=&gt;&#123; console.log('保存成功') //发送响应给前端 &#125;,1000) setTimeout &#125;,1000)&#125;do() 模拟了非常简单的一个从前端接受请求到发送响应回到前端的过程，这个代码是非常简单的，不过看起来并不是，而且一旦需求更复杂，这样风格的代码肯定会让我非常头疼 我需要的代码风格 每个异步过程独立成块，不再是嵌套风格 异步返回结果的处理过程独立于异步过程 可伸缩，直接扩展异步结果处理过程,并不与之前的混在一起,实现细分，独立成块 每个异步过程存在依赖 好吧，发现promise满足我的所有需求，拿来现成用？这一点都不好玩，所以研究了一下promise的用法，下面是我简易的需求说明 需求说明（参考ES6的实现效果） 每个promise实例 resolve动作 reject动作 promise实例 then方法注册resolve回调，reject回调 A实例执行完回调，then()会返回一个B实例 B实例跟A一样，同样有 resolve动作 reject动作 调用B的then()方法同样会注册resolve回调，reject回调 影响B动作的因素有4个(下面详细讲解) 有catch同then一样，但是只能注册一个错误回调 a实例如过程上依赖于另外一个b实例,则可被当做其resolve参数传递，并且b实例成功好事滚粗依赖于 a 的状态 一旦实例状态发生改变,状态不会再改变 ##影响B实例的因素 1.A的resolve回调和reject回调是否有异常抛出是：B执行reject动作 否：B执行resolve动作 2.A的reject动作是否有回调是：回到1. 、 否：B执行reject动作 3.A的resolve动作是否有回调是：回到1 否： B执行resolve动作 4.A的回调中return 另一个promise实例CC resolve: B resolve C reject: B reject 具体实现Promise实例所有的属性12345678910111213141516171819class Promise&#123; //构造函数 fn为构建实例的异步过程 constructor(fn)&#123; //必须为函数类型 if(typeof fn !== 'function') throw new Error('not a function'); this.success = []; this.sucArg = null; this.fail = []; this.failArg = null; this.state = 0; this.parent = null; //fork promise分支 this.fork = []; //传递的error setTimeout(()=&gt;&#123; fn(myPromise.resolve.bind(this),myPromise.reject.bind(this)) &#125;,0); &#125;&#125; Promise实例的方法，then(),catch()123456789101112131415161718192021222324 //onFulfilled成功处理函数，onRejected滚粗处理函数 then(onFulfilled,onRejected)&#123; /*参数格式限制*/let fork = new myPromise(()=&gt;&#123;&#125;);if(typeof onFulfilled ==='function')&#123; this.success.push(onFulfilled); fork.forkSuc = onFulfilled;&#125;if(typeof onRejected ==='function')&#123; this.fail.push(onRejected); fork.forkRej = onRejected;&#125; this.fork.push(fork);return fork; &#125; catch(onRejected)&#123; //参数必须函数let fork = new myPromise(()=&gt;&#123;&#125;);if(typeof onRejected !=='function') return this;this.fail.push(onRejected);fork.forkRej = onRejected; this.fork.push(fork);return fork; &#125; Promise静态方法resolve,reject123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596 static resolve(value)&#123; if(this.state!==0) return;//参数不是myPromise实例if(value instanceof myPromise)&#123; //如参数是一个promise实例 value.parent = this; if(value.state===1)&#123; //实例状态为成功 myPromise.resolve.call(this,value.successArg); &#125;else if(value.state===-1)&#123; //实例状态为失败 myPromise.reject.call(this,value.failArg); &#125;&#125;else&#123; if(!this.success.length)&#123; for(let fn of this.fork)&#123; myPromise.resolve.call(fn,value); &#125; &#125;else&#123; this.sucArg = value; let cur = 0; for(let fn of this.success)&#123; if(this.fork.length&amp;&amp;fn===this.fork[cur].forkSuc)&#123; let error,preArg,bool; try&#123; preArg = fn(value); if(preArg instanceof myPromise)&#123; let index = cur; bool = true; preArg.success.push(()=&gt;&#123; myPromise.resolve.call(this.fork[index],preArg.sucArg); &#125;); preArg.fail.push(()=&gt;&#123; myPromise.reject.call(this.fork[index],preArg.failArg); &#125;) &#125; &#125;catch(err)&#123; error = err||null; &#125; if(!bool)&#123; error? myPromise.reject.call(this.fork[cur],error): myPromise.resolve.call(this.fork[cur],preArg); &#125; cur++; &#125;else&#123; fn(value); &#125; &#125; &#125; //当前promise变为fulfilled this.state = 1; //如存在parent,则parent.resolve(value) if(this.parent) myPromise.resolve.call(this.parent,value);&#125; &#125; static reject(value)&#123; if(this.state!==0) return;//参数是myPromise实例if(value instanceof myPromise)&#123; value.parent = this; myPromise.reject.call(this);&#125;else&#123; if(!this.fail.length)&#123; for(let fn of this.fork)&#123; myPromise.reject.call(fn,value) &#125; &#125;else&#123; this.failArg = value; let cur = 0; for(let fn of this.fail)&#123; if(this.fork.length&amp;&amp;fn===this.fork[cur].forkRej)&#123; let error,preArg,bool; try&#123; preArg = fn(value); if(preArg instanceof myPromise)&#123; let index = cur; bool = true; preArg.success.push(()=&gt;&#123; myPromise.resolve.call(this.fork[index],preArg.sucArg); &#125;); preArg.fail.push(()=&gt;&#123; myPromise.reject.call(this.fork[index],preArg.failArg); &#125;) &#125; &#125;catch(err)&#123; error = err||null; &#125; if(!bool)&#123; error? myPromise.reject.call(this.fork[cur],error): myPromise.resolve.call(this.fork[cur],preArg); &#125; cur++; &#125;else&#123; fn(value); &#125; &#125; &#125; this.state = -1; if(this.parent) myPromise.reject.call(this.parent,value);&#125; &#125; 好了，就这么多，这是个简易的Promise实现，如有错误，或者什么建议QQ:387857274欢迎讨论","categories":[{"name":"学习","slug":"学习","permalink":"http://jabbla.github.io/categories/学习/"}],"tags":[{"name":"promise","slug":"promise","permalink":"http://jabbla.github.io/tags/promise/"},{"name":"javascript","slug":"javascript","permalink":"http://jabbla.github.io/tags/javascript/"},{"name":"es6","slug":"es6","permalink":"http://jabbla.github.io/tags/es6/"}]},{"title":"Sublime效率开发实践","slug":"Sublime效率开发实践","date":"2016-05-14T08:21:00.000Z","updated":"2016-08-20T12:39:53.662Z","comments":true,"path":"2016/05/14/Sublime效率开发实践/","link":"","permalink":"http://jabbla.github.io/2016/05/14/Sublime效率开发实践/","excerpt":"如何让写代码更有快感呢，那就是多使用快捷键，练习传说中的微操会持续更新·····","text":"如何让写代码更有快感呢，那就是多使用快捷键，练习传说中的微操会持续更新····· 快捷键只列了自己不熟悉的功能，Preferences–&gt;key binding中有全面的 1234567891011121314151617181920ctr+shift+o 新建窗口ctr+o 提示打开文件ctr+n 新建文件ctr+s 保存文件ctr+shift+s 另存为ctr+F4 关闭文件ctr+w 关闭标签ctr+k+b (喜欢ctr按住)侧边栏隐藏/显示F11 全屏模式shift+F11 加强版全屏模式ctr+shift+z 恢复修改ctr+k+v (喜欢ctr按住)选择复制Home 去到一行的开头End 去到一行的结尾ctr+Home 去到文件的开头ctr+End 去到文件的结尾ctr+pageup 上一个标签ctr+pagedown下一个标签 快速生成代码片段在package Control中寻找相应的Snippets进行安装 Bootstrap3 Snippets Balbel Snippets 安装Emmet插件 写Html结构的利器(太酷了,强烈推荐) Emmet官网","categories":[{"name":"开发","slug":"开发","permalink":"http://jabbla.github.io/categories/开发/"}],"tags":[{"name":"效率工具","slug":"效率工具","permalink":"http://jabbla.github.io/tags/效率工具/"}]},{"title":"Hexo常用指令","slug":"Hexo常用指令","date":"2016-05-10T07:24:00.000Z","updated":"2016-08-20T12:40:01.987Z","comments":true,"path":"2016/05/10/Hexo常用指令/","link":"","permalink":"http://jabbla.github.io/2016/05/10/Hexo常用指令/","excerpt":"Hexo常用指令大部分都是从官网复制粘贴，会持续更新此后会写一篇，修改Hexo主题的教程，或者Hexo工作流程剖析","text":"Hexo常用指令大部分都是从官网复制粘贴，会持续更新此后会写一篇，修改Hexo主题的教程，或者Hexo工作流程剖析 Hexo的目录结构:12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes 1234567891011121314151617181920package.json&#123; \"name\": \"hexo-site\", \"version\": \"0.0.0\", \"private\": true, \"hexo\": &#123; \"version\": \"\" &#125;, \"dependencies\": &#123; \"hexo\": \"^3.0.0\", \"hexo-generator-archive\": \"^0.1.0\", \"hexo-generator-category\": \"^0.1.0\", \"hexo-generator-index\": \"^0.1.0\", \"hexo-generator-tag\": \"^0.1.0\", \"hexo-renderer-ejs\": \"^0.1.0\", \"hexo-renderer-stylus\": \"^0.2.0\", \"hexo-renderer-marked\": \"^0.2.4\", \"hexo-server\": \"^0.1.2\" &#125;&#125; scaffoldsScaffold folder. When you create a new post, Hexo bases the new file on the scaffold. sourceSource folder. This is where you put your site’s content. Hexo ignores hidden files and files or folders whose names are prefixed with _ (underscore) - except the _posts folder. Renderable files (e.g. Markdown, HTML) will be processed and put into the public folder, while other files will simply be copied. themesTheme folder. Hexo generates a static website by combining the site contents with the theme. Commandsnew1$ hexo new [layout] &lt;title&gt; Creates a new article. If no layout is provided, Hexo will use the default_layout from _config.yml. If the title contains spaces, surround it with quotation marks. generate1$ hexo generate Generates static files. Option Description12-d, --deploy Deploy after generation finishes-w, --watch Watch file changes publish1$ hexo publish [layout] &lt;filename&gt; Publishes a draft. server1$ hexo server Starts a local server. By default, this is at http://localhost:4000/. Option Description123-p, --port Override default port-s, --static Only serve static files-l, --log Enable logger. Override logger format. deploy1$ hexo deploy Deploys your website. Option Description1-g, --generate Generate before deployment render1$ hexo render &lt;file1&gt; [file2] ... Renders files. Option Description1-o, --output Output destination migrate1$ hexo migrate &lt;type&gt; Migrates content from other blog systems. clean1$ hexo clean Cleans the cache file (db.json) and generated files (public). list1$ hexo list &lt;type&gt; Lists all routes. version1$ hexo version Displays version information. Customize config file path1$ hexo --config custom.yml Uses a custom config file (instead of _config.yml). Display drafts1$ hexo --draft Displays draft posts (stored in the source/_drafts folder). Customize CWD1$ hexo --cwd /path/to/cwd Customizes the path of current working directory.","categories":[{"name":"学习","slug":"学习","permalink":"http://jabbla.github.io/categories/学习/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://jabbla.github.io/tags/hexo/"}]},{"title":"常见的几种数组排序算法JS实现","slug":"常见的几种数组排序算法JS实现","date":"2016-03-24T12:09:29.000Z","updated":"2016-08-20T12:40:10.774Z","comments":true,"path":"2016/03/24/常见的几种数组排序算法JS实现/","link":"","permalink":"http://jabbla.github.io/2016/03/24/常见的几种数组排序算法JS实现/","excerpt":"常见的几种数组排序算法JS实现一些简单的排序js实现(小菜一只，大神勿喷)","text":"常见的几种数组排序算法JS实现一些简单的排序js实现(小菜一只，大神勿喷) 快速排序 从给定的数据中，随机抽出一项，这项的左边放所有比它小的，右边放比它大的，然后再分别这两边执行上述操作，采用的是递归的思想，总结出来就是 实现一层，分别给两边递归，设置好出口 1234567891011121314151617181920212223242526272829303132333435function fastSort(array,head,tail)&#123; //考虑到给每个分区操作的时候都是在原有的数组中进行操作的，所以这里head,tail来确定分片的位置 /*生成随机项*/ var randomnum = Math.floor(ranDom(head,tail)); var random = array[randomnum]; /*将小于random的项放置在其左边 策略就是通过一个临时的数组来储存分好区的结果，再到原数组中替换*/ var arrayTemp = []; var unshiftHead = 0; for(var i = head;i &lt;= tail;i++)&#123; if(array[i]&lt;random)&#123; arrayTemp.unshift(array[i]); unshiftHead++; &#125;else if(array[i]&gt;random)&#123; arrayTemp.push(array[i]); &#125; /*当它等于的时候放哪，这里我想选择放到队列的前面，也就是从unshift后的第一个位置放置*/ if(array[i]===random)&#123; arrayTemp.splice(unshiftHead,0,array[i]); &#125; &#125; /*将对应项覆盖原来的记录*/ for(var j = head , u=0;j &lt;= tail;j++,u++)&#123; array.splice(j,1,arrayTemp[u]); &#125; /*寻找中间项所在的index*/ var nowIndex = array.indexOf(random); /*设置出口，当要放进去的片段只有2项的时候就可以收工了*/ if(arrayTemp.length &lt;= 2)&#123; return; &#125; /*递归，同时应用其左右两个区域*/ fastSort(array,head,nowIndex); fastSort(array,nowIndex+1,tail); &#125; 插入排序 思想就是在已经排好序的数组中插入到相应的位置，以从小到大排序为例，扫描已经排好序的片段的每一项，如大于，则继续往后，直到他小于一项时，将其插入到这项的前面 12345678910111213141516171819function insertSort(array)&#123; /*start根据已排列好的项数决定*/ var start=1; /*按顺序，每一项检查已排列好的序列*/ for(var i=start; i&lt;array.length; start++,i++)&#123; /*跟已排好序的序列做对比，并插入到合适的位置*/ for(var j=0; j&lt;start; j++)&#123; /*小于或者等于时（我们是升序）插入到该项前面*/ if(array[i]&lt;=array[j])&#123; console.log(array[i]+' '+array[j]); array.splice(j,0,array[i]); /*删除原有项*/ array.splice(i+1,1); break; &#125; &#125; &#125; &#125; 冒泡排序 故名思意 ，就是一个个冒泡到最前端或者最后端，主要是通过两两依次比较，以升序为例，如果前一项比后一项大则交换顺序，一直比到最后一对 12345678910111213function bubbleSort(array)&#123; /*给每个未确定的位置做循环*/ for(var unfix=array.length-1; unfix&gt;0; unfix--)&#123; /*给进度做个记录，比到未确定位置*/ for(var i=0; i&lt;unfix;i++)&#123; if(array[i]&gt;array[i+1])&#123; var temp = array[i]; array.splice(i,1,array[i+1]); array.splice(i+1,1,temp); &#125; &#125; &#125; &#125; 选择排序 将当前未确定块的min或者max取出来插到最前面或者后面 123456789101112131415161718function selectSort(array)&#123; /*给每个插入后的未确定的范围循环，初始是从0开始*/ for(var unfixed=0; unfixed&lt;array.length; unfixed++)&#123; /*设置当前范围的最小值和其索引*/ var min = array[unfixed]; var minIndex = unfixed; /*在该范围内选出最小值*/ for(var j=unfixed+1; j&lt;array.length; j++)&#123; if(min&gt;array[j])&#123; min = array[j]; minIndex = j; &#125; &#125; /*将最小值插入到unfixed，并且把它所在的原有项替换成*/ array.splice(unfixed,0,min); array.splice(minIndex+1,1); &#125; &#125; 总结一下，实现思想是很简单的,难点在于如何创造思想，还有就是个人的测试能力，和编程习惯，做注释其实不是仅仅为了别人看得更方便，而是自己思路的记录，有些人编着编着容易断片，注释起到了很好的引导作用","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://jabbla.github.io/tags/javascript/"},{"name":"算法","slug":"算法","permalink":"http://jabbla.github.io/tags/算法/"}]},{"title":"我所理解的JS执行环境和作用域链","slug":"我所理解的JS执行环境和作用域链","date":"2016-03-22T12:45:22.000Z","updated":"2016-08-20T12:40:20.914Z","comments":true,"path":"2016/03/22/我所理解的JS执行环境和作用域链/","link":"","permalink":"http://jabbla.github.io/2016/03/22/我所理解的JS执行环境和作用域链/","excerpt":"看了一些网上的关于JS机制的文章,结合自己在书上看的和自己的理解,把吸收到的捋捋直","text":"看了一些网上的关于JS机制的文章,结合自己在书上看的和自己的理解,把吸收到的捋捋直执行流 JS包含在HTML文件里的外部文件里或者内嵌script中,每个文件或者代码块都是单独扫描的1234&lt;script&gt; fn1() //fn1 function fn1()&#123;alert('fn1');&#125;&lt;/script&gt; 123456&lt;script&gt; fn1() //error&lt;/script&gt;&lt;script&gt; function fn1()&#123;alert('fn1');&#125;&lt;/script&gt; 浏览器扫描此代码块 然后将具名函数的声明做预处理,然后代码按顺序执行 注意是在同一代码块中哦,浏览器对每个代码块或者文件都是单独扫描的,也就是说预处理的作用范围是单个代码块 之后按照全局顺序开始执行代码,执行流下行 执行环境每个函数都有自己的执行环境,当执行流进入函数时,会为函数生成一个执行环境和执行环境关联的变量对象,变量对象中存着定义在执行环境中的所有变量和函数,JS的全局环境是window对象执行环境栈 为保证代码有序地执行,通过执行流流过的顺序,执行环境依次入栈出栈12345var a = 0;function hello()&#123; a = a+1;&#125;hello() 全局环境入栈-&gt;执行到第5行把hello()执行环境推到栈顶-&gt;hello()出栈,执行流重新回到上一层环境 作用域链12345var a = 0;function hello()&#123; a = a+1;&#125;hello() 当执行流到达第2行时,它不会进入hello()因为它还没有被调用,只是把hello()函数上的作用域链的钩子指向全局函数的变量对象 当执行流到达第5行时,创建hello()的执行环境,生成自己的变量对象,并将作用域链的钩子挂到此时的 全局变量对象上 其实也就这么点东西,还是得多做做题,加深对这些概念的理解,深入学习,下午看的主要结论就是,概念看了谁都懂,主要还是得做一些不那么常规的题巩固记忆,和加深对概念的认识,OK.","categories":[{"name":"学习","slug":"学习","permalink":"http://jabbla.github.io/categories/学习/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://jabbla.github.io/tags/javascript/"}]},{"title":"当我们说Line-Height时候,都会谈论到神马","slug":"当我们说line-height时候-都会谈论到神马","date":"2016-03-20T07:14:05.000Z","updated":"2016-08-20T12:40:34.197Z","comments":true,"path":"2016/03/20/当我们说line-height时候-都会谈论到神马/","link":"","permalink":"http://jabbla.github.io/2016/03/20/当我们说line-height时候-都会谈论到神马/","excerpt":"作为一个初入前端的小鲜肉,这几天被line-height折腾得够呛所以本着 你丫欺负我,我就刨你家祖坟的精神 今天就查查你家户口本","text":"作为一个初入前端的小鲜肉,这几天被line-height折腾得够呛所以本着 你丫欺负我,我就刨你家祖坟的精神 今天就查查你家户口本文中如果有什么不对的地方加我QQ387857274欢迎指正哦,前端爱好者也可以加一下,相互交流嘛个人认为,要想把这货彻底弄清楚就要,得先认识一下’基线’ 什么是基线红色这条线就是基线12是不是很像英语作业本中的线格,没错就是那玩意基线就是用来定位文字在一行中的显示位置,也就是说,一旦一行的基线的位置固定了,文字的位置也就固定了 line-height与基线的关系讲一讲绿线是什么鬼1绿线其实是我意淫出来的0.0 绿线的用处主要就是确定每行content_area,应该和好多文章中所提到的行内框相似12绿线的跨度是由该行内font-size最大的那个元素决定绿线的跨度的改变也会影响基线的位置&apos;好比姚明很高,所以他的屁股也会很高&apos; 绿线跟line-height有什么关系上方区域和下方区域的高度是一致的,我手残只能这样了12那么上方区域或者下方区域是如何计算的呢,就是&apos;((line-height)-绿线的跨度)/2&apos;也就是说这行的上方区域和上一行的下方区域共同组成&apos;行间距一号&apos;,同样下方区域和下一行的上方区域组成&apos;行间距二号&apos; 好吧这里好像跟基线并没有半毛钱关系,我承认,不过也可认为是姚明和他屁股的关系,line-height 会决定本行的位置,同时也就是会影响基线 基线会影响谁呢大家都知道,有inline,inline-block,block三种东西 一. inline我们把它看做一个由内容撑开的元素,被基线影响 二. inline-block中存在基线,其中的inline元素也被基线影响,不过inline-block会继承父元素的line-height1这里大家可能会产生疑问,看图,红色是父级元素p p设置line-height之前 p设置line-height:600px后;两个盒子的基线被拉到下面 这里有一些关于一行的基线到底归谁管的问题,请往下看 三. block跟inline-block是一样一样的区别在于block这货一下占一行 一行的基线到底归谁管1你可以笼统地说是`line-height`,这句话本身是没什么问题的,不过现实情况要比想象的要复杂一点,还有就是图片和空的`inline-block`也会影响基线的位置(**很诡异吧,我也觉得**) 情况11还是上面的图,当两个`inlin-block`不设置任何`line-height`的时候 p元素设置`line-height:600px;`可以看到第一行的基线沉下去了 情况21当只有黄色`inline-block`设置`line-height`的时候,同时绿色的本身&gt; 基线会向整体基线靠拢 情况31当两个货都设置不同的`line-height`呢绿色会调整自己的位置使自身基线向行基线靠拢 情况41当存在空的inline-bolck时,也会把基线下沉 情况51当行中加入图片后,本行的基线会随图片的高度而下沉,其它元素的基线也同时超主基线靠拢 这里得到的结论是:该行的line-height最终结果是子元素中最大的line-height,然后其它元素的line-height设置完成之后基线会朝整行基线靠拢心得就是还是慎用inline-block,个人认为float比inline-block好太多,能不用就不用以上都是个人观点 这是我研究一早上的结果,想交流的小伙伴可以加我qq387857274,共同进步关于更详细的知识内容见下面的参考资料参考链接CSS深入理解之line-height","categories":[{"name":"学习","slug":"学习","permalink":"http://jabbla.github.io/categories/学习/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://jabbla.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"http://jabbla.github.io/tags/CSS/"}]}]}