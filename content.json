{"meta":{"title":"Gloria","subtitle":"zxr's blog","description":"sadad","author":"Zxr","url":"http://jabbla.github.io"},"pages":[{"title":"关于我","date":"2016-08-13T07:21:24.000Z","updated":"2016-08-20T13:32:57.764Z","comments":true,"path":"about/index.html","permalink":"http://jabbla.github.io/about/index.html","excerpt":"","text":"爱篮球，爱滑雪，爱R&amp;B 爱前端，爱挑战，爱刺激 沉迷地狱，无法自拔，^_^"}],"posts":[{"title":"Sass：@mixin和@extend该如何选择","slug":"Sass：-mixin和-extend该如何选择","date":"2016-08-21T13:30:00.000Z","updated":"2016-08-21T13:44:07.768Z","comments":true,"path":"2016/08/21/Sass：-mixin和-extend该如何选择/","link":"","permalink":"http://jabbla.github.io/2016/08/21/Sass：-mixin和-extend该如何选择/","excerpt":"Sass译文第二弹W3CPlus:http://www.w3cplus.com/preprocessor/sass-mixin-or-extend.html","text":"Sass译文第二弹W3CPlus:http://www.w3cplus.com/preprocessor/sass-mixin-or-extend.html Sass：@mixin？@extend？该如何选择Mixins允许我们在项目中复用样式片段，可以传递参数这个特性使得它们非常灵活，强大。同样，我们也可以使用@extend命令让一个选择器继承其它选择器去复用样式片段。有的时候Mixin和extend好像做了同样的事情，那我们应该选择哪一个呢？ 这个问题我会在本文的最后给出答案。在这之前，我先谈一谈关于@mixin指令的一些事情。 除了传递参数，我想让你知道如何给一个mixin传递CSS片段，了解这个片段的作用域。然后我会回到刚才的问题，将@extend和@mixin进行对比，帮助你了解他们的使用场景。 向Mixin传递样式片段除了传递参数，也可以直接传递一个样式片段给Mixin。在Mixin中，添加@content;语句，然后传递的样式片段就会代替@content;出现在相应的位置。 12345678910111213@mixin button &#123; font-size: 1em; padding: 0.5em 1.0em; text-decoration: none; color: #fff; @content; &#125;.button-green &#123; @include button &#123; background: green &#125;&#125; .button-green中调用了Mixin。@include指令传递了一个将背景色设置为绿色的CSS片段，然后这个片段就会代替@content语句出现在mixin中相应的位置 The Sass compiles to:这段Sass被编译成：1234567.button-green &#123; font-size: 1em; padding: 0.5em 1.0em; text-decoration: none; color: #fff; background: green; &#125; 如果是设置成这样，也可以只放一个@content语句在mixin中，然后使用@include传递包括选择器在内的所有东西。12345678910111213@mixin button &#123; @content; &#125;@include button &#123; .background-green &#123; font-size: 1em; padding: 0.5em 1.0em; text-decoration: none; color: #fff; background: green; &#125;&#125;; 这段Sass编译出来的结果跟刚才一样 当然也可以像最开始那样，把一些样式片段放在mixin中，然后使用@include传递另外的样式。但是要时刻警惕，这些样式都需要一个选择器，下面的例子就是一个反面教材，它是不会工作的。1234567891011@mixin button &#123; font-size: 1em; padding: 0.5em 1.0em; text-decoration: none; color: #fff; @content; &#125;@include button &#123; background: green; &#125;; 这段代码，编译过程中会抛出错误，因为没有一个选择器去应用这些样式。 你可能想知道，何时使用@content而不是仅仅传递一个参数值。下面是Christian Reuter提供的一些使用场景。 嵌套（内联）的媒体查询 keyframes 上下文差异化 结合@at-root书写BEM 变量作用域 和 内容片段当一个内容片段传进mixin的时候，它的作用域是在定义它的地方，而不是在mixin里面。也就是说，传进去的内容片段不能使用在mixin中定义的变量。 1234567891011$color: green;@mixin button($color: #fff) &#123; color: $color; @content; border: 1px solid $color; &#125;.button-green &#123; @include button &#123;background: $color;&#125; &#125; 在这个例子中，在最外层和mixin的参数中都有定义变量$color。这两个变量分别有不同的色值。 在mixin中，$color变量的值是#fff。在传递给.button-green的内容片段中，$color将会使用在最外层定义的green值 所以，上面的Sass会被编译成下面这段CSS 12345.button-green &#123; color: #fff; background: green; border: 1px solid #fff; &#125; 用@include传递进的内容片段将会使用最外层变量的green值，然后代替@content出现在mixin，mixin中的其它地方，字体颜色，边框颜色都使用mixin中定义的#fff值 应该使用 @mixin 还是 @extend@mixin和@extend都能帮助你模块化代码，然后更加方便地在样式表中复用一些样式片段。 你可能会问，到底什么时候使用@mixin，什么时候使用@extend? 不急，我们先看看一些代码编译出来是什么样的。1234567891011.button &#123; background: green; &#125;.button-1 &#123; @extend .button; &#125;.button-2 &#123; @extend .button; &#125; Using @extend produces DRY CSS. 使用@extend产生 DRY CSS风格的代码。 123.button, .button-1, .button-2 &#123; background: green; &#125; 注意，样式片段没有重复，这就是DRY。但是@mixin就不能产生DRY式的代码。 1234567891011@mixin button &#123; background-color: green; &#125;.button-1 &#123; @include button; &#125; .button-2 &#123; @include button; &#125; 这段使用@mixin的Sass编译出来的样子： 1234567891011.button &#123; background-color: green; &#125;.button-1 &#123; background-color: green; &#125;.button-2 &#123; background-color: green; &#125; 可以看到，相同的样式片段在不同的选择器中重复多次，这也导致了编译出来的CSS不是DRY形式的。 这可能会暗示你应该一直使用@extend，但是@extend也有一些缺点。@extend会增加选择器之间的联系，然后把他们堆在一起。 被继承的选择器和继承别人的选择器可能会在样式表的不同位置，这就导致维护困难，放置顺序，或者需要差异化的一些问题 @extend命令不够灵活。不能向它传递参数，它原本是啥样就是啥样。这里还有一些在@media中使用@extend的限制，比如，不能横跨多个@media指令使用@extend。 还有一个重要的问题就是@extend增加了选择器之间的联系。当你正在为一些相关的元素设置样式，就拿一组按钮来说，使用@extend让他们共享样式看起来合情合理。但是如果这些被复用的样式片段并不仅仅局限于相关的元素，那么使用@mixin或许更好。 @mixin主要的优势就是它能够接受参数。如果想传递参数，你会很自然地选择@mixin而不是@extend。 如果没有任何参数，使用@extend来创造DRY应该是个不错的选择。不过要注意的是，使用gzip压缩过的文件可能会破坏代码中的DRY。 当文件很小的时候，编译完成代码中有重复的片段并不是一件坏事。不过如果源文件中存在这样的重复片段，会使得代码很难维护。使用@mixin会减少编译后文件中DRY式的代码。但是，如果gzip的算法对重复片段的优化工作做得比较好，那么编译后的代码不会变得肿胀。 @mixin会更强大，更灵活，它与gzip的组合跟@extend的主要优势相比，一点都不会逊色。 结束语除了给一个@mixin传递参数之外，还能直接传递样式片段。你可能不会经常这么做，但是在一些使用场景中这么做更有意义 在大作数情况下@mixin会比@extend更好，但是它们俩都有自己的一席之地。当样式和选择器之间的关系在某些方面比较紧密的时候，使用@extend。除此之外，你可以使用@mixin在任何地方。 原文链接: http://vanseodesign.com/css/sass-mixin-or-extend/","categories":[{"name":"译文","slug":"译文","permalink":"http://jabbla.github.io/categories/译文/"}],"tags":[{"name":"Sass","slug":"Sass","permalink":"http://jabbla.github.io/tags/Sass/"}]},{"title":"为什么你要开始学习Sass","slug":"为什么你要开始学习Sass","date":"2016-08-19T07:10:00.000Z","updated":"2016-08-20T12:32:53.336Z","comments":true,"path":"2016/08/19/为什么你要开始学习Sass/","link":"","permalink":"http://jabbla.github.io/2016/08/19/为什么你要开始学习Sass/","excerpt":"自己的第一篇译文，希望能帮助到需要的童鞋w3cplus: http://www.w3cplus.com/preprocessor/why-should-you-start-learning-sass.html","text":"自己的第一篇译文，希望能帮助到需要的童鞋w3cplus: http://www.w3cplus.com/preprocessor/why-should-you-start-learning-sass.html 为什么你要开始学习Sass本文不会像一些其它文章一样，教你如何开始使用Sass，我会告诉你为什么使用Sass，我到底喜欢它什么。 我最初是在一个Laravel项目中，结识了Sass，Larvel是个PHP框架，内建有Elixir服务支持Sass。你可能觉得说这个玩意跟我们没啥关系，但是重点是Larvel支持Sass,使Sass非常容易上手，这就促使我去尝试使用Sass,慢慢了解到它的很多优点。 之前，我总觉得，写脚本在css里会把本应简单的事情变复杂，然后不确定是否应该花时间去学习它。但是我慢慢发现，它的用处巨大，还好当初没有放弃。 Sass 就是 CSS首先，你要知道的是，Sass其实就是CSS，这里可能会有很多的议论，但是如果你并不想使用Sass的诸多特性，你也可以只在Sass的样式表中书写CSS，这一点问题都没有，然后当你需要一些Sass特性的时候，你可以拿起来写。 Import(引入)回到当初的Larvel项目，一开始我用传统的方式书写CSS文件，最后发现文件内容非常的长。当时觉得，这没有什么问题，但是过了一段时间之后，发现在这个CSS文件里我很难回想起各个规则的位置。ok,Sass来了，它允许你创建多个文件，然后在一个文件中引入。也就是说你可以把长长的CSS文件，分割成几个以各自逻辑命名，组织的文件。这样，以后我们要完善更改样式表就变得更容易了。 对我来说，在一个项目中，经常会为网格，颜色，基础的布局创建文件，等等。当然，你也可以引入很多个需要的文件，只要你愿意。 Variables(变量)如果你习惯编程，你应该对变量不陌生。你可以定义一个变量，赋值，然后就能复用它。这是一个非常有用的特性，因为在书写CSS的颜色属性时候，你不需要再去重复写多个一样的hex，rgb值，你可以把它写在一个变量里。 这样做的好处就是，当你的客户想把红色设置稍微粉一点，你只需在变量定义的地方修改颜色的值。另外一个好处就是，相比hex值，变量名更好记，这就减少了前后不一致的错误。 Nesting(嵌套)你如果做响应式设计，我猜你会在CSS中的一些地方用到媒体查询。我曾经很发愁，媒体查询到底应该在CSS文件中的什么位置，最后我选择放在样式表的最底部，为不同的屏幕宽度，单独拿出一块区域。这么做的问题是，这些样式规则和原始的规则是分离的，维护起来会比较困难。 Sass的嵌套特性允许你可以通过在class中放置媒体查询来为这个class书写媒体查询。 这就表明，你可以在把一个class的所有规则，包括媒体查询放在一个地方，这样阅读和维护都会变得更加容易，你就不用反复地上下查看这个文件了。 像媒体查询一样，你也可以在使用&amp;添加如hover,active这样的状态规则。 Extend（继承）Sass有很多其它很酷的东西，但是我只在这里多说一个。当你存在两个class，它们有一些不同，但是也存在很多相似的地方，你可能会把所有样式重复声明两次,但是更好的做法是创建一个基础的class，然后在第二个class中使用extend继承。也就是说它继承了第一class的样式，同时可以添加额外的样式，或者对某些样式进行重写。 这点其实非常有用，比如说一些具有标准样式的按钮，同时存在不同颜色的差别，你可以声明一个具有标准样式的class，在按钮中继承这个class，然后设置不同的背景色。 在这篇文章当中，我觉得已经有足够多使用Sass的原因了。最后，非常希望可以帮助你发现Sass能带给你的便利。 原文链接：https://medium.com/@chrisrhymes/why-should-you-start-learning-sass-e3d83f2553c2#.4k65q0gwp","categories":[{"name":"译文","slug":"译文","permalink":"http://jabbla.github.io/categories/译文/"}],"tags":[{"name":"Sass","slug":"Sass","permalink":"http://jabbla.github.io/tags/Sass/"}]},{"title":"Sudoku数据处理流程","slug":"Sudoku数据处理流程","date":"2016-08-18T12:32:00.000Z","updated":"2016-08-20T12:43:17.732Z","comments":true,"path":"2016/08/18/Sudoku数据处理流程/","link":"","permalink":"http://jabbla.github.io/2016/08/18/Sudoku数据处理流程/","excerpt":"Sudoku这个项目陆陆续续地写了有2个星期了,断断续续地，今天终于做完最后一个模块，该放一放了，现在理一下项目的数据和数据处理流程，之后再填功能思路会更清晰一点","text":"Sudoku这个项目陆陆续续地写了有2个星期了,断断续续地，今天终于做完最后一个模块，该放一放了，现在理一下项目的数据和数据处理流程，之后再填功能思路会更清晰一点 后端数据数据库A. UserModel,用户模型 1234567891011121314151617181920212223242526272829userName: String, //用户名password: String, //密码email: String, //邮箱gameInfo: &#123; //用户的游戏记录 level4:&#123; min: Number, //最短时间 avg: Number, //平均时间 &#125;, level3:&#123; min: Number, avg: Number, &#125;, level2:&#123; min: Number, avg: Number, &#125;, level1:&#123; min: Number, avg: Number, &#125;,&#125;current: &#123; //用户所处当前关卡信息 mission: String, //所在关卡 time: Number, //已用时间 board: &#123; //棋盘数据 'row+col': 0 &#125;,&#125; B. LevelModel,等级模型123456level: Number //等级boards: [board,board] //数量不固定//BoardsubLevel: Number //子关卡board: String //棋盘数据字符串 排行榜数据rank.json123level:[&#123;userName:'username',level:'修罗'&#125;],cap:[&#123;userName:'username',cap:800&#125;],real:[&#123;userName:'username',real:800&#125;], 后端数据其实就是1231.UserCollection //用户集合2.LevelCollection //关卡集合3.rank.json //定时生成的排行榜 前端数据保存在cookies的数据C123456userName //用户名password //密码email //邮箱gameInfo //游戏信息current //当前关卡信息rankInfo //排行榜信息 经处理后的数据D123456789101112131415161718192021222324userName //用户名level //等级cap //能力值real //水平值num //小关卡层数levelNum //大关卡层数detail:&#123; //游戏信息 First:&#123; min:'...分...秒', avg:'...分...秒', &#125;, Sec:&#123;...&#125;, Thir:&#123;...&#125;, Forth:&#123;...&#125;,&#125;current //当前关卡名称boardInfo:&#123; mission //当前关卡名称 time //已用时间 board:&#123; //已填位置 'row+col':0 &#125; &#125; 开始游戏发送数据E123userName //用户名level //所在大关卡subLevel //所在小关卡 更新游戏信息发送数据F1234userName //用户名time //所用时间complete //是否完成board //当前用户已填位置 开始游戏接收数据G12board //原始棋盘信息boardInfo //用户已填位置 数据处理流程/signin1FE--(userName,password)--&gt;BE--C--&gt;FE--&gt;D /signup1FE--(userName,password,email)--&gt;BE--C--&gt;FE--&gt;D /admin1FE--(level,board)--&gt;BE /user/findInfo1FE--E--&gt;BE--G--&gt;FE /user/update1FE--F--&gt;BE--(404/200)--&gt;FE 欢迎访问Sudoku(数独游戏)，多提提意见啦,有什么好的想法也可以QQ我 持续更新","categories":[{"name":"开发","slug":"开发","permalink":"http://jabbla.github.io/categories/开发/"}],"tags":[{"name":"全栈","slug":"全栈","permalink":"http://jabbla.github.io/tags/全栈/"},{"name":"Sudoku","slug":"Sudoku","permalink":"http://jabbla.github.io/tags/Sudoku/"}]},{"title":" Canvas 知识体系简单总结","slug":"Canvas-知识体系简单总结","date":"2016-08-04T07:09:00.000Z","updated":"2016-08-20T12:39:31.897Z","comments":true,"path":"2016/08/04/Canvas-知识体系简单总结/","link":"","permalink":"http://jabbla.github.io/2016/08/04/Canvas-知识体系简单总结/","excerpt":"知识点零零散散，一个上午整理了一下，内容不多,方便记忆。本文不是教程，如需教程移步 MDN Canvas教程本文原创，如需转载，请注明出处","text":"知识点零零散散，一个上午整理了一下，内容不多,方便记忆。本文不是教程，如需教程移步 MDN Canvas教程本文原创，如需转载，请注明出处 Canvas 能干什么个人把它分为以下几点1234一个画板，能绘制复杂的图形，并应用各种样式。能在画板中放置图片，并可操作图片的尺寸和每个像素。鼠标事件能够访问到画板中的相应区域。能把画板中的图画，转换为DataURL的形式。 体系概览 把Canvas想象成一个画板123456一个绘制状态，可类比画图工具中的工具栏绘图元素，包括简单的图形，线条，复杂的组合，和图片绘制模式，比如画板中的图形存在绘制的先后顺序，而存在重叠部分，该如何显示存在重叠的图形，这是绘制模式要解决的问题裁切路径，只让画板的部分可见像素操作，操作ImageData的像素，画板的一部分区域访问，鼠标事件能够获取到所在的区域 绘制元素 需要说明的是image的类型1234HTMLImageElementHTMLVideoElementHTMLCanvasElementImageBitmap 绘制状态 需说明的是，一个canvas只有一组绘制状态 区域访问12addHitRegion(&#123;id:&apos;abc&apos;&#125;)鼠标事件能够获取到所在的区域 绘制模式12globalCompositeOperation比如画板中的图形存在绘制的先后顺序，而存在重叠部分，该如何显示存在重叠的图形，这是绘制模式要解决的问题 裁剪路径12clip()只让画板的部分可见 像素操作","categories":[{"name":"学习","slug":"学习","permalink":"http://jabbla.github.io/categories/学习/"}],"tags":[{"name":"canvas","slug":"canvas","permalink":"http://jabbla.github.io/tags/canvas/"},{"name":"html5","slug":"html5","permalink":"http://jabbla.github.io/tags/html5/"}]},{"title":"Promise思考及强化实现","slug":"思考及强化实现","date":"2016-08-01T14:40:53.000Z","updated":"2016-08-20T12:39:40.759Z","comments":true,"path":"2016/08/01/思考及强化实现/","link":"","permalink":"http://jabbla.github.io/2016/08/01/思考及强化实现/","excerpt":"做了Sudoku项目后，很头疼的问题就是代码维护，很大一部分原因是回调嵌套太多，影响代码的可读性,增加了维护难度,尤其是后端的数据库操作，用nodeJs通常会写许多回调嵌套。这次终于打算揭竿起义。","text":"做了Sudoku项目后，很头疼的问题就是代码维护，很大一部分原因是回调嵌套太多，影响代码的可读性,增加了维护难度,尤其是后端的数据库操作，用nodeJs通常会写许多回调嵌套。这次终于打算揭竿起义。 本文原创，如需转载请注明出处 我需要什么做了Sudoku项目后，很头疼的问题就是代码维护，很大一部分原因是回调嵌套太多，影响代码的可读性,增加了维护难度,尤其是后端的数据库操作，用nodeJs通常会写许多回调嵌套。这次终于打算揭竿起义。 第二次修改,废话不多说，直接进入正题先看下面这段代码12345678910111213function do()&#123; //查找数据库 setTimeout(()=&gt;&#123; console.log('收到数据'); //修改字段，并保存 setTimeout(()=&gt;&#123; console.log('保存成功') //发送响应给前端 &#125;,1000) setTimeout &#125;,1000)&#125;do() 模拟了非常简单的一个从前端接受请求到发送响应回到前端的过程，这个代码是非常简单的，不过看起来并不是，而且一旦需求更复杂，这样风格的代码肯定会让我非常头疼 我需要的代码风格 每个异步过程独立成块，不再是嵌套风格 异步返回结果的处理过程独立于异步过程 可伸缩，直接扩展异步结果处理过程,并不与之前的混在一起,实现细分，独立成块 每个异步过程存在依赖 好吧，发现promise满足我的所有需求，拿来现成用？这一点都不好玩，所以研究了一下promise的用法，下面是我简易的需求说明 需求说明（参考ES6的实现效果） 每个promise实例 resolve动作 reject动作 promise实例 then方法注册resolve回调，reject回调 A实例执行完回调，then()会返回一个B实例 B实例跟A一样，同样有 resolve动作 reject动作 调用B的then()方法同样会注册resolve回调，reject回调 影响B动作的因素有4个(下面详细讲解) 有catch同then一样，但是只能注册一个错误回调 a实例如过程上依赖于另外一个b实例,则可被当做其resolve参数传递，并且b实例成功好事滚粗依赖于 a 的状态 一旦实例状态发生改变,状态不会再改变 ##影响B实例的因素 1.A的resolve回调和reject回调是否有异常抛出是：B执行reject动作 否：B执行resolve动作 2.A的reject动作是否有回调是：回到1. 、 否：B执行reject动作 3.A的resolve动作是否有回调是：回到1 否： B执行resolve动作 4.A的回调中return 另一个promise实例CC resolve: B resolve C reject: B reject 具体实现Promise实例所有的属性12345678910111213141516171819class Promise&#123; //构造函数 fn为构建实例的异步过程 constructor(fn)&#123; //必须为函数类型 if(typeof fn !== 'function') throw new Error('not a function'); this.success = []; this.sucArg = null; this.fail = []; this.failArg = null; this.state = 0; this.parent = null; //fork promise分支 this.fork = []; //传递的error setTimeout(()=&gt;&#123; fn(myPromise.resolve.bind(this),myPromise.reject.bind(this)) &#125;,0); &#125;&#125; Promise实例的方法，then(),catch()123456789101112131415161718192021222324 //onFulfilled成功处理函数，onRejected滚粗处理函数 then(onFulfilled,onRejected)&#123; /*参数格式限制*/let fork = new myPromise(()=&gt;&#123;&#125;);if(typeof onFulfilled ==='function')&#123; this.success.push(onFulfilled); fork.forkSuc = onFulfilled;&#125;if(typeof onRejected ==='function')&#123; this.fail.push(onRejected); fork.forkRej = onRejected;&#125; this.fork.push(fork);return fork; &#125; catch(onRejected)&#123; //参数必须函数let fork = new myPromise(()=&gt;&#123;&#125;);if(typeof onRejected !=='function') return this;this.fail.push(onRejected);fork.forkRej = onRejected; this.fork.push(fork);return fork; &#125; Promise静态方法resolve,reject123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596 static resolve(value)&#123; if(this.state!==0) return;//参数不是myPromise实例if(value instanceof myPromise)&#123; //如参数是一个promise实例 value.parent = this; if(value.state===1)&#123; //实例状态为成功 myPromise.resolve.call(this,value.successArg); &#125;else if(value.state===-1)&#123; //实例状态为失败 myPromise.reject.call(this,value.failArg); &#125;&#125;else&#123; if(!this.success.length)&#123; for(let fn of this.fork)&#123; myPromise.resolve.call(fn,value); &#125; &#125;else&#123; this.sucArg = value; let cur = 0; for(let fn of this.success)&#123; if(this.fork.length&amp;&amp;fn===this.fork[cur].forkSuc)&#123; let error,preArg,bool; try&#123; preArg = fn(value); if(preArg instanceof myPromise)&#123; let index = cur; bool = true; preArg.success.push(()=&gt;&#123; myPromise.resolve.call(this.fork[index],preArg.sucArg); &#125;); preArg.fail.push(()=&gt;&#123; myPromise.reject.call(this.fork[index],preArg.failArg); &#125;) &#125; &#125;catch(err)&#123; error = err||null; &#125; if(!bool)&#123; error? myPromise.reject.call(this.fork[cur],error): myPromise.resolve.call(this.fork[cur],preArg); &#125; cur++; &#125;else&#123; fn(value); &#125; &#125; &#125; //当前promise变为fulfilled this.state = 1; //如存在parent,则parent.resolve(value) if(this.parent) myPromise.resolve.call(this.parent,value);&#125; &#125; static reject(value)&#123; if(this.state!==0) return;//参数是myPromise实例if(value instanceof myPromise)&#123; value.parent = this; myPromise.reject.call(this);&#125;else&#123; if(!this.fail.length)&#123; for(let fn of this.fork)&#123; myPromise.reject.call(fn,value) &#125; &#125;else&#123; this.failArg = value; let cur = 0; for(let fn of this.fail)&#123; if(this.fork.length&amp;&amp;fn===this.fork[cur].forkRej)&#123; let error,preArg,bool; try&#123; preArg = fn(value); if(preArg instanceof myPromise)&#123; let index = cur; bool = true; preArg.success.push(()=&gt;&#123; myPromise.resolve.call(this.fork[index],preArg.sucArg); &#125;); preArg.fail.push(()=&gt;&#123; myPromise.reject.call(this.fork[index],preArg.failArg); &#125;) &#125; &#125;catch(err)&#123; error = err||null; &#125; if(!bool)&#123; error? myPromise.reject.call(this.fork[cur],error): myPromise.resolve.call(this.fork[cur],preArg); &#125; cur++; &#125;else&#123; fn(value); &#125; &#125; &#125; this.state = -1; if(this.parent) myPromise.reject.call(this.parent,value);&#125; &#125; 好了，就这么多，这是个简易的Promise实现，如有错误，或者什么建议QQ:387857274欢迎讨论","categories":[{"name":"学习","slug":"学习","permalink":"http://jabbla.github.io/categories/学习/"}],"tags":[{"name":"promise","slug":"promise","permalink":"http://jabbla.github.io/tags/promise/"},{"name":"javascript","slug":"javascript","permalink":"http://jabbla.github.io/tags/javascript/"},{"name":"es6","slug":"es6","permalink":"http://jabbla.github.io/tags/es6/"}]},{"title":"Sublime效率开发实践","slug":"Sublime效率开发实践","date":"2016-05-14T08:21:00.000Z","updated":"2016-08-20T12:39:53.662Z","comments":true,"path":"2016/05/14/Sublime效率开发实践/","link":"","permalink":"http://jabbla.github.io/2016/05/14/Sublime效率开发实践/","excerpt":"如何让写代码更有快感呢，那就是多使用快捷键，练习传说中的微操会持续更新·····","text":"如何让写代码更有快感呢，那就是多使用快捷键，练习传说中的微操会持续更新····· 快捷键只列了自己不熟悉的功能，Preferences–&gt;key binding中有全面的 1234567891011121314151617181920ctr+shift+o 新建窗口ctr+o 提示打开文件ctr+n 新建文件ctr+s 保存文件ctr+shift+s 另存为ctr+F4 关闭文件ctr+w 关闭标签ctr+k+b (喜欢ctr按住)侧边栏隐藏/显示F11 全屏模式shift+F11 加强版全屏模式ctr+shift+z 恢复修改ctr+k+v (喜欢ctr按住)选择复制Home 去到一行的开头End 去到一行的结尾ctr+Home 去到文件的开头ctr+End 去到文件的结尾ctr+pageup 上一个标签ctr+pagedown下一个标签 快速生成代码片段在package Control中寻找相应的Snippets进行安装 Bootstrap3 Snippets Balbel Snippets 安装Emmet插件 写Html结构的利器(太酷了,强烈推荐) Emmet官网","categories":[{"name":"开发","slug":"开发","permalink":"http://jabbla.github.io/categories/开发/"}],"tags":[{"name":"效率工具","slug":"效率工具","permalink":"http://jabbla.github.io/tags/效率工具/"}]},{"title":"Hexo常用指令","slug":"Hexo常用指令","date":"2016-05-10T07:24:00.000Z","updated":"2016-08-20T12:40:01.987Z","comments":true,"path":"2016/05/10/Hexo常用指令/","link":"","permalink":"http://jabbla.github.io/2016/05/10/Hexo常用指令/","excerpt":"Hexo常用指令大部分都是从官网复制粘贴，会持续更新此后会写一篇，修改Hexo主题的教程，或者Hexo工作流程剖析","text":"Hexo常用指令大部分都是从官网复制粘贴，会持续更新此后会写一篇，修改Hexo主题的教程，或者Hexo工作流程剖析 Hexo的目录结构:12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes 1234567891011121314151617181920package.json&#123; \"name\": \"hexo-site\", \"version\": \"0.0.0\", \"private\": true, \"hexo\": &#123; \"version\": \"\" &#125;, \"dependencies\": &#123; \"hexo\": \"^3.0.0\", \"hexo-generator-archive\": \"^0.1.0\", \"hexo-generator-category\": \"^0.1.0\", \"hexo-generator-index\": \"^0.1.0\", \"hexo-generator-tag\": \"^0.1.0\", \"hexo-renderer-ejs\": \"^0.1.0\", \"hexo-renderer-stylus\": \"^0.2.0\", \"hexo-renderer-marked\": \"^0.2.4\", \"hexo-server\": \"^0.1.2\" &#125;&#125; scaffoldsScaffold folder. When you create a new post, Hexo bases the new file on the scaffold. sourceSource folder. This is where you put your site’s content. Hexo ignores hidden files and files or folders whose names are prefixed with _ (underscore) - except the _posts folder. Renderable files (e.g. Markdown, HTML) will be processed and put into the public folder, while other files will simply be copied. themesTheme folder. Hexo generates a static website by combining the site contents with the theme. Commandsnew1$ hexo new [layout] &lt;title&gt; Creates a new article. If no layout is provided, Hexo will use the default_layout from _config.yml. If the title contains spaces, surround it with quotation marks. generate1$ hexo generate Generates static files. Option Description12-d, --deploy Deploy after generation finishes-w, --watch Watch file changes publish1$ hexo publish [layout] &lt;filename&gt; Publishes a draft. server1$ hexo server Starts a local server. By default, this is at http://localhost:4000/. Option Description123-p, --port Override default port-s, --static Only serve static files-l, --log Enable logger. Override logger format. deploy1$ hexo deploy Deploys your website. Option Description1-g, --generate Generate before deployment render1$ hexo render &lt;file1&gt; [file2] ... Renders files. Option Description1-o, --output Output destination migrate1$ hexo migrate &lt;type&gt; Migrates content from other blog systems. clean1$ hexo clean Cleans the cache file (db.json) and generated files (public). list1$ hexo list &lt;type&gt; Lists all routes. version1$ hexo version Displays version information. Customize config file path1$ hexo --config custom.yml Uses a custom config file (instead of _config.yml). Display drafts1$ hexo --draft Displays draft posts (stored in the source/_drafts folder). Customize CWD1$ hexo --cwd /path/to/cwd Customizes the path of current working directory.","categories":[{"name":"学习","slug":"学习","permalink":"http://jabbla.github.io/categories/学习/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://jabbla.github.io/tags/hexo/"}]},{"title":"常见的几种数组排序算法JS实现","slug":"常见的几种数组排序算法JS实现","date":"2016-03-24T12:09:29.000Z","updated":"2016-08-20T12:40:10.774Z","comments":true,"path":"2016/03/24/常见的几种数组排序算法JS实现/","link":"","permalink":"http://jabbla.github.io/2016/03/24/常见的几种数组排序算法JS实现/","excerpt":"常见的几种数组排序算法JS实现一些简单的排序js实现(小菜一只，大神勿喷)","text":"常见的几种数组排序算法JS实现一些简单的排序js实现(小菜一只，大神勿喷) 快速排序 从给定的数据中，随机抽出一项，这项的左边放所有比它小的，右边放比它大的，然后再分别这两边执行上述操作，采用的是递归的思想，总结出来就是 实现一层，分别给两边递归，设置好出口 1234567891011121314151617181920212223242526272829303132333435function fastSort(array,head,tail)&#123; //考虑到给每个分区操作的时候都是在原有的数组中进行操作的，所以这里head,tail来确定分片的位置 /*生成随机项*/ var randomnum = Math.floor(ranDom(head,tail)); var random = array[randomnum]; /*将小于random的项放置在其左边 策略就是通过一个临时的数组来储存分好区的结果，再到原数组中替换*/ var arrayTemp = []; var unshiftHead = 0; for(var i = head;i &lt;= tail;i++)&#123; if(array[i]&lt;random)&#123; arrayTemp.unshift(array[i]); unshiftHead++; &#125;else if(array[i]&gt;random)&#123; arrayTemp.push(array[i]); &#125; /*当它等于的时候放哪，这里我想选择放到队列的前面，也就是从unshift后的第一个位置放置*/ if(array[i]===random)&#123; arrayTemp.splice(unshiftHead,0,array[i]); &#125; &#125; /*将对应项覆盖原来的记录*/ for(var j = head , u=0;j &lt;= tail;j++,u++)&#123; array.splice(j,1,arrayTemp[u]); &#125; /*寻找中间项所在的index*/ var nowIndex = array.indexOf(random); /*设置出口，当要放进去的片段只有2项的时候就可以收工了*/ if(arrayTemp.length &lt;= 2)&#123; return; &#125; /*递归，同时应用其左右两个区域*/ fastSort(array,head,nowIndex); fastSort(array,nowIndex+1,tail); &#125; 插入排序 思想就是在已经排好序的数组中插入到相应的位置，以从小到大排序为例，扫描已经排好序的片段的每一项，如大于，则继续往后，直到他小于一项时，将其插入到这项的前面 12345678910111213141516171819function insertSort(array)&#123; /*start根据已排列好的项数决定*/ var start=1; /*按顺序，每一项检查已排列好的序列*/ for(var i=start; i&lt;array.length; start++,i++)&#123; /*跟已排好序的序列做对比，并插入到合适的位置*/ for(var j=0; j&lt;start; j++)&#123; /*小于或者等于时（我们是升序）插入到该项前面*/ if(array[i]&lt;=array[j])&#123; console.log(array[i]+' '+array[j]); array.splice(j,0,array[i]); /*删除原有项*/ array.splice(i+1,1); break; &#125; &#125; &#125; &#125; 冒泡排序 故名思意 ，就是一个个冒泡到最前端或者最后端，主要是通过两两依次比较，以升序为例，如果前一项比后一项大则交换顺序，一直比到最后一对 12345678910111213function bubbleSort(array)&#123; /*给每个未确定的位置做循环*/ for(var unfix=array.length-1; unfix&gt;0; unfix--)&#123; /*给进度做个记录，比到未确定位置*/ for(var i=0; i&lt;unfix;i++)&#123; if(array[i]&gt;array[i+1])&#123; var temp = array[i]; array.splice(i,1,array[i+1]); array.splice(i+1,1,temp); &#125; &#125; &#125; &#125; 选择排序 将当前未确定块的min或者max取出来插到最前面或者后面 123456789101112131415161718function selectSort(array)&#123; /*给每个插入后的未确定的范围循环，初始是从0开始*/ for(var unfixed=0; unfixed&lt;array.length; unfixed++)&#123; /*设置当前范围的最小值和其索引*/ var min = array[unfixed]; var minIndex = unfixed; /*在该范围内选出最小值*/ for(var j=unfixed+1; j&lt;array.length; j++)&#123; if(min&gt;array[j])&#123; min = array[j]; minIndex = j; &#125; &#125; /*将最小值插入到unfixed，并且把它所在的原有项替换成*/ array.splice(unfixed,0,min); array.splice(minIndex+1,1); &#125; &#125; 总结一下，实现思想是很简单的,难点在于如何创造思想，还有就是个人的测试能力，和编程习惯，做注释其实不是仅仅为了别人看得更方便，而是自己思路的记录，有些人编着编着容易断片，注释起到了很好的引导作用","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://jabbla.github.io/tags/javascript/"},{"name":"算法","slug":"算法","permalink":"http://jabbla.github.io/tags/算法/"}]},{"title":"我所理解的JS执行环境和作用域链","slug":"我所理解的JS执行环境和作用域链","date":"2016-03-22T12:45:22.000Z","updated":"2016-08-20T12:40:20.914Z","comments":true,"path":"2016/03/22/我所理解的JS执行环境和作用域链/","link":"","permalink":"http://jabbla.github.io/2016/03/22/我所理解的JS执行环境和作用域链/","excerpt":"看了一些网上的关于JS机制的文章,结合自己在书上看的和自己的理解,把吸收到的捋捋直","text":"看了一些网上的关于JS机制的文章,结合自己在书上看的和自己的理解,把吸收到的捋捋直执行流 JS包含在HTML文件里的外部文件里或者内嵌script中,每个文件或者代码块都是单独扫描的1234&lt;script&gt; fn1() //fn1 function fn1()&#123;alert('fn1');&#125;&lt;/script&gt; 123456&lt;script&gt; fn1() //error&lt;/script&gt;&lt;script&gt; function fn1()&#123;alert('fn1');&#125;&lt;/script&gt; 浏览器扫描此代码块 然后将具名函数的声明做预处理,然后代码按顺序执行 注意是在同一代码块中哦,浏览器对每个代码块或者文件都是单独扫描的,也就是说预处理的作用范围是单个代码块 之后按照全局顺序开始执行代码,执行流下行 执行环境每个函数都有自己的执行环境,当执行流进入函数时,会为函数生成一个执行环境和执行环境关联的变量对象,变量对象中存着定义在执行环境中的所有变量和函数,JS的全局环境是window对象执行环境栈 为保证代码有序地执行,通过执行流流过的顺序,执行环境依次入栈出栈12345var a = 0;function hello()&#123; a = a+1;&#125;hello() 全局环境入栈-&gt;执行到第5行把hello()执行环境推到栈顶-&gt;hello()出栈,执行流重新回到上一层环境 作用域链12345var a = 0;function hello()&#123; a = a+1;&#125;hello() 当执行流到达第2行时,它不会进入hello()因为它还没有被调用,只是把hello()函数上的作用域链的钩子指向全局函数的变量对象 当执行流到达第5行时,创建hello()的执行环境,生成自己的变量对象,并将作用域链的钩子挂到此时的 全局变量对象上 其实也就这么点东西,还是得多做做题,加深对这些概念的理解,深入学习,下午看的主要结论就是,概念看了谁都懂,主要还是得做一些不那么常规的题巩固记忆,和加深对概念的认识,OK.","categories":[{"name":"学习","slug":"学习","permalink":"http://jabbla.github.io/categories/学习/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://jabbla.github.io/tags/javascript/"}]},{"title":"当我们说Line-Height时候,都会谈论到神马","slug":"当我们说line-height时候-都会谈论到神马","date":"2016-03-20T07:14:05.000Z","updated":"2016-08-20T12:40:34.197Z","comments":true,"path":"2016/03/20/当我们说line-height时候-都会谈论到神马/","link":"","permalink":"http://jabbla.github.io/2016/03/20/当我们说line-height时候-都会谈论到神马/","excerpt":"作为一个初入前端的小鲜肉,这几天被line-height折腾得够呛所以本着 你丫欺负我,我就刨你家祖坟的精神 今天就查查你家户口本","text":"作为一个初入前端的小鲜肉,这几天被line-height折腾得够呛所以本着 你丫欺负我,我就刨你家祖坟的精神 今天就查查你家户口本文中如果有什么不对的地方加我QQ387857274欢迎指正哦,前端爱好者也可以加一下,相互交流嘛个人认为,要想把这货彻底弄清楚就要,得先认识一下’基线’ 什么是基线红色这条线就是基线12是不是很像英语作业本中的线格,没错就是那玩意基线就是用来定位文字在一行中的显示位置,也就是说,一旦一行的基线的位置固定了,文字的位置也就固定了 line-height与基线的关系讲一讲绿线是什么鬼1绿线其实是我意淫出来的0.0 绿线的用处主要就是确定每行content_area,应该和好多文章中所提到的行内框相似12绿线的跨度是由该行内font-size最大的那个元素决定绿线的跨度的改变也会影响基线的位置&apos;好比姚明很高,所以他的屁股也会很高&apos; 绿线跟line-height有什么关系上方区域和下方区域的高度是一致的,我手残只能这样了12那么上方区域或者下方区域是如何计算的呢,就是&apos;((line-height)-绿线的跨度)/2&apos;也就是说这行的上方区域和上一行的下方区域共同组成&apos;行间距一号&apos;,同样下方区域和下一行的上方区域组成&apos;行间距二号&apos; 好吧这里好像跟基线并没有半毛钱关系,我承认,不过也可认为是姚明和他屁股的关系,line-height 会决定本行的位置,同时也就是会影响基线 基线会影响谁呢大家都知道,有inline,inline-block,block三种东西 一. inline我们把它看做一个由内容撑开的元素,被基线影响 二. inline-block中存在基线,其中的inline元素也被基线影响,不过inline-block会继承父元素的line-height1这里大家可能会产生疑问,看图,红色是父级元素p p设置line-height之前 p设置line-height:600px后;两个盒子的基线被拉到下面 这里有一些关于一行的基线到底归谁管的问题,请往下看 三. block跟inline-block是一样一样的区别在于block这货一下占一行 一行的基线到底归谁管1你可以笼统地说是`line-height`,这句话本身是没什么问题的,不过现实情况要比想象的要复杂一点,还有就是图片和空的`inline-block`也会影响基线的位置(**很诡异吧,我也觉得**) 情况11还是上面的图,当两个`inlin-block`不设置任何`line-height`的时候 p元素设置`line-height:600px;`可以看到第一行的基线沉下去了 情况21当只有黄色`inline-block`设置`line-height`的时候,同时绿色的本身&gt; 基线会向整体基线靠拢 情况31当两个货都设置不同的`line-height`呢绿色会调整自己的位置使自身基线向行基线靠拢 情况41当存在空的inline-bolck时,也会把基线下沉 情况51当行中加入图片后,本行的基线会随图片的高度而下沉,其它元素的基线也同时超主基线靠拢 这里得到的结论是:该行的line-height最终结果是子元素中最大的line-height,然后其它元素的line-height设置完成之后基线会朝整行基线靠拢心得就是还是慎用inline-block,个人认为float比inline-block好太多,能不用就不用以上都是个人观点 这是我研究一早上的结果,想交流的小伙伴可以加我qq387857274,共同进步关于更详细的知识内容见下面的参考资料参考链接CSS深入理解之line-height","categories":[{"name":"学习","slug":"学习","permalink":"http://jabbla.github.io/categories/学习/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://jabbla.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"http://jabbla.github.io/tags/CSS/"}]}]}