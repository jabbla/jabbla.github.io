{"meta":{"title":"Gloria","subtitle":"zxr's blog","description":"FE Engineer","author":"Gloria","url":"http://jabbla.github.io"},"pages":[{"title":"Categories","date":"2017-10-22T06:27:19.000Z","updated":"2017-10-22T07:16:19.659Z","comments":true,"path":"categories/index.html","permalink":"http://jabbla.github.io/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2017-10-22T06:25:53.000Z","updated":"2017-10-22T07:15:53.077Z","comments":true,"path":"tags/index.html","permalink":"http://jabbla.github.io/tags/index.html","excerpt":"","text":""},{"title":"关于我","date":"2016-08-13T07:21:24.000Z","updated":"2018-04-19T13:35:30.300Z","comments":true,"path":"about/index.html","permalink":"http://jabbla.github.io/about/index.html","excerpt":"","text":"FE Engineer"}],"posts":[{"title":"Webpack基本架构浅析","slug":"Webpack基本架构浅析","date":"2018-04-19T13:35:00.000Z","updated":"2018-04-19T14:09:37.900Z","comments":true,"path":"2018/04/19/Webpack基本架构浅析/","link":"","permalink":"http://jabbla.github.io/2018/04/19/Webpack基本架构浅析/","excerpt":"文章webpack版本为3.6.0 随着掌握的前端基础知识越来越多，对技术的要求逐渐不满足于实现即可，技术到了瓶颈期，自己也曾尝试写过一些开源库，不过很少有满意的作品，通常没迭代几个版本就没有耐心继续维护了。通常是面临的情形是前期设计思路太过简单导致后期扩展的时候需要重构大量的代码（GG吧~），就好比一坨屎，再怎么装点，都很难把它当成蛋糕吃下去。","text":"文章webpack版本为3.6.0 随着掌握的前端基础知识越来越多，对技术的要求逐渐不满足于实现即可，技术到了瓶颈期，自己也曾尝试写过一些开源库，不过很少有满意的作品，通常没迭代几个版本就没有耐心继续维护了。通常是面临的情形是前期设计思路太过简单导致后期扩展的时候需要重构大量的代码（GG吧~），就好比一坨屎，再怎么装点，都很难把它当成蛋糕吃下去。 我认为，突破这个瓶颈的关键就是学会深入理解优秀开源库背后的思路。有人可能会说，我用xxx已经很久了，能够熟练使用它解决各种棘手问题，对于它，我已经充分理解了。我想说的是，即便你对于它的使用已经达到了炉火纯青的程度，但是站在使用者角度理解再“深”能有多深呢，不过是坐井观天罢了。 为什么Webpack目前为止，Webpack已经拥有39.9k的star，在前端代码打包器领域内应该算是无敌的存在了吧。Webpack强大的生态圈和丰富的解决方案使得我们在日常开发中很难逃脱它的魔爪。如果能学习到它背后的思路，对于技能树的完善和水平层次的提高应该是非常有好处的。 概要如果要全面总结webpack的实现，估计写10篇文章都不一定够。为了更加清晰地get到webpack的设计思路，会隐去webpack的大部分功能实现。 以实现简单的js模块打包功能为背景，文章分为3部分： BundleBuilder基本架构 Webpack基本架构 学到了些什么 相信你在阅读完本文后会对Webpack的架构有个大概的了解，这应该会对你继续深入理解webpack其它功能的实现以及编写插件会有所帮助。 BundleBuilder基本架构 简单到不能再简单的js模块打包器 示意图 BundleBuilder对象 BundleBuilder对象接收并处理外部配置 根据配置选择不同的ModuleResolver 使用ModuleResolver接收配置得到最终文件内容 生成打包后的文件 ModuleResolver对象 接收从BundleBuilder传进的配置 解析入口文件内容 提取子模块路径，并递归地解析子模块 将引用的模块路径替换为模块id最终生成模块文件 webpack基本架构这个接下来依次讲解webpack中几个重要对象之间的关系，会以各自的视角描述几个重要的过程。当然，就单单这几个对象还不能完全地描述流程上的所有内容。 Tapable插件功能 webpack 4.0的插件系统已经完全重做并将Tapable更新到了1.0.0 在正式介绍几个核心对象之前，你需要了解一下Tapable类。 简单来说，Tapable为一个对象提供了插件功能。如果你用过Vue.js或者React.js之类的框架，Tapable就是为某个对象提供了相当于组件的生命周期功能，在外部你可以通过调用这些生命周期钩子监听该对象。 当然，你还可以在外部手动触发对象的某个生命周期。 如果你想详细了解Tapable的API可以参考这里（文中版本为0.2.8） Webpack主函数视角 最宏观的视角 1. 合并外部与默认配置 2. 配置并创建compiler 3. 在compiler启动前触发compiler上的若干生命周期 其中生命周期包括：environment，after-environment，entry-option，after-plugins，after-resolvers 4. 启动compiler 5. 将compiler运行后得到的状态信息打印出来 Compiler视角1. 正式运行前依次触发before-run和run生命周期 2. 创建params对象并触发before-compile生命周期 3. 触发compile生命周期并创建compilation对象 4. 触发this-compilation和compilation生命周期 5. 触发make生命周期并调用compilation.finish() 在make阶段调用了compilation.addEntry()，开始构建模块树，构建完毕后调用compilation.finish()，记录报错信息 6. 调用compilation.seal()并触发after-compile生命周期 compilation在seal过程中做了很多工作，在compilation视角部分会讲到，现在只需知道seal过后compilation生成了assets对象以供compiler生成文件 7. 拿到assets并在生成每个assets对应的文件 8. 将警告信息和文件大小信息合成为stats状态信息 9. 触发done生命周期并将stats状态信息交给webpack主函数 Compilation构建模块树视角 当compiler命令compilation构建模块树之后compilation都做了些什么 1. 使用moduleFactory创建空module 2. 命令module自行构建自身属性，比如依赖的子模块信息（dependency） 调用module.build()进行构建模块自身属性 3. 递归地重复1和2的操作，生成模块树 4. 将模块树记录到chunk中 Compilation的seal视角1. 配置chunk 2. 将所处模块树深度和引用顺序等信息记录在每个模块上 3. 将所有模块按照引用顺序排序 4. 触发optimize-module-order生命周期并按照排序后的模块顺序为每个模块编号 5. 使用template对象渲染出chunk的内容source 6. 拿到source后生成asset，添加到assets中 学到了什么引入插件系统1. 存在的问题 可以看到，BundleBuilder的架构中完全没有为第三方提供接口，后期当然也可以做成根据不同的外部配置项来实现一些有限的定制化需求。 但是，这样为了保证功能的多样性，会频繁修改打包器的内部实现。这种做法会使得整个打包器的稳定性不足，最终非常臃肿，维护困难。 2. webpack的做法 反观webpack，它使用了一种非常聪明的方式。在保证基本架构的前提下，为主流程上的大部分对象都引入插件系统，使用者可以获取到这些对象，并且在一些特定的时候运行使用者提供的代码。这样一来，社区的逐渐壮大保证了功能的多样性，还把稳定性不足的风险留给用户去处理，提高了整个打包器的可维护性。 过程粒度细化1. 存在的问题 可以看到，BundleBuilder最终生成文件内容只有一个过程，就是调用ModuleResolver获取字符串。当这个过程中的某一阶段需要独立进行的时候，难免会要重构代码。如果内部实现是比较松耦合的，那么重构的工作会比较轻松，但是像现在BundleBuilder这种实现，显然要做的工作并不少。 2. webpack的做法 从接收配置到生成文件内容，从比较宏观的角度，分为构建，封装，生成文件内容，三部分。 保证了内部修改的灵活性。如果要对过程再细分或者添加过程，实现起来会比较方便。 丰富了对外扩展的接口。很显然，由于webpack引入了插件系统，细化过程粒度应该是必然选择，这样会有效地增加用户对整个打包过程的自定义能力。 提升了代码的可维护性。当打包器在运行时出现了bug，粒度越小，越加方便定位问题。 更多类的抽象1. 存在的问题 在BundleBuilder中，对于每个模块仅仅是通过路径读取它的文件内容，然后分析其子模块的信息，最后生成处理后的模块内容。这些都是过程。如果后面迭代时需要在打包后输出一些log，如模块警告，模块路径等与模块相关的信息。以面向过程的编程方式当然也可以实现，但这样难免会增加实现难度，降低代码可读性。 2. webpack的做法 稍微搜索一下，不包括自带插件，webpack总共有200多个用Class声明的类。 结构化的数据。创建一个类就意味着我们能统一很多有相同抽象含义的对象创建同样的属性，比如Module类，它可以记录很多与模块相关的信息。 方便扩展不同种类的对象。比如模块类，可以通过继承的方式衍生出，普通js文件模块，css文件模块等等。 多类意味着有承担不同职责的对象。明确的职责分工，比如compiler仅仅负责compilation的创建，文件的生成和信息状态的合成。ModuleFactory负责创建Module。一旦出了问题方便定位到责任人，降低了各个工作的耦合度。 对象间的解耦。比如compilation和Module两个类，webpack其实也可以直接使用compilation来直接创建Module，但是一旦Module的种类增加，不可避免地需要在compilation中写一些条件语句，这样，创建Module这部分的代码会让本来就有很多事情要做的compilation变得更加庞大。所以webpack引入了ModuleFactory，compilation只需调用ModuleFactory来创建Module就好，创建部分的逻辑则被分布在了ModuleFactory中，将compilation与Module解耦，两者中一方发生变化，只需在ModuleFactory中增加逻辑即可。 感受由于webpack过于庞大，看源码的过程感觉是在修行。写这篇文章之初准备深入到一些技术细节，后来感觉意义不大。也尝试过列举在简单js模块打包流程上涉及到的默认插件，写出来像API手册，如果完全写完，体量可能都接近半本书了。最后，决定拿小学3年级画画水平，将最基本的架构关系画出来。 最大的感受就是：当你真的准备设计一个库的时候，应该在实现之前充分列举可能的应用场景，将充分抽象出稳定的基本架构，然后将难办的部分，复杂度很高的部分，或者说定制化需求比较多的部分，采用开放插件的方式扔给使用者去解决。","categories":[{"name":"技术原创","slug":"技术原创","permalink":"http://jabbla.github.io/categories/技术原创/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://jabbla.github.io/tags/javascript/"},{"name":"webpack","slug":"webpack","permalink":"http://jabbla.github.io/tags/webpack/"},{"name":"node.js","slug":"node-js","permalink":"http://jabbla.github.io/tags/node-js/"}]},{"title":"2018.4.14 杭州，阴","slug":"2018-4-14-杭州，阴","date":"2018-04-14T03:30:00.000Z","updated":"2018-04-19T13:40:18.183Z","comments":true,"path":"2018/04/14/2018-4-14-杭州，阴/","link":"","permalink":"http://jabbla.github.io/2018/04/14/2018-4-14-杭州，阴/","excerpt":"","text":"昨天刷知乎突然看到韩寒当年舌战各学者的片段，虽然这么多年一直觉得他是个很牛逼的人，但是看完将近1小时的视频之后还是惊叹这个17岁的高中生，在我还会因为老师的批评瑟瑟发抖的年纪，能够面对教授学者面不改色，甚至还能以嘲讽的口吻回击，其胆魄和想法甚至都远超现在很多的中年人。 但是不难发现一个细节，当主持人询问三重门含义的时候，韩寒给出了撒泼打滚式的回答：我忘了。嗯，很多摇滚青年应该会不自觉地冒出”牛逼”两个字。但是这个回答不禁让我想到了前一阵的那个奔驰车主，或许那个车主也是浩浩荡荡所谓摇滚青年中的一位吧。 我的文字很烂，语文一直是弱项，高考语文成绩也就将将110的水平。貌似没有资格从文字的角度去猜测三重门是否为韩寒父亲代笔…但是就他这么多年完全不谈自己21万长篇小说的思路和创作过程，我完全有理由怀疑三重门是韩寒亲自创作的真实性。或许当年要不是方舟子太讨人厌了，韩寒或许不会有现在的名气和广泛的好评。 当然，一切都是猜测，没有确凿的证据无法一棒子打死。我在学生时代看过很多韩寒的博客和杂文，在当时的我眼中，有两个人是偶像，一个罗永浩，一个韩寒。他们从某种程度上都是这个社会的搅局者，敢于发出不同的声音，而且在当时的我看来，逻辑是那么的正确，而且总能把我弄得热血沸腾，以至于当时看了老罗在吉林大学的演讲视频之后，对吉大有种莫名的好感，或许去那里能离老罗近一点吧，这货现在想起来居然决定了我的人生。如果不是他，我生活4年的大学不是吉林大学，而是电子科技大学。 嗯，我觉得这个社会需要破坏者。不管韩寒当时的三重门是否真的是他人代笔，他的出现是非常有价值的，老罗也是一样。对权威的质疑和独立思考，在我看来是这个社会一直缺乏的。现在满天的公众号，大V，公知，各种知乎live，高赞的水文，水书，鸡汤。这些东西满天飞，越来需要我们有独立思考能力，很多东西并没有定论，少去相信从结果推倒出来的结论，一切都在于自己，盲从是毒药，少数人的声音一直是很有价值的。 嗯，就这么多。","categories":[{"name":"杂记","slug":"杂记","permalink":"http://jabbla.github.io/categories/杂记/"}],"tags":[]},{"title":"2017年度总结","slug":"2017年度总结","date":"2018-01-02T15:11:00.000Z","updated":"2018-01-03T14:33:00.172Z","comments":true,"path":"2018/01/02/2017年度总结/","link":"","permalink":"http://jabbla.github.io/2018/01/02/2017年度总结/","excerpt":"这个总结托了有3天了，现在终于下定决心写一写，总归是懒。这病2018年真得治一治。","text":"这个总结托了有3天了，现在终于下定决心写一写，总归是懒。这病2018年真得治一治。 杂感离开学校2017年最大的事就是离开吉大了，说实话，没什么感觉。总听人说，进入社会以后，会怀念校园生活。而我却觉得进入社会后的生活给人一种更加踏实的感觉。因为所做的每一件事的背后，都有清晰的目标做支撑，相比在校园中的迷茫，我更加喜欢现在的状态。 离开了讨厌的考试，不再需要去花时间学习自己不喜欢的课程，不需要每天像僵尸一样坐在教室里等待签到的那一刻。 开始工作虽然以前有过实习的经历，但基本就是跟着别人做一些需求。现在也有机独立负责一个项目，可以说获得了一些项目经验，从一开始遇到问题慌慌张张到还算有条不紊。熟悉了一些流程规范，发现了一些问题。从发现问题-&gt;解决问题-&gt;总结这一过程中获得的一些除了技术之外的经验，比如任务管理，遇事心态等。 2017技术相关今年算是对前端有了比较全面的涉猎，从毕设-&gt;面试-&gt;工作这三个阶段都有不同的收获。 1. Node.js毕设写了个图书资源搜索系统，使用node.js实现了30w本图书的爬虫，封装了一个爬虫框架，当时觉得用起来还行，现在回过头看看，缺陷还是蛮多的，最主要的功能设计从一开始并没有想好，使得后期扩展功能会有比较大的改动。然后拿koa2写了个超蹩脚的搜索系统服务器，基本属于东拼西凑。 几个月前，嫌html-webpack-plugin不好用，自己写了个比较轻量插件scriptText-webpack-plugin，实现比较简单，用来自动生成引用打包目标文件的script标签。 2. 算法+WebAR准备面试过程其实就是刷题，查漏补缺，最主要的就是看了一些算法，写了个基于WebGL+WebRTC的简单的WebAR Demo，算是知道了WebAR基本上是怎么回事，但面试的时候并没有太多地涉及到这两部分。 3. MV*框架工作阶段算是真正开始思考一些跟实际生产联系比较紧密的技术问题。刚开始脑袋一热前前后后花了1周的时间工作之余写了个类似Regular和React的框架，虽然模板解析器直接拷贝Regular的parser，但是还是有一些成就感的，利用的Web Worker的能力，在前端实现SSR，不过这个SSR比较彻底，每一次状态改变后的渲染操作都放在worker中进行。不过这个框架属于边想边写，其中逻辑写得太过耦合，导致后期的小改动影响的地方会非常多，极其难以维护。所以基本属于放弃迭代的状态。 写了基于Regular的rwatch库，找到一种不同于传统开发方式的概念，基于属性映射的开发，我觉得这种属性映射的开发方式有很大的挖掘空间，因为基于它开发的页面，逻辑是容易还原的，逻辑与代码的组织形式有着比较强的统一性，以致于维护时不需要看代码即可了解到页面的大体逻辑，或者知道了页面的逻辑即可自动生成出代码的组织形式，同时也可以方便定位bug。不过目前还没有时间写相应的功能扩展来证明这种想法的可行性。 输出博文比较懒，稍微能看的文章也就3篇： Webpack原理分享（一）： webpack最基本的插件系统，基本就是对tapableAPI的总结。下一次分享会从一个打包工具的演进过程的角度对webpack背后思路做一个剖析。 Regular基于属性映射的开发方式：在regular的基础上探索了一种基于属性映射的开发方式，这种开发方式的好处就是逻辑与代码的组织形式有比较好的统一性，可从代码的组织形式到逻辑的生成（逻辑可视化），也可从逻辑到代码组织形式的生成（代码原型一键生成），这两点还只是概念上的，考虑之后把逻辑可视化部分提上日程。 第12届d2主会场分享笔记：算是第一次参加技术分享大会，主会场讲PWA的分享嘉宾和他差不了几岁，当初还一起翻译过webgl的相关文档。但人家有能力去D2做分享，这就是差距，整个大会下来最大的感受就是自己还是太懒，缺乏坚持，不够努力。 总结2017年对自己来说是非常重要的一年，还算有意义的付出，学会了面对，也接受了一些东西。但是现在的能力还远远达不到自己心中理想的状态，还是懒，尤其是离开学校以后，基本周末睡到中午，吃个饭，打球，看剧。真的是一点自制力都没有。嗯，得改一改。 2018技术计划 形成良好的代码习惯 深入研究前端的某一领域 对这一领域内各个优秀轮子有比较深刻的理解 汲取优秀轮子的优点，开发适合自己的轮子 养成习惯 规律作息 常记录、分类与整理 每月一篇博文（技术原创分类） 总结总的来说就是能在技术视野和技术习惯上有比较大的突破吧。主要还是生活上，要养成早起，整理的习惯，有规律的作息。就这么多吧，能说的总有很多，但是能做到的又有多少呢，嗯，要坚持。","categories":[{"name":"杂记","slug":"杂记","permalink":"http://jabbla.github.io/categories/杂记/"}],"tags":[]},{"title":"第12届d2主会场分享笔记","slug":"第12届d2主会场分享笔记","date":"2017-12-18T13:10:00.000Z","updated":"2017-12-20T11:10:55.338Z","comments":true,"path":"2017/12/18/第12届d2主会场分享笔记/","link":"","permalink":"http://jabbla.github.io/2017/12/18/第12届d2主会场分享笔记/","excerpt":"第一次参加D2，收获当然是有的，中了一支圆珠笔……只能眼睁睁地看着别人抱着键盘回去。不说了，还是大概地捋一下主会场的分享，先来一篇流水账吧。","text":"第一次参加D2，收获当然是有的，中了一支圆珠笔……只能眼睁睁地看着别人抱着键盘回去。不说了，还是大概地捋一下主会场的分享，先来一篇流水账吧。 轻舟简单讲就是，用尽可能少的研发周期，获得更多的用户体验，把APP开发简单地分为5个步骤： 初始化：云端一键配置，免去繁琐的手动搭建环境工作 本地开发：使用轻舟的IDE，支持基于Weex和Rax的开发方式，提供了ui库，实现插件系统，达到灵活定制的目的，提供了一些使用频率较高内置插件 打包：一键打包，提供相应的开发调试工具 提交APP store 更新 QA环节问：是否考虑支持RN答：以后可能会提供支持，不过由于license的问题，暂时不会考虑。 总结看上去很牛逼，不知道用起来怎么样，现场演示的时候出现了布局上的bug，还是比较明显的。 React同构解决方案(beidou)开场讲了一下SSR之于CSR，刚开始我还以为这就是嘉宾的”解决方案”，听到后面发现其实干货还是挺多的，除了SSR对比CSR的那些优势外，传言这个解决方案还通过采用下面这些策略将渲染性能提高了100倍： 可定制SSR模块 针对生产环境的优化 使用Babel-preset对诸如const语句的优化 定义可缓存模块 升级react16，node8 QA环节其实没有什么印象深刻的提问。有一个是问router之间如何保存状态的，其实感觉提问者并没有搞清楚使用SSR的时机，貌似还在知乎上吐槽了嘉宾答非所问。 总结分享很棒，促使我想去了解beidou，不过有一些开发者还是得从提升自己水平的角度对待问题，而不是寄希望别人，自己水平不行并不是别人必须帮你的理由。 Microbenchmark for JS贺老是通过一个引子，循序渐进地引出目前benchMark.js当前存在的问题，最后抛出自己正在做针对这些优化的测试框架，具体： console.time 不稳定，需”提前准备” new Date().getTime和Date.now的精度问题，依赖外部日期 performance.now()在Web上这种方案比较不错，精度达到5us且不依赖外部日期 process.hrtime() Node端的api，有返回ns级别的精度，不过嘉宾表示怀疑 终极的测试方案大概意思则是利用方差，置信区间等统计学方法提高测试结果的可信度 总结贺老的ppt太扎眼，不过对一个问题的深挖精神真的是探为观止，忍不住蹦出一个词”极客”，而且非常符合这次D2的”匠心”。 从Web渲染到Web计算嘉宾讲得比较快，主要就是介绍WebAR相关，自己对里面有些东西也只是稍微有点涉猎，算是外行，有以下几个印象比较深刻的点： webview向客户端发送图像的一些方法和其中的性能对比，偏向于使用异步的方式提升帧率。 解决客户端计算结果和当前相机不同步的问题，避开了前端做跟踪计算的时掉帧严重的问题。 尝试使用WebAssembly提高计算能力，实现了一个基于sobel的demo，看上去还算流畅。 QA环节这场没人提问，估计这个主题大部分在场前端没怎么听懂。 总结WebAssembly是个好东东，嗯。。不明觉厉。。 天猫超市 极致Mobile Web总体感觉就是对天猫超市交互上的缺陷做了一个总结，并给出了一些解决方案。最后安利了团队自己开发的原生组件库。 问题和对应的解决方案： 实现粗糙：制定静态和动态规范，使用视觉与最终完成的比对工具 缺乏可靠性：预加载，利用sw+webPush实现提前更新，提供重试机制和统一异常提示，增加手势识别避免误操作 操作体验差：提升响应速度，实时反馈… 交互缺乏统一设计语言：统一设计语言 QA环节问：为什么不考虑使用weex或者RN？答：1. 借助wk和u4内核体验接近native；2. 需要跨端解决方案；3. 阿里以广泛使用weex，需要探索一种差异化的道路。其他两个，一个吐槽了一下猫超的交互。另外一个提问者貌似没有注意听分享，主要就是多页面切换时候状态保存的问题，嘉宾分享也有提及，这种情况uc做了内核层面的优化。 总结除了一些具体提升性能的解决方案，分享嘉宾建议在交互方面多借鉴native优点，追求对交互细节的打磨。 PWA 带来的极速离线APP这场听得比较朦胧，虽然对worker比较熟悉，但是还没有实践过PWA 1.serviceWorker的能力： a. 页面请求代理 b. 接收后台push c. 管理离线Cache资源 d. 新开或切到某个页面这部分主要讲了实际开发中能遇到的坑点和sw的生命周期详解，坑点如严格同域，https，更新等问题。 介绍了cacheStorage，和对缓存溢出情况的几种处理方式 介绍了web push,提出sw模拟离线包概念，并与传统离线包进行了对比，看样子是完爆的赶脚 开源计划：a. 通过配置一键生成sw文件b. 相关webpack pluginc. 忘了… QA环节这次是主会场提问最多的，不过貌似都是问的具体问题的解决方案，没有哪个提问是印象深刻的。 总结对PWA了解比较少，不过嘉宾台上比较稳。关于PWA，得抽时间做个小demo出来，体验一下SW，不然快跟不上节奏了？ 支付宝无线效率工具建设这部分其实没怎么记，主要就是介绍了支付宝无线团队开发的的4个效率工具，还有嘉宾对这种工具开发的观点 联动DNS，注册调试域名 搭建IOS模拟器 真机不插线调试 AnyProxy QA环节这场貌似没有人提问 总结这场分享，给我印象最深的不是这4个效率工具，因为类似的需求场景比较少。印象最深的是嘉宾提出的3个观点： 走产品化道路：需要以产品的思维去开发，不然很难大范围使用。 个人价值：业务无法满足自己的成就感，需寻找挑战，实现自我价值 紧贴业务：提出了做工具最好与业务耦合，提高生产效率，不盲目追求开源","categories":[{"name":"杂记","slug":"杂记","permalink":"http://jabbla.github.io/categories/杂记/"}],"tags":[]},{"title":"Regular基于属性映射的开发方式","slug":"Regular基于属性映射的开发方式","date":"2017-12-09T16:01:00.000Z","updated":"2017-12-20T11:11:40.117Z","comments":true,"path":"2017/12/10/Regular基于属性映射的开发方式/","link":"","permalink":"http://jabbla.github.io/2017/12/10/Regular基于属性映射的开发方式/","excerpt":"水平有限，算是抛砖引玉吧 本文主要从几个方面展开介绍:1.什么是基于属性映射的开发方式2.如何实现属性的映射3.rwatch在实际开发中的实践4.对比传统开发方式","text":"水平有限，算是抛砖引玉吧 本文主要从几个方面展开介绍:1.什么是基于属性映射的开发方式2.如何实现属性的映射3.rwatch在实际开发中的实践4.对比传统开发方式 什么是基于属性映射的开发方式页面由许多组件组成，每个组件当前所处的状态其实就是对象的属性值，于是组件间的关系可以看作是属性之间的关系，从而整个页面的功能可以看作是一个属性关系网。 假设有组件A、B、C12A.b-&gt;B.b-&gt;C.bA.a-&gt;B.b-&gt;C.c 上图虽简单，但就已经包括了所有属性映射的情况。 影响B.b的属性有A.b，A.a，多对一。 B.b又会影响到C.b，C.c，一对多（多个1对1）。 举个例子 将下拉列表选中的文字，放入搜索框中，搜索框中输入的文字会显示在页面的标题和副标题 dropDown 下拉列表组件dropDown.selected 当前选中项的索引dropDown.source 下拉框的所有选项数组 search 搜索框组件search.value 当前搜索框中的文字 title 页面标题subTitle 页面副标题 映射关系：123dorpDown.selected + dropDown.source -&gt; search.valuesearch.value -&gt; titlesearch.value -&gt; subTitle 生成规则：123search.value = dropDown.source[dorpDown.selected].texttitle = search.valuesubTitle = search.value 一个完整的功能点 下面是一个接口相关的属性映射关系图 TrendChart 代表接口 params.xxx 接口请求参数 SetChart 获取到响应数据后的操作 data.xxx.xxx 状态 上面所说的映射关系则是从箭头的起点到箭头终点的过程，其中某个属性的改变会影响它所指向属性的改变，开发过程中只需要关注前后属性之间的关系即可，当某个属性发生变动的时候，与它相关的属性就会像一根锁链一样一环扣一环地根据各自的映射关系发生相应的改变。 如何实现属性映射在这里使用本人开发的rwatch实现属性的映射 rwatch中的属性映射其实是对Regular的$watch方法进行的封装，你可以像下面这样实现上面例子中的属性映射。 dorpDown.selected + dropDown.source -&gt; search.value12345watcher.watch(['dorpDown.selected', 'dropDown.source'], 'search.value', function(sources, target)&#123; var selected = sources[0], source = sources[1]; return source[selected].text;&#125;); search.value -&gt; titlesearch.value -&gt; subTitle123watcher.watch('search.value', ['title', 'subTitle'], function(source, target)&#123; return source;&#125;); rwatch在实际开发中的实践由于rwatch基于$watch方法，所以所有的映射规则的执行都是依赖于regular的脏检查机制。 如果你想在事件中同步地获取到通过生成规则改变后的属性是不现实的，所以一切和获取属性相关的操作都应在生成规则中，$watch方法中，或者rwatch提供的then()中。 下面通过一个真实的需求来介绍使用rwatch过程中可能遇到的坑和本人的解决方案 1. 映射关系书写不全面123watcher.watch('dorpDown.selected', 'search.value', function(source)&#123; return this.data.dorpDown.source[source].text;&#125;); 这种代码，当下拉框的列表数据发生改变的时候search.value并不会得到相应的更新，应修改为如代码 12345watcher.watch(['dorpDown.selected', 'dropDown.source'], 'search.value', function(sources, target)&#123; var selected = sources[0], source = sources[1]; return source[selected].text;&#125;); 2.组件的当前属性不支持双向数据绑定比如上述下拉框的dorpDown.selected这个属性不支持双向数据绑定，则需在事件中手动更新123onSelected: function(e)&#123; this.data.dorpDown.selected = e.selected;&#125; 3.频繁触发请求由于页面中所有组件状态的改变都是基于rwatch的，于是获取接口的请求参数在事件中无法获取到组件的最新状态，所以发送请求的行为必须放在$watch中。像下面这样: 1234567this.$watch('params.a', function()&#123; this.request();&#125;);this.$watch('params.b', function()&#123; this.request();&#125;); 上述代码解决了发送请求的问题，但是引进了一个新问题：当params.a，params.b同时发生改变时，会发送2次请求，如果params有很多属性同时改变，那么就会发送N次请求，如何解决呢？ 利用节流函数1234567request: (function()&#123; return ut.throttle(function()&#123; var option = &#123;...&#125;; this.fetchData(option); &#125;.bind(this), 500);&#125;)()； 对比传统开发方式试着使用传统开发方式完成上面的例子：123456789101112131415onDorpDownSelected: function(e)&#123; var data = this.data, dropDownSource = data.dropDown.source, text = dropDownSource[e.selected].text data.search.value = text; data.title = text; data.subtitle = text;&#125;,onSearchChange: function(e)&#123; var data = this.data; data.title = e.value; data.subTitle = e.value;&#125; 传统开发方式，起点往往是某个事件，专注于处理流程，而不是属性间的映射关系。 个人认为当页面的交互逻辑比较复杂的时候，使用属性映射的方式开发会使得组件的逻辑相较传统开发方式更加清晰、易懂。 不过这种开发方式的缺点也是明显的： 需要额外通过节流函数避免多余的请求发送 依赖脏检查机制，不够“及时” watcher过多，性能问题？ 后续会针对rwatch做更加全面详细的讨论 嗯~先抛个砖","categories":[{"name":"技术原创","slug":"技术原创","permalink":"http://jabbla.github.io/categories/技术原创/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://jabbla.github.io/tags/javascript/"},{"name":"regular","slug":"regular","permalink":"http://jabbla.github.io/tags/regular/"}]},{"title":"Webpack原理分享（一）","slug":"Webpack原理分享（一）","date":"2017-10-22T03:17:00.000Z","updated":"2017-12-20T11:12:24.403Z","comments":true,"path":"2017/10/22/Webpack原理分享（一）/","link":"","permalink":"http://jabbla.github.io/2017/10/22/Webpack原理分享（一）/","excerpt":"","text":"Webpack原理分享，这一小节主要介绍一下webpack中重要的基类Tapable Webpack原理分享（一）Tapable详解什么是Tapable? 提供事件订阅，发布功能的小型库 Webpack中重要对象的基类，为compiler，compilation等 对象提供插件系统 Tapable接口列表 Tapable.prototype.plugin 注册事件 Tapable.prototype.applyPlugin(applyPlugins，applyPluginsWaterfall...) 触发事件 Tapable.prototype.hasPlugins 判断是否存在事件 Tapable.prototype.apply 应用插件 Tapable.prototype.plugin 事件注册方法 1void plugin(names: string|string[], handler: Function) name：事件名称handler: 触发事件后运行的回调函数 Tapable.prototype.applyPlugin… 事件触发方法 applyPlugins applyPluginsWaterfall applyPluginsAsync applyPluginsBailResult applyPluginsAsyncWaterfall applyPluginsAsyncSeries applyPluginsParallel applyPluginsParallelBailResult 事件触发分类 根据回调函数的调用顺序分为2类 串行调用涉及到的方法：applyPluginsapplyPluginsWaterfallapplyPluginsAsync = applyPluginsAsyncSeriesapplyPluginsBailResultapplyPluginsAsyncWaterfall 1. Task之间相互独立 applyPlugins 同步地按照注册顺序，依次调用Task 1void applyPlugins(name: string, args: any...) name：事件名称args ：Task实参，可为多个 applyPluginsBailResult 同步地按照注册顺序，依次调用Task，一旦有Task的return值!==undefined，则不会执行剩下的Task，且applyPluginsBailResult的返回值为该Task的返回值 1any applyPluginsBailResult(name: string, args: any...) name：事件名称args ：Task实参，可为多个 applyPluginsAsync 默认Task为异步执行，Task中最后一个形参为callback，Task中手动调用callback执行下一个Task，如为callback传入！=undefined实参，则不会执行下一个Task，并且调用callback 12345void applyPluginsAsync(name: string, args: any..., callback: (err?: Error) -&gt; void) name：事件名称args：Task实参，可为多个callback：当所有Task全部执行完毕后调用的回调函数 2. Task之间可传递值 applyPluginsWaterfall 同步地按照注册顺序调用Task，每个Task的return值将作为下一个Task的第一个实参传入 12345any applyPluginsWaterfall( name: string, init: any, args: any... ) name：事件名称init：第一个Task的第一个实参args：Task除第一个实参外剩下的实参 applyPluginsAsyncWaterfall​​​​​​​ 默认Task为异步执行，Task第一个形参为上一个Task调用callback传下来的第二个实参，第一个Task为init，第二个实参为callback，Task中手动调用callback执行下一个Task，如callback第一个实参为！=undefined则不会调用下一个Task，并且调用callback 12345applyPluginsAsyncWaterfall( name: string, init: any,callback: (err: Error, result: any) -&gt; void) name：事件名称init：第一个Task的第一个实参args：Task除第一个实参外剩下的实参callback：所有Task调用结束后的回调 并行调用 applyPluginsParallel Task默认为异步执行，Task中手动调用callback表明该Task已结束，当Task全部结束时，会最终调用callback，如某个Task为callback传入实参!=undefined，则会提前执行callback 12345applyPluginsParallel( name: string, args: any...,callback: (err?: Error) -&gt; void) name：事件名称args：Task实参，可多个callback：所有Task结束后的回调函数 applyPluginsParallelBailResult Task默认为异步执行，Task中手动调用callback表明该Task已结束，当Task全部结束时，会最终调用callback，最终callback的实参根据Task的注册顺序，寻找第一个为callback传递的实参 12345applyPluginsParallelBailResult( name: string, args: any...,callback: (err?: Error) -&gt; void) name：事件名称args：Task实参，可多个callback：所有Task结束后的回调函数 应用插件Tapable.prototype.apply 调用该方法会触发传入构造函数所有实例的apply方法 123456789function Plugin()&#123;&#125;Plugin.prototype.apply = function(instance)&#123; instance.plugin('test', function()&#123;&#125;)&#125;;var a = new Tapable(new Plugin());a.apply();","categories":[{"name":"技术原创","slug":"技术原创","permalink":"http://jabbla.github.io/categories/技术原创/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://jabbla.github.io/tags/webpack/"},{"name":"node.js","slug":"node-js","permalink":"http://jabbla.github.io/tags/node-js/"}]},{"title":"浅入Redux分享","slug":"浅入Redux分享","date":"2017-09-13T13:39:00.000Z","updated":"2017-12-20T11:13:33.290Z","comments":true,"path":"2017/09/13/浅入Redux分享/","link":"","permalink":"http://jabbla.github.io/2017/09/13/浅入Redux分享/","excerpt":"","text":"组内的Redux分享 浅入Redux分享业务背景1.当很早以前完成的页面有新的需求时，需要花额外的时间去理清其中的数据处理含义。2.当一个页面工作量较大，组件较多，数据流动较复杂的时候，没有一目了然的处理方式。 对于Redux的个人理解 单一状态树：即对象。 声明式改变：打包对状态的一系列操作，并对其分类 可监听的变化 Redux 3个核心概念下面就以一个简单的todoList为例，介绍有关Redux的三个概念 State 状态树，Object State就是一个页面的状态 对于这个todoList所谓state就是： 所有的任务 ； 当前显示的任务种类（比如：已完成的，未完成的，全部）； 每个任务的具体信息； 这个对象就长下面这样：12345678910&#123; todos: [&#123; text: '整理Freemamba文档', completed: true &#125;, &#123; text: '优化Freemamba build过程', completed: false &#125;], visibilityFilter: 'SHOW_COMPLETED'&#125; Action 行为，Object 一个描述操作的对象 对于这个todoList所谓的action就是： 添加一个名为…的任务 完成指定任务 切换当前页面显示任务的种类 下面是对应的3个action123&#123; type: 'ADD_TODO', text: '实现组件嵌套' &#125;&#123; type: 'COMPLETE_TODO', index: 0 &#125;&#123; type: 'SET_FILTER', filter: 'SHOW_ALL' &#125; Reducer 定义action如何生成新的state，Function 一个函数，获取当前State，和Action，生成新State 1234567891011function reducer(state, action)&#123; switch(action.type)&#123; case 'ADD_TODO': return &#123;...&#125;; case 'COMPLETE_TODO': return &#123;...&#125;; case 'SET_FILTER': return &#123;...&#125;; default: return state; &#125;&#125; 基本使用1. 创建一个store 通过传入reducer创建store 定义reducer.js123456789101112131415161718192021222324252627var initialState = &#123; todos: [...], visibilityFilter: 'SHOW_COMPLETED'&#125;;function addTodoReducer(state, action)&#123; var todos = state.todos.concat(&#123;text: action.text, complete: false&#125;); return Object.assign(&#123;&#125;, state, &#123;todos: todos&#125;);&#125;....function reducer(state, action)&#123; if(action.type === void 0)&#123; return initialState; &#125; switch(action.type)&#123; case 'ADD_TODO': return addTodoReducer(state, action); case 'COMPLETE_TODO': return completeTodoReducer(state, action); case 'SET_FILTER': return setFilterReducer(state, action); default: return state; &#125;&#125;module.exports = reducer; 定义action1234567891011121314151617function addTodo(text)&#123; return &#123; type: 'ADD_TODO', text: text &#125;;&#125;function completeTodo(index)&#123; return &#123; type: 'COMPLETE_TODO' , index: index &#125;;&#125;function setFilter(filterName)&#123; return &#123; type: 'SET_FILTER', filter: filterName &#125;;&#125;module.exports = &#123; addTodo: addTodo, completeTodo: completeTodo, setFilter: setFilter&#125;; 创建store12345678910111213var Redux = require('redux');var reducer = reuqire('./reducer.js');var actions = require('./actions.js);var store = Redux.createStore(reducer, &#123;todos: []&#125;);/*添加一个任务*/store.dispatch(actions.addTodo('优化Freemamba Build过程'));/*获取当前状态*/store.getState();/*监听State改变*/store.subscribe(function()&#123;&#125;);/*替换Reducer*/store.replaceReducer(reducer); 简单介绍基本的APIRedux.createStore根据Reducer，preloadedState（可选，初始状态），enhancer（可选，函数）创建Store Redux.combineReducers针对状态树的每个属性，书写对应的Reducer123456789101112var reducer = Redux.combineReducers(&#123; todos: function(todos, action)&#123; if(todos === void 0)&#123; return []; &#125; switch(action.type)&#123; case 'ADD_TODO': return todos.concat(&#123;text: 'zxr', complete: false&#125;); default: return todos; &#125; &#125;&#125;); Redux.applyMiddleware包裹store._dispatch方法，创建中间件12345678910111213141516var logger = function(store)&#123; return function(next)&#123; return function(action)&#123; console.log('before dispatch', store.getState()) let returnValue = next(action); console.log('after dispatch', store.getState()); return returnValue; &#125; &#125;;&#125;var store = Redux.createStore(reducer, Redux.applyMiddleware(logger));store.$dispatch(....);//'before dispatch &#123;todos:[]&#125;'//'after dispatch &#123;todos: [&#123;text: 'zxr', complete: false&#125;]&#125;' Redux.bindActionCreators创建Action的时候，自动dispatch 动手实现一个简易的Redux实现简单的Redux，创建一个store，获取状态，分发action，监听变化 Redux.createStoreRedux.createStore(reducer, preloadState)123456789101112131415161718192021222324252627282930313233343536Redux.createStore = function(reducer, preloadState)&#123; /*获取默认状态*/ var state = preloadState || reducer(); /*创建监听列表*/ var listener = []; /*获取状态*/ var getState = function()&#123; return state; &#125;; /*分发action*/ var dispatch = function(action)&#123; state = reducer(state, action); setTimeout(function()&#123; _checkListeners(); &#125;, 0); &#125;; /*订阅变化*/ var subscribe = function(listener)&#123; listeners.push(listener); &#125;; /*执行监听器*/ var _checkListeners = function()&#123; listeners.forEach(function(item)&#123;item()&#125;); &#125;; return &#123; getState: getState, dispatch: dispatch, subscribe: subscribe &#125;;&#125;; Redux.combineReducers123456789Redux.combineReducers = function(reducerMap)&#123; return function(state, action)&#123; var ret = &#123;&#125;; for(var key in reducerMap)&#123; ret[key] = reducerMap[key](state || state[key], action); &#125; return Object.assign(&#123;&#125;, state, ret); &#125;;&#125;; Redux.applyMiddleware12345678910111213Redux.applyMiddleware = function()&#123; var middlewares = [].slice.call(arguments); return function(store)&#123; function getNext(index)&#123; if(index&gt;=middlewares.length)&#123; return store._dispatch; &#125; return middlewares[index](getNext(index+1)) &#125; return middlewares[0](getNext(1)); &#125;;&#125;;","categories":[{"name":"技术原创","slug":"技术原创","permalink":"http://jabbla.github.io/categories/技术原创/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://jabbla.github.io/tags/javascript/"},{"name":"redux","slug":"redux","permalink":"http://jabbla.github.io/tags/redux/"},{"name":"FP","slug":"FP","permalink":"http://jabbla.github.io/tags/FP/"}]},{"title":"ScriptText Webpack Plugin使用说明","slug":"ScriptText-Webpack-Plugin使用说明","date":"2017-09-13T13:30:00.000Z","updated":"2017-12-20T11:14:29.776Z","comments":true,"path":"2017/09/13/ScriptText-Webpack-Plugin使用说明/","link":"","permalink":"http://jabbla.github.io/2017/09/13/ScriptText-Webpack-Plugin使用说明/","excerpt":"","text":"写了个自动生成script标签的Webpack插件，用着比较顺手 ScriptText Webpack Plugin Webpack插件，用来自动生成script标签 应用场景：在html文件中自动添加webpack打包后的script引用 使用说明安装1npm install scripttext-webpack-plugin --save-dev 基本使用该插件会自动将位置标记替换为引用目标chunk的script标签 123456789101112131415var path = require('path');var ScriptTextPlugin = require('scripttext-webpack-plugin');module.exports = &#123; entry: &#123; page1: './src/page1/js/index.js' &#125;, output: &#123; filename: '[name]/js/index.[chunkhash:10].js', path: path.resolve(__dirname, './dist') &#125;, plugins: [ new ScriptTextPlugin(option) ]&#125;; option 插件配置对象 1234&#123; default: &#123;&#125;, //默认选项 config: [configItems] //config数组 &#125; default 默认配置，与configItem对应，基于deep assign 1234567891011121314151617181920212223/*configItem*/&#123; source: &#123; filename: 'index.html', &#125;&#125;/*default*/&#123; pageName: 'index1', source: &#123; path: p2 &#125;&#125;/*result configItem*/&#123; pageName: 'index1', source: &#123; filename: 'index.html', path: p2 &#125;&#125; configItem option.config数组项 configItem各属性含义 source：用来配置源文件的名称及路径 output: 用来配置生成后的文件及路径 pageName: 用来设置[pageName]代表的字符串 chunks: 配置引用的各个chunk script: 插入生成的script的相关规则 1234567&#123; pageName: 'page1', //页面名称，在所有的path和filename中可以用[pageName]代替 source: &#123;&#125;, output: &#123;&#125;, chunks: [chunk], script: &#123;&#125;&#125; pageName 用来设置[pageName]代表的字符串 1234有效范围source.filename source.pathoutput.filename output.pathchunk.path source 用来配置源文件的名称及路径，路径为绝对路径 1234&#123; filename: 'index.html', path: path.resolve(__dirname, './src/[pageName]/')&#125; output 用来配置生成后的文件及路径，绝对路径 1234&#123; filename: 'index.html', path: path.resolve(__dirname, './dist/[pageName]/')&#125; chunk 配置要生成script标签的chunk，其中path会原样输出 1234&#123; name: 'page1', //entry配置中的chunkName path: './[pageName]/js' //生成的script中路径&#125; script 插入生成的script的相关规则 123&#123; positionFlag: '!!!&#123;&#123;&#123;webpack-chunks&#125;&#125;&#125;' //位置标记&#125; 例子源文件123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!--positionFlag默认为&#123;&#123;&#123;webpack-chunks&#125;&#125;&#125;，如果没有该标志默认插在&lt;/body&gt;之前，如果没有&lt;/body&gt;标签则插在文件末尾--&gt;&lt;/body&gt;&lt;/html&gt; webpack.config.js123456789101112131415161718192021222324252627var path = require('path');var ScriptTextPlugin = require('scripttext-webpack-plugin');module.exports = &#123; entry: &#123; chunk1: './src/js/chunk1.js' chunk2: './src/js/chunk2.js' &#125;, output: &#123; filename: '[name].[chunkhash:10].js', path: path.resolve(__dirname, './dist') &#125;, plugins: [ new ScriptTextPlugin(&#123; default: ..., config: [ &#123; pageName: 'page1', chunks: [ &#123;name: 'chunk1', path: './[pageName]/js'&#125;, &#123;name: 'chunk2', path: './[pageName]/js'&#125; ] &#125; ] &#125;) ]&#125;; 生成的文件1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script src=\"page1\\js\\chunk1.947b04c5d3.js\"&gt;&lt;/script&gt;&lt;script src=\"page1\\js\\chunk2.a7213u22d3.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"技术原创","slug":"技术原创","permalink":"http://jabbla.github.io/categories/技术原创/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://jabbla.github.io/tags/javascript/"},{"name":"webpack","slug":"webpack","permalink":"http://jabbla.github.io/tags/webpack/"},{"name":"node.js","slug":"node-js","permalink":"http://jabbla.github.io/tags/node-js/"}]},{"title":"一些面试题的JS实现（二）","slug":"一些面试题的JS实现（二）","date":"2017-03-06T11:42:00.000Z","updated":"2017-12-20T11:15:07.369Z","comments":true,"path":"2017/03/06/一些面试题的JS实现（二）/","link":"","permalink":"http://jabbla.github.io/2017/03/06/一些面试题的JS实现（二）/","excerpt":"","text":"接着上一部分的面试题继续 树的子结构题目： 输入两颗二叉树A和B，判断B是不是A的子结构。123456789function calc(tree1,tree2)&#123; if(!tree2) return true; if(!tree1) return false; if(tree1.value===tree2.value)&#123; return calc(tree1.left,tree2.left) &amp;&amp; calc(tree1.right,tree2.right); &#125;else&#123; return calc(tree1.left,tree2) || calc(tree1.right,tree2); &#125;&#125; 思路： 自己假想一下如果让你判断一个结构是否是另一个结构的子结构，你会怎么做，放心，你会发现规律的； 额外扩展题： 输入两个二叉树，找出它们的不同12345678910111213141516function diff(tre1,tre2)&#123; var diffs = []; var calc = function(tree1,tree2)&#123; if(!tree1 &amp;&amp; !tree2) return; if(!tree1 || !tree2 || tree1.value!==tree2.value)&#123; var v1 = tree1 &amp;&amp; tree1.value, v2 = tree2 &amp;&amp; tree2.value; diffs.push([v1,v2]); &#125;else if(tree1.value===tree2.value)&#123; calc(tree1.left,tree2.left); calc(tree1.right,tree2.right); &#125; &#125; calc(tre1,tre2); return diffs;&#125; 思路：跟上一题思路有相似之处，开动脑筋哦。 二叉树的镜像题目：请完成一个函数，输入一个二叉树，该函数输出它的镜像。123456789function calc(tree)&#123; if(!tree) return; var temp = tree.left; tree.left = tree.right; tree.right = temp; calc(tree.left); calc(tree.right); return tree;&#125; 思路：这道题，我想大家都知道怎么办了吧，观察镜像后二叉树的特征，很容易得到答案。 顺时针打印矩阵题目： 输入一个矩阵，按照从外向里以顺时针的顺序一次打印出每一个数字。例如：如果输入如下矩阵1 2 3 45 6 7 89 10 11 1213 14 15 16则打印出数字1、2、3、4、8、12、16、15、14、13、9、5、6、7、11、101234567891011121314151617181920212223242526272829303132333435363738function calc(mar)&#123; var start = &#123;x: 0,y: 0&#125;, rowLength = mar[0].length, colLength = mar.length; var doCalc = function(startP)&#123; if(rowLength&lt;=0 &amp;&amp; colLength&lt;=0) return; var startX = startP.x, startY = startP.y; var rowEnd = startX+rowLength-1, colEnd = startY+colLength-1; var i; //正方形的上边 for(i=startX;i&lt;rowEnd;i++)&#123; console.log(mar[startY][i]); &#125; //右侧 for(i=startY;i&lt;colEnd;i++)&#123; console.log(mar[i][rowEnd]); &#125; //下侧 for(i=rowEnd;i&gt;startX;i--)&#123; console.log(mar[colEnd][i]); &#125; //左侧 for(i=colEnd;i&gt;startY;i--)&#123; console.log(mar[i][startX]); &#125; rowLength -= 2; colLength -= 2; doCalc(&#123;x: startX+1, y: startY+1&#125;); &#125; doCalc(start)&#125; 思路：每一圈当作一个循环，每一个循环的特征就是起始点不同，然后判断出结束状态，这道题很简单 包含min函数的栈题目： 定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的min函数。在该栈中，调用min、push及pop的时间复杂度都是O(1)。123456789101112131415161718192021222324252627282930313233function minStack()&#123; this.mStack = []; this.Stack = [];&#125;minStack.prototype.push = function(num)&#123; var Stack = this.Stack, mStack = this.mStack; Stack.push(num); var min = mStack[mStack.length-1]; if(min&gt;=num || typeof min === 'undefined')&#123; mStack.push(num); &#125;&#125;minStack.prototype.pop = function()&#123; var Stack = this.Stack, mStack = this.mStack; var min = mStack[mStack.length-1]; var pop = Stack.pop(); if(min===pop)&#123; mStack.pop(); &#125; return pop;&#125;minStack.prototype.min = function()&#123; var Stack = this.Stack, mStack = this.mStack; return mStack[mStack.length-1];&#125; 思路：创建一个辅助栈，在栈顶存储进栈时最小的元素即可。 栈的压入、弹出序列题目：输入两个整数序列，第一序列表示栈的压入顺序，请判断第二序列是否为该栈的弹出序列。假设压入栈的所有数字均不相等。例如序列1、2、3、4、5是某栈的压栈序列，序列4、5、3、2、1是该栈序列对应的一个弹出序列，但4、3、5、1、2就不可能是该压栈序列的弹出序列。123456789101112131415161718192021222324function calc(enterQueue,popQueue)&#123; for(var i=0;i&lt;popQueue.length;i++)&#123; var pop = popQueue[i]; var enterIndex = enterQueue.indexOf(pop); var posPop1 = enterQueue[enterIndex+1]; var posPop2 = enterQueue[enterIndex-1]; var nextPop = popQueue[i+1]; var possiblePop = &#123;&#125;; possiblePop[posPop1] = enterIndex+1; possiblePop[posPop2] = enterIndex-1; console.log(pop,possiblePop,nextPop,enterIndex); if(!nextPop)&#123; return true; &#125; if(possiblePop[nextPop] || possiblePop[nextPop]===0)&#123; enterQueue.splice(enterIndex,1); &#125;else&#123; return false; &#125; &#125;&#125; 从上往下打印二叉树题目：从上往下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。12345678910function calc(tree)&#123; var queue = [tree]; while(queue.length&gt;0)&#123; var temp = queue.shift(); console.log(temp.value); temp.left &amp;&amp; queue.push(temp.left); temp.right &amp;&amp; queue.push(temp.right); &#125;&#125; 思路：利用队列的特性，完成二叉树的宽度优先遍历 二叉搜索树的后序遍历序列题目： 输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则返回true，否则返回false。假设输入的数组的任意两个数字都互不相同。12345678910111213141516171819202122232425function calc(array)&#123; var docalc = function(left,right)&#123; if(left===right) return true; var root = array[right]; var leftC = [], rightC = []; for(var i=left;i&lt;right;i++)&#123; var item = array[i]; if(item&lt;root &amp;&amp; !push(leftC,&#123;index: i,value: item&#125;)) return false; if(item&gt;root &amp;&amp; !push(rightC,&#123;index: i,value: item&#125;)) return false; &#125; return docalc(leftC[0].index,leftC[leftC.length-1].index) &amp;&amp; docalc(rightC[0].index,rightC[rightC.length-1].index); &#125;; var push = function(arr,obj)&#123; var index = obj.index, value = obj.value; if(arr[arr.length-1] &amp;&amp; (arr[arr.length-1].index+1)!==index &amp;&amp; arr.length!==0)&#123; return false; &#125;else&#123; arr.push(obj); return true; &#125; &#125; return docalc(0,array.length-1);&#125; 思路： 像这种给出序列去判断的问题，一般会先找到根节点，然后再递归判断 二叉树中和为某一值的路径题目：输入一颗二叉树和一个整数，打印出二叉树节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。123456789101112131415161718function calc(tree,integer)&#123; var path = []; var docalc = function(tree,sum)&#123; path.push(tree? tree.value : 'undefined'); if(!tree)&#123; return; &#125; sum = sum+tree.value; if(sum===integer)&#123; console.log(path); &#125; docalc(tree.left,sum); path.pop(); docalc(tree.right,sum); path.pop(); &#125; docalc(tree,0);&#125; 思路： 不难看出保存路径的数据结构实际是一个栈，因为路径要与递归状态调用状态一致，而递归调用的本质就是一个压栈和出栈的过程。 字符串的排列题目：输入一个字符串，打印出该字符串中字符的所有排列。例如输入字符串abc，则打印出由字符a、b、c所能排列出来的所有字符串abc、acb、bac、bca、cab和cba.123456789101112131415161718192021222324function calc(str)&#123; var strArray = str.split(''); var path = []; var docalc = function(array)&#123; if(array.length===1)&#123; path.push(array[0]); console.log(path); path.pop(); return; &#125; for(var i=0;i&lt;array.length;i++)&#123; var left = array[0]; array[0] = array[i]; array[i] = left; path.push(array[0]); docalc(array.slice(1)); path.pop(); var temp = array[0]; array[0] = left; array[i] = temp; &#125; &#125; docalc(strArray);&#125; 思路： 利用递归思想，想固定一个位置，然后求剩余位置的排列；","categories":[{"name":"技术原创","slug":"技术原创","permalink":"http://jabbla.github.io/categories/技术原创/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://jabbla.github.io/tags/javascript/"},{"name":"算法","slug":"算法","permalink":"http://jabbla.github.io/tags/算法/"}]},{"title":"一些面试题的JS实现（一）","slug":"一些面试题的JS实现（一）","date":"2017-03-02T11:39:00.000Z","updated":"2017-12-20T11:15:32.281Z","comments":true,"path":"2017/03/02/一些面试题的JS实现（一）/","link":"","permalink":"http://jabbla.github.io/2017/03/02/一些面试题的JS实现（一）/","excerpt":"","text":"这些题目摘自《剑指offer》，会给出实现，思路，但是不会详细讲解，大家开动起脑筋吧 1.实现一个单例模式123456function single(func)&#123; var instance; return function(config)&#123; return instance || new func(config); &#125; &#125; 主要就是使创建的对象始终保存在一个引用中，下次创建的时候如果引用不为空则使用引用的值 2.二维数组的查找题目：在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。1 2 8 92 4 9 124 7 10 136 8 11 151234567891011121314function find(array,num)&#123; var find = function(x,y)&#123; if(x&gt;array[0].length-1 || y&gt;array.length-1) return false; var value = array[x][y]; if(value&lt;num)&#123; return find(x+1,y) || find(x,y+1); &#125;else if(value&gt;num)&#123; return false; &#125;else if(value===num)&#123; return &#123;x: x,y: y&#125; &#125; &#125; return find(0,0);&#125; 思路：这个题理解题目意思很重要，发现该二维数组的特征，假设一个输入，根据数组的特征一步步代入，就会发现规律，我选择从左上角开始验证。 上述代码是初始形态，还不够完善，由于存在重复比较的情况，所以在这里引入一个二维数组来存储节点的结果1234567891011121314151617181920function find(array,num)&#123; var dp = array.map(function(value)&#123; return value.map(function()&#123; return false; &#125;) &#125;); var find = function(x,y)&#123; if(x&gt;array[0].length-1 || y&gt;array.length-1) return false; if(dp[x][y]!==false) return dp[x][y]; var value = array[x][y]; if(value&lt;num)&#123; return find(x+1,y) || find(x,y+1); &#125;else if(value&gt;num)&#123; return dp[x][y] = false; &#125;else if(value===num)&#123; return &#123;x: x+1,y: y+1&#125; &#125; &#125; return find(0,0);&#125; 3.重建二叉树题目：输入某二叉树的前序和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数组。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，输出它的头节点。12345678910111213141516171819202122232425262728293031323334353637383940function buildBTree(front,middle)&#123; var build = function(Node,Range)&#123; var x = front.indexOf(Node.value), y = middle.indexOf(Node.value), leftTree = [Range.start,y-1], rightTree = [y+1,Range.end], leftTable = &#123;&#125;, rightTable = &#123;&#125;, leftNode,rightNode,leftStop,rightStop; middle.slice(leftTree[0],leftTree[1]+1).forEach(function(value)&#123; leftTable[value] = true; &#125;); middle.slice(rightTree[0],rightTree[1]+1).forEach(function(value)&#123; rightTable[value] = true; &#125;); for(var i=x+1;i&lt;front.length;i++)&#123; if(!leftStop&amp;&amp;leftTable[front[i]])&#123; leftNode = &#123;value: front[i]&#125;; leftStop = true; &#125; if(!rightStop&amp;&amp;rightTable[front[i]])&#123; rightNode = &#123;value: front[i]&#125;; rightStop = true; &#125; if(leftStop&amp;&amp;rightStop) break; &#125; Node.left = leftNode; Node.right = rightNode; if(leftNode) build(leftNode,&#123;start: Range.start,end: y-1,&#125;); if(rightNode) build(rightNode,&#123;start: y+1,end: Range.end&#125;); return; &#125; var root = &#123;value: front[0]&#125;; build(root,&#123;start: 0,end: middle.length-1&#125;); return root;&#125; 做好这道题需要充分理解二叉树的前序，中序，和后序遍历的原理，结合两个序列，先自己重建一遍树的结构，然后找寻其中的规律 4.用两个栈实现队列题目：用两个栈实现一个队列。队列的声明如下：请实现两个函数appendTail和deleteHead，分别完成在队列尾部插入节点和在队列头部删除结点的功能。12345678910111213141516function queue()&#123; this.stack1 = [], this.stack2 = [];&#125;queue.prototype.appendTail = function(item)&#123; return this.stack2.push(item);&#125;queue.prototype.deleteHead = function()&#123; if(!this.stack1.length)&#123; while(this.stack2.length)&#123; this.stack1.push(this.stack2.pop()); &#125; &#125; return this.stack1.pop();&#125; 思路： 利用两个栈，一个负责进一个负责出，出的时候只需要将进栈序列颠倒即可 5.旋转数组的最小数字题目：把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1；12345678910111213141516function findMin(arr)&#123; var find = function(left,right)&#123; var middle = parseInt((left+right)/2); var mdValue = arr[middle]; var lValue = arr[left]; var rValue = arr[right]; if((right-left)===1) return rValue&gt;lValue? lValue:rValue; if(mdValue&gt;rValue)&#123; return find(middle,right); &#125;else if(mdValue&lt;rValue)&#123; min = mdValue; return find(left,middle); &#125; &#125; return find(0,arr.length-1);&#125; 思路：不要想着遍历所有的元素找出最小的，这是很低级的做法，这道题完全可以利用旋转数列的特征，虽然这个数列不是完全的有序数列，不过依然能够通过有序数列的排序算法求解，这里我使用基本的二分查找实现它 6.斐波那契数列题目：写一个函数，输入n，求斐波那契(Fibonacci)数列的第n项。斐波那契数列的定义如下：f(0) = 0,f(1) = 1,f(n) = f(n-1)+f(n-2) 思路：有人说这道题不是很简单吗？直接写个递归不就好了，如下12345function calc(n)&#123; if(n===0) return 0; if(n===1) return 1; return calc(n-1)+calc(n-2);&#125; 仔细思考一下，这个方法是不是重复计算了，就跟第3道面试题是差不多的，是不是需要一个储存计算值的数组呢？像下面这样1234567891011function calc(n)&#123; var dp = []; var cal = function(index)&#123; if(index===0) return 0; if(index===1) return 1; dp[index-1] = dp[index-1] || cal(index-1); dp[index-2] = dp[index-2] || cal(index-2); return dp[index-1]+dp[index-2]; &#125; return cal(n); &#125; 当然了，这道题还有一些其它的写法，不说了，都很简单。 7.二进制中1的个数题目： 请实现一个函数，输入一个整数，输出该数二进制表示中1的个数。例如把9表示成二进制是1001，有2位是1.因此如果输入9，该函数输出2.12345678910function calc(num)&#123; if(num===0) return 0; var count = 0, moR; while(num!==1)&#123; moR = num % 2; if(moR===1) count++; num = (num-moR)/2; &#125; return ++count;&#125; 思路：这道题都不会的小伙伴需要重新学习一下《计算机导论》。。。就是十进制转换成二进制，需要注意的就是一定要考虑全面，往往越简单的题，面试官期望得到的答案越全面。 8.数值的整数次方题目： 实现函数double Power（double base , int exponent），求base的exponent次方。不得使用库函数，同时不需要考虑大数问题。12345678910111213141516function calc(base, exponent)&#123; if(base===0||base===1) return base; if(exponent&lt;0) return false; var dp = []; var do1 = function(base,exponent)&#123; if(exponent===0) return 1; if(exponent===1) return base; if(exponent%2===0)&#123; return dp[exponent] = dp[exponent] || do1(base,exponent/2)*do1(base,exponent/2); &#125;else&#123; dp[exponent-1] = dp[exponent-1] || do1(base,(exponent-1)/2)*do1(base,(exponent-1)/2); return dp[exponent-1]*base; &#125; &#125; return do1(base,exponent);&#125; 思路： 将exponent拆分成两个相同的部分，利用数组记录其中一个的结果，使用递归实现，需注意当exponent是偶数，拆分成两个exponent/2，如果是奇数则是两个(exponent-1 )/2 与一个base 9.调整数组顺序使奇数位于偶数前面题目： 输入一个整数数组，实现一个函数来调整该书组的数字顺序，使得所有技术位于数组的前半部分，所有偶数位于数组的后半部分。123456789101112131415161718192021function calc(array)&#123; var left = 0, right = array.length-1, temp,itemL,itemR; while(right&gt;=left)&#123; console.log(right,left); itemL = array[left]%2; itemR = array[right]%2; if(itemL===0) left++; if(itemR!==0) right--; if(itemL &amp;&amp; !itemR) &#123; temp = array[left]; array[left] = array[right]; array[right] = temp; left++; right--; &#125; &#125; return array;&#125; 思路： 根据题目的特点，可以轻易发现，只要每次判断数组两端的值即可，所以拿两个变量分别记录数组的首部和尾部，然后分情况讨论首尾是否移动","categories":[{"name":"技术原创","slug":"技术原创","permalink":"http://jabbla.github.io/categories/技术原创/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://jabbla.github.io/tags/javascript/"},{"name":"算法","slug":"算法","permalink":"http://jabbla.github.io/tags/算法/"}]},{"title":"纯SVG实现进度圈","slug":"纯SVG实现进度圈","date":"2016-09-09T06:28:00.000Z","updated":"2017-12-20T11:16:42.731Z","comments":true,"path":"2016/09/09/纯SVG实现进度圈/","link":"","permalink":"http://jabbla.github.io/2016/09/09/纯SVG实现进度圈/","excerpt":"进度圈是经典的仪表盘元素，可以将统计数据直观地展现为摘要视图。我们可以通过javascript+canvas+css，图片或者利用SVG实现一个进度圈。","text":"进度圈是经典的仪表盘元素，可以将统计数据直观地展现为摘要视图。我们可以通过javascript+canvas+css，图片或者利用SVG实现一个进度圈。 See the Pen SVG Progress Circle - Sass by Airen (@airen) on CodePen. 使用SVG实现一个进度圈并没有想象中那么难，我们先从基本的开始： 1.-创建背景首先，创建一个半径为90px的圆形，然后使用cx,cy设置圆心在svg中的位置。我在这里还添加了一些样式属性，比如3px的灰色轮廓。123&lt;svg width=\"240\" height=\"240\" xmlns=\"http://www.w3.org/2000/svg\"&gt; &lt;circle r=\"90\" cy=\"120\" cx=\"120\" stroke-width=\"3\" stroke=\"#333\" fill=\"none\"/&gt;&lt;/svg&gt; 2.-添加进度效果现在需要在刚才的背景上再添加一个表示进度的圆形：1234&lt;svg width=\"240\" height=\"240\" xmlns=\"http://www.w3.org/2000/svg\"&gt; &lt;circle id=\"backdrop\" r=\"90\" cy=\"120\" cx=\"120\" stroke-width=\"3\" stroke=\"#333\" fill=\"none\"/&gt; &lt;circle id=\"progress\" r=\"90\" cy=\"120\" cx=\"120\" stroke-width=\"4\" stroke=\"red\" fill=\"none\"/&gt;&lt;/svg&gt; 好了，现在我们已经画好了需要的两个圆，可以想象，100%可以用一个全红的圆形表示，但是，如果我想表示一个具体的百分比呢？ 3.-stroke-dasharray与stroke-dashoffset接下来需要书写CSS，SVG提供了stroke-dasharray和stroke-dashoffset两个属性，它们可以将刚才的圆形的轮廓变成虚线。如果两个属性都被设置成100px,会有下面的效果：1234#progress &#123; stroke-dasharray: 100px; stroke-dashoffset: 100px;&#125; 然后，我们可以使用keyframe为其添加一些动画：1234567891011121314#progress &#123; stroke-dasharray: 100px; stroke-dashoffset: 100px; animation: progressAnimation 600ms linear infinite;&#125;@keyframes progressAnimation &#123; from &#123; stroke-dashoffset: 100px; &#125; to &#123; stroke-dashoffset: 300px; &#125;&#125; 4.-实现具体百分比的表示到目前为止，动画效果，进度圆和背景圆都已经完成，最后的工作就是使用stroke-dashoffset stroke-dasharray将给定的百分比表示出来，这可能会涉及到数学方面的知识。 在这里我们使用Sass完成这项工作，当然，利用javascript+CSSDOM这个组合也可以实现我们想要的效果(可以处理浮点数的情况)。123456789101112131415161718192021$radius: 90;$percent: 83;$circumference: (pi() * (2 * $radius));$stroke_percentage: $circumference - (($percent / 100) * $circumference);#progress &#123; stroke-dasharray: $circumference; stroke-dashoffset: $circumference;&#125;#progress &#123; animation: progressAnimation 1600ms linear 500ms forwards; transition: stroke-dasharray 400ms linear;&#125;@keyframes progressAnimation &#123; to &#123; stroke-dashoffset: $stroke_percentage; &#125;&#125; 首先，我们设置了一些需要用到的变量，$radius(圆的半径)，percent(需要展示的百分比)，$circumference(圆的周长)。 接下来，对$circumference做减法算出stroke-dashoffset的值。 如果你尝试运行这个例子，会发现圆的进度条会以3点钟方向为起点，为了修正这个问题，我们需要将整个SVG 逆时针旋转90° 完成我添加了一些其它的效果，这些效果多少也都会涉及一些数学知识。 See the Pen SVG Progress Circle - Sass by Airen (@airen) on CodePen. 如果你有任何的问题，可以在文章下面留言。另外，在前面示例的基础上采用一些JavaScript代码来处理进度条百分比的效果： See the Pen SVG Progress Circle JS by Airen (@airen) on CodePen.","categories":[{"name":"技术译文","slug":"技术译文","permalink":"http://jabbla.github.io/categories/技术译文/"}],"tags":[{"name":"html","slug":"html","permalink":"http://jabbla.github.io/tags/html/"},{"name":"svg","slug":"svg","permalink":"http://jabbla.github.io/tags/svg/"}]},{"title":"SVG元素上的transform","slug":"SVG元素上的transform","date":"2016-09-06T04:41:00.000Z","updated":"2017-12-20T11:17:27.620Z","comments":true,"path":"2016/09/06/SVG元素上的transform/","link":"","permalink":"http://jabbla.github.io/2016/09/06/SVG元素上的transform/","excerpt":"同HTML元素一样，我们可以通过transform函数操作SVG元素。然而transform在SVG元素和HTML元素上的工作方式会有一些差别。","text":"同HTML元素一样，我们可以通过transform函数操作SVG元素。然而transform在SVG元素和HTML元素上的工作方式会有一些差别。首先，IE不支持SVG元素的CSS transform属性，但是如果只是应用一些2D变换，为了适配IE,我们可以使用SVG的transform属性。 SVG的transform属性中的所有函数的参数只能是纯数字，比如说，我们不能在translate函数中使用%单位（虽说在火狐浏览器中的css transform属性也不能使用—此处有链接—），rotate，skew角度只能使用deg单位，我们能在css transform属性中可以使用的所有其它单位在这里都不能使用。 注：火狐浏览器现在已经支持transform-origin上应用带有%的值，不过与chorme不同的是，火狐的%是相对于svg画布而不是元素自身。 而且蛋疼的是，JS的特征检测会有问题（通过js读取在外部css文件中设置的transform属性会返回与其等价的矩阵），所以我们需要另外一种检测IE的方法，或者直接在html上书写transform属性。 SVG元素和HTML元素工作方式的差异，主要是由元素坐标系的不同造成的。无论是HTML元素还是SVG元素，都有一个自己的坐标系。对于HTML元素，初始的坐标原点在元素的中心。对于SVG元素，其坐标系原点是在svg画板的（0，0）处（假设在svg标签内祖先元素和自身都不存在任何变换）。如果SVG元素的中心点不在画板的(0,0)点，像rotate,scale或者skew这些变换的结果，都会与HTML元素上应用的结果大不一样。 为了更好地理解这些差异，让我们来看看transform函数是如何工作的。 transform函数是如何工作的我们要清楚在一个存在嵌套的元素上应用变换会有叠加效果。也就是说，在一个包含后代的元素上应用变换，后代元素也会根据自己的坐标系产生相应的变换。为了方便起见，我们后面的例子都是以祖先元素不存在变换，并且其中不包含任何子孙元素为前提的。 位移translation会在相同的方向上以相同的距离移动元素上的所有点，并且会保留元素上除了位置信息的所有其它信息。这种位移可以被解释成移动一个元素的坐标原点，所以位置是相对于那个坐标原点的任何元素都会被移动。这种位移之后的效果并不依赖于坐标系的位置。 translate transform: HTML 元素 (左边) vs SVG 元素 (右边) 上面的图片展示了当translate分别应用到HTML元素和SVG元素上的区别。 正如我们看到的，它们的区别在于各自坐标系的位置。HTML元素的坐标原点在自身50% 50%处，SVG元素的坐标原点在SVG画布0 0处，不过无论坐标原点处在什么位置，它们最后呈现的效果都是一样的。 对于HTML和SVG元素，我们都可以在 CSS transform 中使用3种2D的位移函数：translateX(tx),translateY(ty)和translate(tx[, ty])。前两个分别作用在 X方向 和 Y方向(相对于元素自身的坐标系)。需要注意的是，如果在translate之前存在另外的变换，X方向，Y方向就可能不再代表着水平方向，垂直方向。而第三个位移函数则同时在x,y方向上分别移动tx,ty个单位，ty是可选的，如果不明确指定，默认是0。 SVG元素除了CSS tranform属性，还有SVG tranform属性。在这个例子中，我们在tranform属性中只定义了translate，SVG属性中可以使用逗号分隔，或者空格分隔，其中1代表着1px，下面的两种为SVG元素应用位移的方式是等价的： 使用CSS transform:1234rec &#123; /* doesn't work in IE */ transform: translate(295px, 115px);&#125; 使用SVG transform:1&lt;rect width='150' height='80' transform='translate(295 115)' /&gt; 注：SVG transform 和 CSS transform 将会被合并 连续的translate()将会被相加在一起，比如我们可以书写一个与translate(tx1 + tx2, ty1 + ty2)等价的链式写法translate(tx1, ty1) translate(tx2, ty2)，注意，这种等价关系只有当两个translate()之间没有任何其它的转换的情况下成立。从translate(tx, ty)返回到初始状态，应用translate(-tx, -ty)即可。 旋转2D旋转会基于一个固定点将元素及其子孙元素旋转一定的角度（固定点的位置在旋转前后不会被改变），旋转后的效果会因固定点位置的变化而不同。就像位移一样，旋转不会扭曲元素，元素自身的属性不会发生变化。rotate()同样具有可加性，在相反的方向应用相同角度的rotate()就能返回到初始状态。 上面展示了在两种不同元素上应用rotate()的区别。旋转一个元素，其自身的坐标系会基于原点旋转相同的角度，同时也会应用到后代元素。 一个元素上的所有点都会绕着自身的坐标原点旋转，HTML元素的坐标原点在50% 50%处，SVG元素的坐标原点则是在SVG画板的0 0处。 CSS transform中的2D旋转函数就是rotate(angle)。angle可以是多种单位的值： degrees，radians，turn,grad,我们也可以使用calc()(比如calc(.25turn - 30deg) )，这个属性现在只能在Chorme 38+/Opera 25+使用， 如果angle是正值，将会沿着顺时针方向旋转（反之，则会是逆时针）。 在SVG的transform属性中的旋转函数是这样的：rotate(angle[ x y])，angle的值与CSS transform属性中的一样(必须是无单位的degree值，正值表示顺时针旋转，负值反之，可选的x y表示旋转时固定点的位置，其值默认是该元素坐标系的原点)，如果只有x，则变换无效。 与translate()一样，参数可以使用逗号或者空格分隔。 指定x y不代表该元素的坐标原点被移动到了x y上，就像元素一样，其坐标系也同时绕着x y点旋转。 也就是说，我们可以使用两种方法旋转一个SVG元素(效果可以在上面的图片中看到)。 使用CSS transform:1234rect &#123; /* doesn't work in IE */ transform: rotate(45deg);&#125; 使用SVG transform属性：12&lt;!-- works everywhere --&gt;&lt;rect x='65' y='65' width='150' height='80' transform='rotate(45)' /&gt; 我们可以在CSS transform中指定transform-origin属性来模拟SVG中的x y参数，长度单位是相对于元素坐标系而言的，百分比单位则是以元素自身为基准，完美！！不过也有一些需要注意的地方。 首先，transform-origin，rotate()中指定固定点，两者是不一样的，比如我们需要绕着元素的50% 50%点旋转SVG元素，下面是两种实现方式：12345678rect &#123; transform: rotate(45deg); /* doesn't work as intended in Firefox * % values are taken relative to the SVG, not the element * which actually seems to be correct */ transform-origin: 50% 50%;&#125; 1234&lt;rect x='65' y='65' width='150' height='80' transform='rotate(45 140 105)' /&gt;&lt;!-- 140 = 65 + 150/2 --&gt;&lt;!-- 105 = 65 + 80/2 --&gt; 在Chorme中两者实现了相同的效果，如下图 围绕一个固定点旋转一个 SVG 元素: 使用 CSS (左边) vs. 使用SVG transform(右边) 正如上图所展示的，第一个CSS transform例子会将元素的坐标系原点移动到自身的50% 50%位置，然后基于坐标系原点旋转，第二个SVG transform例子则是仅仅将元素中心点的位置作为旋转的固定点，自身的坐标系并没有因此改变，所以所有基于自身坐标系的变换都不会发生变化。 为了加深理解，我们再应用一个相同角度45°，相反方向的roatate()：1234rect &#123; transform: rotate(45deg) rotate(-45deg); transform-origin: 50% 50%; /* Chrome, Firefox behaves differently */&#125; 1234&lt;rect x='65' y='65' width='150' height='80' transform='rotate(45 140 105) rotate(-45)' /&gt;&lt;!-- 140 = 65 + 150/2 --&gt;&lt;!-- 105 = 65 + 80/2 --&gt; 在SVG元素上链式调用旋转: CSS transforms (左边) vs. SVG transform (右边) 如图所示，在CSS transform中，设置transform-origin为50% 50%，两次的rotate()会相互抵消，因为两次的旋转都是围绕坐标系原点50% 50%，而在SVG transform中，第一次指定了旋转的固定点在元素中心，而第二次并没有指定，所以默认以元素坐标系原点为固定点。如果想实现预期的效果可以指定第二个为:rotate(-45 140 105)而不是rotate(-45)。 我们能为SVG transform的每个roatate()指定不同的固定点，但是只能为CSS transform的每个rotate()指定一个transform-origin。如果想实现一个矩形先绕右下角的点旋转90°,再绕右上角旋转90°，对于SVG tranform来说很容易实现，为每个rotate()指定不同的固定点就可以了：12345678910&lt;rect x='0' y='80' width='150' height='80' transform='rotate(90 150 160) rotate(90 150 80)'/&gt;&lt;!--bottom right: x = x-offset + width = 0 + 150 = 150 y = y-offset + height = 80 + 80 = 160top right: x = x-offset + width = 0 + 150 = 150 y = y-offset = 80--&gt; 链式调用不同固定点的rotate (SVG transform ) 我们如何做到在CSS transform中实现相同的效果呢？第一步很简单，我们可以指定transform-origin为right bottom，但是第二步呢？如果只是简单地链式书写在第一个的后面， 元素会以right bottom为固定点再次旋转90°。 为了忽略transform-origin的位置，我们需要再添加3个变换，第 一个就是 translate(x, y) ，为了与第二次的旋转固定点对应，我们使用 translate(x, y) 使元素的坐标系原点和我们希望的固定点重合，第二个就是旋转，第三个是translate(-x, -y)(第一次变换的相反操作)。 下面是上面例子的代码：1234567891011rect &#123; /* doesn't work as intended in Firefox * % values are taken relative to the SVG, not the element * which actually seems to be correct */ transform-origin: right bottom; /* or 100% 100%, same thing */ transform: rotate(90deg) translate(0, -100%) /* go from bottom right to top right */ rotate(90deg) translate(0, 100%);&#125; 下面这张图片展示了上面代码的步骤： 链式CSS transform的工作流程 然而在火狐浏览器中,transform-origin只能使用长度单位，translate()中的百分比单位也不能使用。 注：在火狐浏览器中transform-origin已经支持百分比单位了，但是它的行为与chorme不太一样，所以我们不建议您使用这个方法。 缩放缩放会在相应的方向上应用缩放因子，然后改变元素所有点到其坐标系原点到的距离。除非各个方向的缩放因子都是相同的，不然该元素的形状必定被改变。 在(-1,1)范围之内的缩放因子会缩小元素，范围之外的因子则会放大元素。一个负值的因子不仅会改变元素的大小，还会基于坐标系原点镜像处理所有的点。如果因子不等于1，那么在相应的方向上就会出现缩放的情况。 一个缩放函数的效果会依赖元素坐标系原点的位置，对于同一个元素，两个具有相同缩放因子的缩放函数，会因为不同的坐标系原点表现出不同的效果。 scale transform: HTML 元素 (左边) vs SVG 元素 (右边) 上图是分别在HTML元素和SVG元素上应用缩放的不同结果，两者拥有完全相同的缩放因子，不同的是，HTML元素的坐标系原点在元素50% 50%处，而SVG元素的坐标原点则是SVG画板的0 0处。 在CSS transform中有3种2D的缩放函数： scale(sx[, sy]) scaleX(sx) scaleX(sx) scaleY(sy)。第一个函数，会同时在x和y方向上应用sx和sy缩放因子，sy是可选的，如果该函数只有一个参数，会默认是sx的值。其它两个函数是分别在两个方向进行缩放，scaleX(sx) scaleY(sy)分别等价于scale(sx,1) scale(1,sy)，如果在此之前存在其它的变换，那么相应的x和y方向将不再是水平和垂直的。 在SVG transform中，只有scale(sx[ sy])。同样，可以使用空格或者逗号分隔参数。 对于SVG元素来说，以下的两种缩放方法是等价的： 使用CSS transform:1234rect &#123; /* doesn't work in IE */ transform: scale(2, 1.5);&#125; 使用SVG transform:12&lt;!-- works everywhere --&gt;&lt;rect x='65' y='65' width='150' height='80' transform='scale(2 1.5)' /&gt; 在同一个元素上应用上面两种方法会产生相同的效果，就像上一个图片中的右边的区域。如果我想实现像应用在HTML元素上一样的效果呢？来看一看我是如何让实现的。 我们可以使用CSS transform中的transform-origin改变元素的坐标原点，或者使用translate() scale() translate()这样的组合，在第二种方法中，我们先将元素坐标系原点移动到元素的50% 50%位置，然后应用缩放，最后做与第一个位移相反的操作。如果使用SVG transform属性，我们只能使用前面CSS transform中的第二种方式，类似的方法，下面是具体的代码。 使用CSS transform中的transform-origin：123456789rect &#123; /* doesn't work in IE */ transform: scale(2, 1.5); /* doesn't work as intended in Firefox * % values are taken relative to the SVG, not the element * which actually seems to be correct */ transform-origin: 50% 50%;&#125; 在CSS transform中链式调用：123456rect &#123; /* doesn't work in IE */ transform: translate(140px, 105px) scale(2 1.5) translate(-140px, -105px);&#125; 在SVG transform中链式调用:123&lt;rect x='65' y='65' width='150' height='80' transform='translate(140 105) scale(2 1.5) translate(-140 -105)'/&gt;&lt;!-- works everywhere --&gt; 下面的demo将会展示链式调用的工作过程（点击播放►按钮开始） See the Pen Chaining on SVG elements to scale wrt a certain point by Ana Tudor (@thebabydino) on CodePen. 还有就是，两个连续的scale()如scale(sx1, sy1) scale(sx2, sy2),可以写成scale(sx1*sx2, sy1*sy2)。scale(1/sx1, 1/sy1)可以对scale(sx1,sy1)做相反的操作。如果所有的scale()参数的绝对值等于1，那么这个元素不产生任何的缩放。 倾斜倾斜操作会将元素上所有点的坐标值在相应的方向上移动一段距离，这段距离取决于倾斜的角度而和每个点到倾斜轴的距离。也就是说，在一个方向上倾斜，另一个方向上的所有点相应的坐标值不会被改变。倾斜一个元素必定会扭曲这个元素，这点和旋转不太一样，倾斜一个矩形，这个矩形会变成不等边的平行四边形，倾斜一个圆，这个圆会变成椭圆。倾斜操作过后，角度(对于倾斜角α，矩形的直角将会变成90° ± α)或者长度都会发生变化，但是元素的原始区域会被保留。 另外，与位移，旋转不一样的是，倾斜不具有可加性，连续两次α1 α2的倾斜，不等于一次α1+α2的倾斜。 下面的demo展示了倾斜的工作方式，你可以调整倾斜轴，倾斜角度，瞧瞧它们是如何作用于初始正方形的： See the Pen How the skew transform works by Ana Tudor (@thebabydino) on CodePen. 倾斜的角度等于初始轴与终轴的夹角(非倾斜轴)，如果应用[0°, 90°]夹角的倾斜，元素上所有点倾斜轴方向上的坐标会加上与其非倾斜轴方向坐标符号相等的值，如果是[-90°, 0°]，则该值的符号相反。 如果我们应用一个在X轴方向上的倾斜，元素y轴方向的坐标保持不变，X轴方向的坐标会增加或者减少d，这个d取决于倾斜角度和该点y轴上的坐标，顶边和底边的长度不变，两侧的长度会随着倾斜角度的增加而增加，当角度为±90°时两侧将会是无限长，当角度慢慢靠近±180°的时候，两侧的长度将会逐渐减少。 注：(90°, 180°]之间的角α等同于α - 180°（落在区间(-90°, 0°]），同样，如果α在(-180°, -90°]之间，则等同于α + 180°(落在区间[0°, 90°)) 同样，如果我们应用一个在y轴方向上的倾斜，元素X轴方向的坐标保持不变，y轴方向的坐标会增加或者减少d，这个d取决于倾斜角度和该点X轴上的坐标，两侧的长度不变，上下的长度会随着倾斜角度的增加而增加，当角度为±90°时上下将会是无限长，当角度慢慢靠近±180°的时候，上下的长度将会逐渐减少。 倾斜操作与旋转操作一样，元素的坐标原点都会影响最终的呈现效果，对同一个元素在相同的轴方向上做相同倾斜操作，会产生不同的结果： skew transform: HTML元素 (左边) vs SVG元素 (右边) 以上是分别对HTML元素和SVG元素做相同的倾斜操作后的图片，相同的角度，相同的倾斜轴，不同的是，它们的坐标原点不一样。HTML元素在其50% 50%处，SVG元素在SVG画布的0 0处。 方便起见，在这我们只关注元素上的一个点：右上角。两者右上角在垂直方向上始终保持不变，在水平方向上，HTML元素中向左平移，SVG元素中向右平移，右下角都向右平移。为什么会这样？ 就像前面提到的，X轴方向的倾斜，y轴方向的坐标保持不变，X轴方向的坐标会增加或者减少d，这个d取决于倾斜角度和该点y轴上的坐标。如果倾斜角在[0°, 90°]之间，则d的符号与y坐标相同，如果在[-90°, 0°]之间，则相反。 在这个例子中，倾斜角是60°，所以在这里右上角y轴方向的坐标是导致两者不同的关键，在HTML元素中，由于坐标系原点在元素中央，所以右上角的y坐标为负值，在SVG元素中，坐标系原点在SVG画板的0 0处，所以右上角y坐标为正值。像上面所说的，这样分别加在两者右上角d的符号也是相反的，也就造成了HTML元素的右上角向左移动，SVG元素的右上角向右移动。 无论是CSS transform还是SVG transform，都有两个倾斜函数:skewX(angle)和skewY(angle)，前者的倾斜轴是X轴，后者的倾斜轴是y轴。 在CSS transform中，angle的单位可以是deg rad turn grad ,还能使用calc()(需要牢记的是，只有Blink内核的浏览器支持在calc()中计算角度) 在SVG transform中，倾斜角度都是没有单位的deg值。 也就是说有两种方法书写上一张图片中右边的效果： 使用CSS transform:123rect &#123; transform: skewX(60deg); /* doesn't work in IE */&#125; 使用SVG transform:12&lt;!-- works everywhere --&gt;&lt;rect x='65' y='65' width='150' height='80' transform='skewX(60)' /&gt; 如果我想实现像应用在HTML元素上一样的效果呢？就像旋转一样，存在3种方式： 使用CSS transform的transform-origin(不建议使用):123456789rect &#123; /* doesn't work in IE */ transform: skewX(60deg); /* doesn't work as intended in Firefox * % values are taken relative to the SVG, not the element * which actually seems to be correct */ transform-origin: 50% 50%;&#125; 在CSS transform中链式调用：123456rect &#123; /* doesn't work in IE */ transform: translate(140px, 105px) skewX(60deg) translate(-140px, -105px);&#125; 在SVG transform中链式调用:123&lt;!-- works everywhere --&gt;&lt;rect x='65' y='65' width='150' height='80' transform='translate(140 105) skewX(60) translate(-140 -105)' /&gt; 下面的demo将会展示链式调用的工作过程（点击播放►按钮开始） See the Pen Chaining on SVG elements to skew wrt a certain point by Ana Tudor (@thebabydino) on CodePen. 缩短调用链我们可以通过链式调用，在SVG元素上实现在HTML元素上进行rotate scale skew操作一样的效果，使用SVG transform也能做到兼容IE浏览器。然而，你不觉得这样的写法很丑陋么？难道就没有更加简便的方式？ 如果我们可以将元素的坐标系原点移动到元素自身的50% 50%处，那么调用链会大大缩短，像下面这样：123&lt;rect x='-75' y='-40' width='150' height='80' transform='translate(140 105) rotate(45)'/&gt;&lt;!-- 75 = 150/2, 40 = 80/2 --&gt; See the Pen Chaining on SVG elements to rotate wrt a certain point #1 by Ana Tudor (@thebabydino) on CodePen. 如果使用SVG元素的viewBox属性，第一个translate也能被精简掉。viewBox属性中有4个值，前两个指定了SVG画布的左上角在显示区域的位置，后两个则是SVG画布显示区域的width和height，如果没有明确指定viewBox，画布的位置就是在显示区域的0 0处。 下面的两张图片能很好地展现viewBox=&#39;-140 -105 280 210&#39;使用前和使用后的区别。 viewBox使用前 vs. viewBox使用后 回到刚才的话题，如果想将SVG画布的坐标原点0 0移动到矩形的中心点，我们可以像下面这样设置viewBox:123&lt;svg viewBox='-140 -105 650 350'&gt; &lt;rect x='-75' y='-40' width='150' height='80' transform='rotate(45)'/&gt;&lt;/svg&gt; See the Pen Setting proper viewBox to rotate wrt a certain point #1 by Ana Tudor (@thebabydino) on CodePen. 实际使用将SVG画布的原点移动到元素的中心点，可以大大简化SVG图形的变换操作。下面的demo展示了3个四角星(点击播放/暂停)，最初都在中央，然后各自旋转，平移，倾斜，缩放，当中并没有使用transform-origin或者链式调用： See the Pen SVG Stars - final by Ana Tudor (@thebabydino) on CodePen. 让我们看一看，这个demo是如何一步一步工作的。 非常轻松地画出四角星（其实就是一个包含8个点的多边形） See the Pen 4 point star - the points by Ana Tudor (@thebabydino) on CodePen. 有3个这样的星星，我不想连续3次重复定义这个多边形，所以使用了1个&lt;defs&gt;和3个&lt;use&gt;:1234567891011&lt;svg viewBox='-512 -512 1024 1024'&gt; &lt;defs&gt; &lt;polygon id='star' points='250,0 64,64 0,250 -64,64 -250,0 -64,-64 0,-250 64,-64'/&gt; &lt;/defs&gt; &lt;g&gt; &lt;use xlink:href='#star'/&gt; &lt;use xlink:href='#star'/&gt; &lt;use xlink:href='#star'/&gt; &lt;/g&gt;&lt;/svg&gt; 首先，星星需要从0放大到1:12345678use &#123; animation: ani 4s linear infinite;&#125;@keyframes ani &#123; 0% &#123; transform: scale(0); &#125; 25%, 100% &#123; transform: scale(1); &#125;&#125; 上面的代码实现的效果： See the Pen SVG Stars - step #1 by Ana Tudor (@thebabydino) on CodePen. 下一步就是为我们的动画增加旋转效果，同时我希望每一个星星都有不同的旋转角度，下面是代码：123456789101112131415161718$n: 3;$α: 360deg/$n;$β: random($α/1deg)*1deg;@for $i from 1 through $n &#123; $γ: $β + ($i - 1)*$α; use:nth-of-type(#&#123;$i&#125;) &#123; fill: hsl($γ, 100%, 80%); animation: ani-#&#123;$i&#125; 4s linear infinite; &#125; @keyframes ani-#&#123;$i&#125; &#123; 0% &#123; transform: scale(0); &#125; 25% &#123; transform: scale(1); &#125; 50%, 100% &#123; transform: rotate($γ); &#125; &#125;&#125; 实现的效果如下： See the Pen SVG Stars - step #2 by Ana Tudor (@thebabydino) on CodePen. 下一步，平移，旋转：12345678@keyframes ani-#&#123;$i&#125; &#123; 0% &#123; transform: scale(0); &#125; 25% &#123; transform: scale(1); &#125; 50% &#123; transform: rotate($γ); &#125; 75%, 100% &#123; transform: rotate($γ) translate(13em) scale(.2); &#125;&#125; See the Pen SVG Stars - step #3 by Ana Tudor (@thebabydino) on CodePen. 好了，我们还需要与缩放配合，添加倾斜效果：1234567891011121314151617181920@keyframes ani-#&#123;$i&#125; &#123; 0% &#123; transform: scale(0); &#125; 25% &#123; transform: scale(1); &#125; 50% &#123; transform: rotate($γ); &#125; 75% &#123; transform: rotate($γ) translate(13em) scale(.2); &#125; 83% &#123; transform: rotate($γ) translate(13em) scale(.2) skewY(30deg) scaleX(.866); &#125; 91% &#123; transform: rotate($γ) translate(13em) scale(.2) skewY(60deg) scaleX(.5); &#125; 100% &#123; transform: rotate($γ) translate(13em) scale(.2) skewY(90deg) scaleX(0); &#125;&#125; 我在原来的基础上添加一些帧。当倾斜角线性变化的时候，其缩放因子会像余弦函数一样变化，如下图一样： 三角函数 正弦 (蓝色) 余弦 (红色) 在火狐浏览器中，这个纯CSS的demo有点蛋疼，然后因为IE不支持SVG元素上的CSS transform,所以这个demo在IE上也不能运行，使其兼容IE只能使用SVG transform，然后配合javascript动态地改变那些值，下面是这个兼容版本(点击开始)： See the Pen Stars - JS version by Ana Tudor (@thebabydino) on CodePen.","categories":[{"name":"技术译文","slug":"技术译文","permalink":"http://jabbla.github.io/categories/技术译文/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://jabbla.github.io/tags/CSS/"},{"name":"SVG","slug":"SVG","permalink":"http://jabbla.github.io/tags/SVG/"}]},{"title":"HTML元素上的SVG滤镜","slug":"HTML元素上的SVG滤镜","date":"2016-08-30T03:28:00.000Z","updated":"2017-12-20T11:18:08.548Z","comments":true,"path":"2016/08/30/HTML元素上的SVG滤镜/","link":"","permalink":"http://jabbla.github.io/2016/08/30/HTML元素上的SVG滤镜/","excerpt":"上周看到有一篇关于CSS滤镜效果函数的文章，其中的效果函数相对来说比较容易理解，而且上手难度低。但是，这种方式仅仅是添加CSS滤镜效果众多方式中最弱的一种。今天让我们来看一看滤镜基元，这是为图片和元素添加滤镜效果另外一种更加强大的方法。","text":"上周看到有一篇关于CSS滤镜效果函数的文章，其中的效果函数相对来说比较容易理解，而且上手难度低。但是，这种方式仅仅是添加CSS滤镜效果众多方式中最弱的一种。今天让我们来看一看滤镜基元，这是为图片和元素添加滤镜效果另外一种更加强大的方法。相较于效果函数，滤镜基元为我们提供了更多的东西。一方面原因是滤镜基元有更多的效果。另一方面是在两者相似的地方，滤镜基元为我们提供了更多的使用方式。 滤镜基元其实比较复杂，很难在一篇文章中展现它的全貌，在这里需要说一声抱歉。 我发现官方文档的描述比较模糊，而且缺乏一些帮助我们理解的例子。我也查过一些资料，但是大多数都是在讨论SVG滤镜本身。不过，高兴的是，我可以轻松地让例子跑起来了，这个例子会在下面给出。有一点不太满意的地方是，它不是在所有的浏览器中都能运行。但是我相信，未来这些浏览器都会支持。 什么是CSS滤镜基元？滤镜基元和效果函数并没有多么不同。在许多方面，他们只是用不同方式做着同样的事情。基元最初是被作为SVG滤镜开发的，之后被扩展到不仅仅支持SVG图片。 像效果函数一样，滤镜基元是一种不需要图片编辑器就可以添加滤镜效果的一种方法。这使得它更加灵活，并且不具破坏性。它被写在SVG标记中，然后可以通过CSS filter属性的url值应用到图片或者元素上。123.filtered &#123; filter: url(path-to-filter-primitives);&#125; 滤镜基元的概念不再像以前那样复杂。它只是与效果函数的书写方式不一样，它还提供了更多的选项，然后以不同的方式将滤镜应用于目标元素。例子或许是帮你弄清它是什么及其工作方式的最佳方法。 如果您从未接触过CSS滤镜相关的内容，建议您可以点击这里进行了解 使用SVG滤镜基元hue-rotate是一个效果函数，你可以像下面这样使用它：1filter: hue-rotate(60deg); 等价的滤镜基元会是下面这样：1&lt;feColorMatrix type=\"hueRotate\" values=\"60\"/&gt; 这是一个标记，而不是CSS，它有一个新名字，你可以看到type属性有一个和效果函数的函数名相似的值，我们还需要更多的代码来让上面的基元工作，但是我想你已经知道了基元和效果函数的关联。 HTML结构很简单：123&lt;div class=\"filtered\"&gt; &lt;img src=\"images/strawberry-fields.jpg\" /&gt;&lt;/div&gt; CSS同样很简单：1filter: url(filters.svg#filter-primitives); 我使用了filter属性的url值，并且将url指向filters.svg文件。在这个文件中，我通过id名为filter-primitives调用了具体的滤镜。 到目前为止，步骤都很简单，现在我们需要定义相应的滤镜。这里是完整的filters.svg文件1234567891011121314&lt;?xml version=\"1.0\"?&gt;&lt;!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"&gt;&lt;svg xmlns=\"http://www.w3.org/2000/svg\"&gt;&lt;defs&gt; &lt;filter id=\"filter-primitives\"&gt; &lt;feGaussianBlur stdDeviation=\"3\" /&gt; &lt;feColorMatrix type=\"hueRotate\" values=\"270\"/&gt; &lt;feColorMatrix type=\"saturate\" values=\"0.75\"/&gt; &lt;feBlend mode=\"multiply\"/&gt; &lt;/filter&gt;&lt;/defs&gt;&lt;/svg&gt; 这个文件首先定义了自己是用xml语言书写的SVG文档。接下来是SVG对象。滤镜定义在defs元素中。它的id就是我们刚才在CSS中引用的那个。这里我应用了4个滤镜基元。我希望各自都可以最大化发挥各自的作用。 还有一些需要注意的事情，就是同时使用了hue-rotate和saturate，每一个都是独一无二的滤镜，但是不仅仅局限于hue 和 saturation，它还有一个luminanceToAlpha值，你也可以直接将一个矩阵赋值给它。 我知道你已经习惯使用ps或者其它图片编辑器，同样需要注意的是，这里虽然没有所有的混合滤镜，但是我们有 normal、 multiply、 screen、 darken和 lighten。 让我们来看一个例子。我会将滤镜应用在下面这张图片： HTML结构很简单：123&lt;div class=\"filtered\"&gt; &lt;img src=\"images/strawberry-fields.jpg\" /&gt;&lt;/div&gt; CSS同样很简单：1filter: url(filters.svg#filter-primitives); 我使用了filter属性的url值，并且将url指向filters.svg文件。在这个文件中，我通过id名为filter-primitives调用了具体的滤镜。 到目前为止，步骤都很简单，现在我们需要定义相应的滤镜。这里是完整的filters.svg文件1234567891011121314&lt;?xml version=\"1.0\"?&gt;&lt;!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"&gt;&lt;svg xmlns=\"http://www.w3.org/2000/svg\"&gt;&lt;defs&gt; &lt;filter id=\"filter-primitives\"&gt; &lt;feGaussianBlur stdDeviation=\"3\" /&gt; &lt;feColorMatrix type=\"hueRotate\" values=\"270\"/&gt; &lt;feColorMatrix type=\"saturate\" values=\"0.75\"/&gt; &lt;feBlend mode=\"multiply\"/&gt; &lt;/filter&gt;&lt;/defs&gt;&lt;/svg&gt; 这个文件首先定义了自己是用xml语言书写的SVG文档。接下来是SVG对象。滤镜定义在defs元素中。它的id就是我们刚才在CSS中引用的那个。这里我应用了4个滤镜基元。我希望各自都可以最大化发挥各自的作用。 还有一些需要注意的事情，就是同时使用了hue-rotate和saturate，每一个都是独一无二的滤镜，但是不仅仅局限于hue 和 saturation，它还有一个luminanceToAlpha值，你也可以直接将一个矩阵赋值给它。 我知道你已经习惯使用ps或者其它图片编辑器，同样需要注意的是，这里虽然没有所有的混合滤镜，但是我们有 normal、 multiply、 screen、 darken和 lighten。 应用上面的滤镜会得到下面这张图片： 上面的例子能完美地在Firefox运行，但是在Chrome Canary和Safari中就悲剧了。为了让上面的例子也能在这两个浏览器中正常运行，于是，我将所有的代码都写在了index.html中。1234567891011121314&lt;svg&gt; &lt;image x=\"0\" y=\"0\" width=\"800\" height=\"600\" xlink:href=\"images/strawberry-fields.jpg\" filter=\"url(#filter-primitives)\"&gt;&lt;/image&gt;&lt;/svg&gt;&lt;svg&gt; &lt;defs&gt; &lt;filter id=\"filter-primitives\"&gt; &lt;feGaussianBlur stdDeviation=\"0\" /&gt; &lt;feColorMatrix type=\"hueRotate\" values=\"270\"/&gt; &lt;feColorMatrix type=\"saturate\" values=\"0.75\"/&gt; &lt;feBlend mode=\"multiply\"/&gt; &lt;/filter&gt; &lt;/defs&gt;&lt;/svg&gt; 所有的东西都在同一个文件中，而不是通过CSS链接外部文件。滤镜没有变。图片元素由原始的HTML图片变为SVG图片。 有趣的是，这个例子在Firefox里居然是。。。。滤镜确实应用在了图片上，但是Firefox只会显示裁切过的图片，就像下面这样： 图片和div容器已经被全尺寸渲染，但是图片会被裁切成宽高为300px和150px的区域。我现在还不知道这是为什么。。 如果有人知道，可以在这里分享一下。 其它例子这里有一些我查阅资料时候碰到的其它例子。 SVG Filter Effects in IE10 Applying SVG effects to HTML content Gaussian Blur and CSS3/SVG Filters SVG-Wow 可以从每一个的标题看出来，它们可以汇总成三方面，SVG滤镜，CSS和SVG运用相同滤镜时使用上的细微差别，和不同浏览器对不同方式的支持程度。 滤镜基元清单有许多我没有在上面使用到的滤镜基元都和效果函数很相似，或者说相似到能够让我们很容易理解它们到底是做什么的。还有不少的更加复杂一些的滤镜基元，但是我已经没有机会再去研究他们了 混合和合并效果 feBlend feComposite feMerge 色彩效果 feColorMatrix feComponentTransfer feFlood (flood-color and flood-opacity) 光照和光源效果 feDiffuseLighting feSpecularLighting feDistantLight fePointLight feSpotLight 其它特殊效果 feConvolveMatrix feDisplacementMap feTurbulence feGaussianBlur feImage feMorphology feTile feOffset feDropShadow 自定义效果 feCustom 总结在这里我向可能引起的困惑道歉。由于官方文档缺少相关的例子，对我来说确实不是那么清晰，除此之外查阅到的资料都是讨论SVG滤镜的。这和我想要的确实有很密切的联系，但是不是同一件事情。 如果我们坚持这个滤镜效果规范，那么滤镜基元就是储存在单独文件中的SVG标记，使用filter: url()，他们可以应用在所有图片或者HTML文档中的其它元素。当SVG滤镜被储存在HTML中时，它只能应用在SVG元素上。 当我努力让它们工作，而且它们确实那样做的时候，很容易看到效果是有多么的强大。希望在不久的将来，我能够清除现在的所有困惑,然后对它们有更加深刻的理解。","categories":[{"name":"技术译文","slug":"技术译文","permalink":"http://jabbla.github.io/categories/技术译文/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://jabbla.github.io/tags/CSS/"},{"name":"SVG","slug":"SVG","permalink":"http://jabbla.github.io/tags/SVG/"}]},{"title":"解决Sass媒体查询的重复问题，优化工作流程","slug":"解决Sass媒体查询的重复问题，优化工作流程","date":"2016-08-24T00:27:00.000Z","updated":"2017-12-20T11:18:46.121Z","comments":true,"path":"2016/08/24/解决Sass媒体查询的重复问题，优化工作流程/","link":"","permalink":"http://jabbla.github.io/2016/08/24/解决Sass媒体查询的重复问题，优化工作流程/","excerpt":"解决Sass媒体查询的重复问题，优化工作流程(第3弹)W3CPlus:http://www.w3cplus.com/preprocessor/the-solution-to-media-queries-in-sass.html","text":"解决Sass媒体查询的重复问题，优化工作流程(第3弹)W3CPlus:http://www.w3cplus.com/preprocessor/the-solution-to-media-queries-in-sass.html在Sass中有很多方法可以解决媒体查询这个问题，但是其中一些方法存在相同的问题。一开始我会还原这个问题，然后提供我的解决方案，最后列出这个方案对工作流程的好处。 问题假如我们把网站的Sass样式分离成多个像header.scss,hero.scss,cards.scss等等这样的组件。为他们添加各自的响应式样式最简洁的做法是，在各自的组件文件中添加相应的响应式样式。为了实现这样的效果，最简单的做法就是，定义一系列针对不同尺寸屏幕的mixin然后使用@content。12345678910@mixin tablet &#123; @media (min-width: 768px) and (max-width: 1024px) &#123; @content; &#125;&#125; @mixin desktop &#123; @media (min-width: 1024px) &#123; @content; &#125;&#125; 这些mixin会将外部传进来的样式片段，放置在@content出现的地方。就像这样使用：123456789p &#123; font-size: 16px; @include tablet &#123; font-size: 18px; &#125; @include desktop &#123; font-size: 20px; &#125;&#125; 这样很好，很整齐。它告诉我们，一个p元素里对两个不同的设备有不同的响应式设计。但是这样带来的问题是，在编译后CSS文件中，每个mixin中的媒体查询会重复地出现，就像这样:12345678910111213p &#123; font-style: 18px;&#125;@media (min-width: 768px) and (max-width: 1023px) &#123; p &#123; font-style: 20px; &#125;&#125; @media (min­width: 1024px) &#123; p &#123; font-style: 25px; &#125;&#125; 上面是https://davidwalsh.name/write-media-queries-sass的例子，只是为了举例说明这个问题。 这个例子仅仅涵盖了一个p标签，当存在很多需要响应式设计的元素的时候，这里将存在大量的重复。 对于小型网站，这样简单地将媒体查询mixin放在元素中可能并没有什么不妥，但是如果是大型网站，这样做会使CSS文件很快臃肿起来。如果Sass团队能解决这个问题，那再好不过了，但是我确定，这对编译速度来说是个很大的挑战。 简单的3步实现的解决方案在这个解决方案中，你可以将响应式样式放在每个组件中相应位置，并且没有重复的媒体查询，一切看起来都很完美，整齐，且易于维护。 步骤 1. 创建一个 media-queries.scss 文件为了避免重复的媒体查询，并且让代码看起来更整齐，我们在一个单独的Sass文件中定义媒体查询，然后调用这个文件。media-queries.scss (or .sass):1234567// small screen size (sm)@media (min-width: 801px) &#123;&#125;// medium screen size (md)@media (min-width: 992px) &#123;&#125; 为了看起来简单一点，在这里仅仅为小尺寸和中等尺寸屏幕定义了两个主要的断点。 步骤 2. 为每个元素创建一个响应式mixin就拿banner.scss来说，利用移动优先原则，在文件的底部定义一系列响应式mixin。这些mixin将会在media-queries.scss中相应的断点处调用。 确保为mixin添加一个能反映出相应断点的后缀，像前面的例子中的，small(sm)，medium(md)。比如说，如果一段样式处于小尺寸屏幕的断点，这个mixin名字就可以取为，元素的名称+sm后缀。 在mixin中为你准备适配的屏幕尺寸添加所有相应的样式。如：12345678910111213141516.banner &#123; text-align: center; font-size: 14px;&#125;// called in media-queries.scss@mixin banner--sm() &#123; .banner &#123; font-size: 20px; &#125;&#125;@mixin banner--md() &#123; .banner &#123; text-align: left; font-size: 25px; &#125;&#125; 步骤 3. 在media-queries.scss中调用这些mixin回到media-queries.scss文件，我们可以在指定的媒体查询中，调用相应的mixin。123456789// small screen size (sm)@media (min-width: 801px) &#123; @include banner--sm();&#125;// medium screen size (md)@media (min-width: 992px) &#123; @include banner--md()&#125; 好了，现在所有的响应式样式片段都定义在相应在的组件文件当中，然后被调用在媒体查询中相应断点处。整个编译后的css文件中没有重复的，冗余的媒体查询语句。 media-queries.scss输出的CSS文件123456789101112@media (min-width: 801px) &#123; .banner &#123; font-size: 20px; &#125;&#125;@media (min-width: 992px) &#123; .banner &#123; text-align: left; font-size: 25px; &#125;&#125; 最后，在每个断点处会调用很多个mixin，这样编译后的css文件就不会变得臃肿，同时你也很清楚所有的响应式样式片段在什么地方：1234567891011@media (min-width: 801px) &#123; @include home-cta--sm(); @include twitter-testimonials--sm(); @include site-footer--sm(); @include feature-section--sm(); @include feature-item--sm(); @include post-meta--sm(); @include social-share--sm(); @include hero--sm(); @include feature-page--sm();&#125; 优点在压缩文件体积方面，效果并不是很明显，但是对我来说，能减则减。另外一方面，重复的媒体查询并不会太大地影响性能。 优点主要还是体现在优化工作流程方面。 团队易读性 和 标准实践回到最初嵌套的媒体查询方法，我也喜欢这个方法，但是如果在一个非常庞大的组件文件中的不同层级使用这种嵌套，会使代码非常不整齐。当然，也可以结合BEM，使得嵌套的层数不超过2层。这种搭配BEM的解决方案其实还不错。 尽管如此，你和你的同事还是要上下滚动来查找哪些元素存在响应式设计。因为你必须弄清那些存在响应式设计的元素，这样，组件文件又不应该过长。使用我的解决方案，你和你的团队会很清楚在任意一个文件中元素媒体查询语句的位置。而且你可以在媒体查询区域寻找元素，如果没有，那么这个元素不会对任何的断点作出响应。 组件文件布局： 也可以在media-queries.scss文件中，查找那些存在响应式设计的元素。我们已经在一个组件数量超过30个的网站运用了这种方法，它的可伸缩性很好。 可以很好地利用移动优先原则最后，如果使用了移动优先原则，在组件文件中你将会从上到下依次看到小屏幕到大屏幕对应的样式。这样就会减少对不同屏幕尺寸所在位置的额外关注。 使用移动优先原则，从上到下将会看到屏幕尺寸的依次递增: 一些缺点这个方案也有一些缺点。比如，当我们删除了一个元素，就必须回到media.scss文件中删除相应的调用，不然就会抛出一个编译错误，不过也有一点好处是，你不用太过注意它，反正都会抛出错误提醒你。还有就是，可能会忘记在media-queries.scss添加mixin。 重构的时候也会比嵌套的媒体查询更麻烦。 在实际开发当中，特别是在回顾的时候，拥有一个结构良好的，有组织的媒体查询方法可以简化工作并且让我们更迅速地debug。 感谢您的阅读","categories":[{"name":"技术译文","slug":"技术译文","permalink":"http://jabbla.github.io/categories/技术译文/"}],"tags":[{"name":"Sass","slug":"Sass","permalink":"http://jabbla.github.io/tags/Sass/"},{"name":"css","slug":"css","permalink":"http://jabbla.github.io/tags/css/"}]},{"title":"Sass：@mixin和@extend该如何选择","slug":"Sass：-mixin和-extend该如何选择","date":"2016-08-21T13:30:00.000Z","updated":"2016-08-21T13:44:07.769Z","comments":true,"path":"2016/08/21/Sass：-mixin和-extend该如何选择/","link":"","permalink":"http://jabbla.github.io/2016/08/21/Sass：-mixin和-extend该如何选择/","excerpt":"Sass译文第二弹W3CPlus:http://www.w3cplus.com/preprocessor/sass-mixin-or-extend.html","text":"Sass译文第二弹W3CPlus:http://www.w3cplus.com/preprocessor/sass-mixin-or-extend.html Sass：@mixin？@extend？该如何选择Mixins允许我们在项目中复用样式片段，可以传递参数这个特性使得它们非常灵活，强大。同样，我们也可以使用@extend命令让一个选择器继承其它选择器去复用样式片段。有的时候Mixin和extend好像做了同样的事情，那我们应该选择哪一个呢？ 这个问题我会在本文的最后给出答案。在这之前，我先谈一谈关于@mixin指令的一些事情。 除了传递参数，我想让你知道如何给一个mixin传递CSS片段，了解这个片段的作用域。然后我会回到刚才的问题，将@extend和@mixin进行对比，帮助你了解他们的使用场景。 向Mixin传递样式片段除了传递参数，也可以直接传递一个样式片段给Mixin。在Mixin中，添加@content;语句，然后传递的样式片段就会代替@content;出现在相应的位置。 12345678910111213@mixin button &#123; font-size: 1em; padding: 0.5em 1.0em; text-decoration: none; color: #fff; @content; &#125;.button-green &#123; @include button &#123; background: green &#125;&#125; .button-green中调用了Mixin。@include指令传递了一个将背景色设置为绿色的CSS片段，然后这个片段就会代替@content语句出现在mixin中相应的位置 The Sass compiles to:这段Sass被编译成：1234567.button-green &#123; font-size: 1em; padding: 0.5em 1.0em; text-decoration: none; color: #fff; background: green; &#125; 如果是设置成这样，也可以只放一个@content语句在mixin中，然后使用@include传递包括选择器在内的所有东西。12345678910111213@mixin button &#123; @content; &#125;@include button &#123; .background-green &#123; font-size: 1em; padding: 0.5em 1.0em; text-decoration: none; color: #fff; background: green; &#125;&#125;; 这段Sass编译出来的结果跟刚才一样 当然也可以像最开始那样，把一些样式片段放在mixin中，然后使用@include传递另外的样式。但是要时刻警惕，这些样式都需要一个选择器，下面的例子就是一个反面教材，它是不会工作的。1234567891011@mixin button &#123; font-size: 1em; padding: 0.5em 1.0em; text-decoration: none; color: #fff; @content; &#125;@include button &#123; background: green; &#125;; 这段代码，编译过程中会抛出错误，因为没有一个选择器去应用这些样式。 你可能想知道，何时使用@content而不是仅仅传递一个参数值。下面是Christian Reuter提供的一些使用场景。 嵌套（内联）的媒体查询 keyframes 上下文差异化 结合@at-root书写BEM 变量作用域 和 内容片段当一个内容片段传进mixin的时候，它的作用域是在定义它的地方，而不是在mixin里面。也就是说，传进去的内容片段不能使用在mixin中定义的变量。 1234567891011$color: green;@mixin button($color: #fff) &#123; color: $color; @content; border: 1px solid $color; &#125;.button-green &#123; @include button &#123;background: $color;&#125; &#125; 在这个例子中，在最外层和mixin的参数中都有定义变量$color。这两个变量分别有不同的色值。 在mixin中，$color变量的值是#fff。在传递给.button-green的内容片段中，$color将会使用在最外层定义的green值 所以，上面的Sass会被编译成下面这段CSS 12345.button-green &#123; color: #fff; background: green; border: 1px solid #fff; &#125; 用@include传递进的内容片段将会使用最外层变量的green值，然后代替@content出现在mixin，mixin中的其它地方，字体颜色，边框颜色都使用mixin中定义的#fff值 应该使用 @mixin 还是 @extend@mixin和@extend都能帮助你模块化代码，然后更加方便地在样式表中复用一些样式片段。 你可能会问，到底什么时候使用@mixin，什么时候使用@extend? 不急，我们先看看一些代码编译出来是什么样的。1234567891011.button &#123; background: green; &#125;.button-1 &#123; @extend .button; &#125;.button-2 &#123; @extend .button; &#125; Using @extend produces DRY CSS. 使用@extend产生 DRY CSS风格的代码。 123.button, .button-1, .button-2 &#123; background: green; &#125; 注意，样式片段没有重复，这就是DRY。但是@mixin就不能产生DRY式的代码。 1234567891011@mixin button &#123; background-color: green; &#125;.button-1 &#123; @include button; &#125; .button-2 &#123; @include button; &#125; 这段使用@mixin的Sass编译出来的样子： 1234567891011.button &#123; background-color: green; &#125;.button-1 &#123; background-color: green; &#125;.button-2 &#123; background-color: green; &#125; 可以看到，相同的样式片段在不同的选择器中重复多次，这也导致了编译出来的CSS不是DRY形式的。 这可能会暗示你应该一直使用@extend，但是@extend也有一些缺点。@extend会增加选择器之间的联系，然后把他们堆在一起。 被继承的选择器和继承别人的选择器可能会在样式表的不同位置，这就导致维护困难，放置顺序，或者需要差异化的一些问题 @extend命令不够灵活。不能向它传递参数，它原本是啥样就是啥样。这里还有一些在@media中使用@extend的限制，比如，不能横跨多个@media指令使用@extend。 还有一个重要的问题就是@extend增加了选择器之间的联系。当你正在为一些相关的元素设置样式，就拿一组按钮来说，使用@extend让他们共享样式看起来合情合理。但是如果这些被复用的样式片段并不仅仅局限于相关的元素，那么使用@mixin或许更好。 @mixin主要的优势就是它能够接受参数。如果想传递参数，你会很自然地选择@mixin而不是@extend。 如果没有任何参数，使用@extend来创造DRY应该是个不错的选择。不过要注意的是，使用gzip压缩过的文件可能会破坏代码中的DRY。 当文件很小的时候，编译完成代码中有重复的片段并不是一件坏事。不过如果源文件中存在这样的重复片段，会使得代码很难维护。使用@mixin会减少编译后文件中DRY式的代码。但是，如果gzip的算法对重复片段的优化工作做得比较好，那么编译后的代码不会变得肿胀。 @mixin会更强大，更灵活，它与gzip的组合跟@extend的主要优势相比，一点都不会逊色。 结束语除了给一个@mixin传递参数之外，还能直接传递样式片段。你可能不会经常这么做，但是在一些使用场景中这么做更有意义 在大作数情况下@mixin会比@extend更好，但是它们俩都有自己的一席之地。当样式和选择器之间的关系在某些方面比较紧密的时候，使用@extend。除此之外，你可以使用@mixin在任何地方。 原文链接: http://vanseodesign.com/css/sass-mixin-or-extend/","categories":[{"name":"译文","slug":"译文","permalink":"http://jabbla.github.io/categories/译文/"}],"tags":[{"name":"Sass","slug":"Sass","permalink":"http://jabbla.github.io/tags/Sass/"}]},{"title":"为什么你要开始学习Sass","slug":"为什么你要开始学习Sass","date":"2016-08-19T07:10:00.000Z","updated":"2017-12-20T11:19:08.564Z","comments":true,"path":"2016/08/19/为什么你要开始学习Sass/","link":"","permalink":"http://jabbla.github.io/2016/08/19/为什么你要开始学习Sass/","excerpt":"自己的第一篇译文，希望能帮助到需要的童鞋w3cplus: http://www.w3cplus.com/preprocessor/why-should-you-start-learning-sass.html","text":"自己的第一篇译文，希望能帮助到需要的童鞋w3cplus: http://www.w3cplus.com/preprocessor/why-should-you-start-learning-sass.html 为什么你要开始学习Sass本文不会像一些其它文章一样，教你如何开始使用Sass，我会告诉你为什么使用Sass，我到底喜欢它什么。 我最初是在一个Laravel项目中，结识了Sass，Larvel是个PHP框架，内建有Elixir服务支持Sass。你可能觉得说这个玩意跟我们没啥关系，但是重点是Larvel支持Sass,使Sass非常容易上手，这就促使我去尝试使用Sass,慢慢了解到它的很多优点。 之前，我总觉得，写脚本在css里会把本应简单的事情变复杂，然后不确定是否应该花时间去学习它。但是我慢慢发现，它的用处巨大，还好当初没有放弃。 Sass 就是 CSS首先，你要知道的是，Sass其实就是CSS，这里可能会有很多的议论，但是如果你并不想使用Sass的诸多特性，你也可以只在Sass的样式表中书写CSS，这一点问题都没有，然后当你需要一些Sass特性的时候，你可以拿起来写。 Import(引入)回到当初的Larvel项目，一开始我用传统的方式书写CSS文件，最后发现文件内容非常的长。当时觉得，这没有什么问题，但是过了一段时间之后，发现在这个CSS文件里我很难回想起各个规则的位置。ok,Sass来了，它允许你创建多个文件，然后在一个文件中引入。也就是说你可以把长长的CSS文件，分割成几个以各自逻辑命名，组织的文件。这样，以后我们要完善更改样式表就变得更容易了。 对我来说，在一个项目中，经常会为网格，颜色，基础的布局创建文件，等等。当然，你也可以引入很多个需要的文件，只要你愿意。 Variables(变量)如果你习惯编程，你应该对变量不陌生。你可以定义一个变量，赋值，然后就能复用它。这是一个非常有用的特性，因为在书写CSS的颜色属性时候，你不需要再去重复写多个一样的hex，rgb值，你可以把它写在一个变量里。 这样做的好处就是，当你的客户想把红色设置稍微粉一点，你只需在变量定义的地方修改颜色的值。另外一个好处就是，相比hex值，变量名更好记，这就减少了前后不一致的错误。 Nesting(嵌套)你如果做响应式设计，我猜你会在CSS中的一些地方用到媒体查询。我曾经很发愁，媒体查询到底应该在CSS文件中的什么位置，最后我选择放在样式表的最底部，为不同的屏幕宽度，单独拿出一块区域。这么做的问题是，这些样式规则和原始的规则是分离的，维护起来会比较困难。 Sass的嵌套特性允许你可以通过在class中放置媒体查询来为这个class书写媒体查询。 这就表明，你可以在把一个class的所有规则，包括媒体查询放在一个地方，这样阅读和维护都会变得更加容易，你就不用反复地上下查看这个文件了。 像媒体查询一样，你也可以在使用&amp;添加如hover,active这样的状态规则。 Extend（继承）Sass有很多其它很酷的东西，但是我只在这里多说一个。当你存在两个class，它们有一些不同，但是也存在很多相似的地方，你可能会把所有样式重复声明两次,但是更好的做法是创建一个基础的class，然后在第二个class中使用extend继承。也就是说它继承了第一class的样式，同时可以添加额外的样式，或者对某些样式进行重写。 这点其实非常有用，比如说一些具有标准样式的按钮，同时存在不同颜色的差别，你可以声明一个具有标准样式的class，在按钮中继承这个class，然后设置不同的背景色。 在这篇文章当中，我觉得已经有足够多使用Sass的原因了。最后，非常希望可以帮助你发现Sass能带给你的便利。 原文链接：https://medium.com/@chrisrhymes/why-should-you-start-learning-sass-e3d83f2553c2#.4k65q0gwp","categories":[{"name":"技术译文","slug":"技术译文","permalink":"http://jabbla.github.io/categories/技术译文/"}],"tags":[{"name":"Sass","slug":"Sass","permalink":"http://jabbla.github.io/tags/Sass/"},{"name":"css","slug":"css","permalink":"http://jabbla.github.io/tags/css/"}]},{"title":"Sudoku数据处理流程","slug":"Sudoku数据处理流程","date":"2016-08-18T12:32:00.000Z","updated":"2017-12-20T11:20:02.455Z","comments":true,"path":"2016/08/18/Sudoku数据处理流程/","link":"","permalink":"http://jabbla.github.io/2016/08/18/Sudoku数据处理流程/","excerpt":"Sudoku这个项目陆陆续续地写了有2个星期了,断断续续地，今天终于做完最后一个模块，该放一放了，现在理一下项目的数据和数据处理流程，之后再填功能思路会更清晰一点","text":"Sudoku这个项目陆陆续续地写了有2个星期了,断断续续地，今天终于做完最后一个模块，该放一放了，现在理一下项目的数据和数据处理流程，之后再填功能思路会更清晰一点 后端数据数据库A. UserModel,用户模型 1234567891011121314151617181920212223242526272829userName: String, //用户名password: String, //密码email: String, //邮箱gameInfo: &#123; //用户的游戏记录 level4:&#123; min: Number, //最短时间 avg: Number, //平均时间 &#125;, level3:&#123; min: Number, avg: Number, &#125;, level2:&#123; min: Number, avg: Number, &#125;, level1:&#123; min: Number, avg: Number, &#125;,&#125;current: &#123; //用户所处当前关卡信息 mission: String, //所在关卡 time: Number, //已用时间 board: &#123; //棋盘数据 'row+col': 0 &#125;,&#125; B. LevelModel,等级模型123456level: Number //等级boards: [board,board] //数量不固定//BoardsubLevel: Number //子关卡board: String //棋盘数据字符串 排行榜数据rank.json123level:[&#123;userName:'username',level:'修罗'&#125;],cap:[&#123;userName:'username',cap:800&#125;],real:[&#123;userName:'username',real:800&#125;], 后端数据其实就是1231.UserCollection //用户集合2.LevelCollection //关卡集合3.rank.json //定时生成的排行榜 前端数据保存在cookies的数据C123456userName //用户名password //密码email //邮箱gameInfo //游戏信息current //当前关卡信息rankInfo //排行榜信息 经处理后的数据D123456789101112131415161718192021222324userName //用户名level //等级cap //能力值real //水平值num //小关卡层数levelNum //大关卡层数detail:&#123; //游戏信息 First:&#123; min:'...分...秒', avg:'...分...秒', &#125;, Sec:&#123;...&#125;, Thir:&#123;...&#125;, Forth:&#123;...&#125;,&#125;current //当前关卡名称boardInfo:&#123; mission //当前关卡名称 time //已用时间 board:&#123; //已填位置 'row+col':0 &#125; &#125; 开始游戏发送数据E123userName //用户名level //所在大关卡subLevel //所在小关卡 更新游戏信息发送数据F1234userName //用户名time //所用时间complete //是否完成board //当前用户已填位置 开始游戏接收数据G12board //原始棋盘信息boardInfo //用户已填位置 数据处理流程/signin1FE--(userName,password)--&gt;BE--C--&gt;FE--&gt;D /signup1FE--(userName,password,email)--&gt;BE--C--&gt;FE--&gt;D /admin1FE--(level,board)--&gt;BE /user/findInfo1FE--E--&gt;BE--G--&gt;FE /user/update1FE--F--&gt;BE--(404/200)--&gt;FE 欢迎访问Sudoku(数独游戏)，多提提意见啦,有什么好的想法也可以QQ我 持续更新","categories":[{"name":"技术原创","slug":"技术原创","permalink":"http://jabbla.github.io/categories/技术原创/"}],"tags":[{"name":"node.js","slug":"node-js","permalink":"http://jabbla.github.io/tags/node-js/"},{"name":"全栈","slug":"全栈","permalink":"http://jabbla.github.io/tags/全栈/"}]},{"title":" Canvas 知识体系简单总结","slug":"Canvas-知识体系简单总结","date":"2016-08-04T07:09:00.000Z","updated":"2017-12-20T11:20:44.776Z","comments":true,"path":"2016/08/04/Canvas-知识体系简单总结/","link":"","permalink":"http://jabbla.github.io/2016/08/04/Canvas-知识体系简单总结/","excerpt":"知识点零零散散，一个上午整理了一下，内容不多,方便记忆。本文不是教程，如需教程移步 MDN Canvas教程本文原创，如需转载，请注明出处","text":"知识点零零散散，一个上午整理了一下，内容不多,方便记忆。本文不是教程，如需教程移步 MDN Canvas教程本文原创，如需转载，请注明出处 Canvas 能干什么个人把它分为以下几点1234一个画板，能绘制复杂的图形，并应用各种样式。能在画板中放置图片，并可操作图片的尺寸和每个像素。鼠标事件能够访问到画板中的相应区域。能把画板中的图画，转换为DataURL的形式。 体系概览 把Canvas想象成一个画板123456一个绘制状态，可类比画图工具中的工具栏绘图元素，包括简单的图形，线条，复杂的组合，和图片绘制模式，比如画板中的图形存在绘制的先后顺序，而存在重叠部分，该如何显示存在重叠的图形，这是绘制模式要解决的问题裁切路径，只让画板的部分可见像素操作，操作ImageData的像素，画板的一部分区域访问，鼠标事件能够获取到所在的区域 绘制元素 需要说明的是image的类型1234HTMLImageElementHTMLVideoElementHTMLCanvasElementImageBitmap 绘制状态 需说明的是，一个canvas只有一组绘制状态 区域访问12addHitRegion(&#123;id:&apos;abc&apos;&#125;)鼠标事件能够获取到所在的区域 绘制模式12globalCompositeOperation比如画板中的图形存在绘制的先后顺序，而存在重叠部分，该如何显示存在重叠的图形，这是绘制模式要解决的问题 裁剪路径12clip()只让画板的部分可见 像素操作","categories":[{"name":"技术原创","slug":"技术原创","permalink":"http://jabbla.github.io/categories/技术原创/"}],"tags":[{"name":"canvas","slug":"canvas","permalink":"http://jabbla.github.io/tags/canvas/"},{"name":"html","slug":"html","permalink":"http://jabbla.github.io/tags/html/"},{"name":"javascript","slug":"javascript","permalink":"http://jabbla.github.io/tags/javascript/"}]},{"title":"Promise思考及强化实现","slug":"思考及强化实现","date":"2016-08-01T14:40:00.000Z","updated":"2017-12-20T11:21:17.971Z","comments":true,"path":"2016/08/01/思考及强化实现/","link":"","permalink":"http://jabbla.github.io/2016/08/01/思考及强化实现/","excerpt":"做了Sudoku项目后，很头疼的问题就是代码维护，很大一部分原因是回调嵌套太多，影响代码的可读性,增加了维护难度,尤其是后端的数据库操作，用nodeJs通常会写许多回调嵌套。这次终于打算揭竿起义。","text":"做了Sudoku项目后，很头疼的问题就是代码维护，很大一部分原因是回调嵌套太多，影响代码的可读性,增加了维护难度,尤其是后端的数据库操作，用nodeJs通常会写许多回调嵌套。这次终于打算揭竿起义。 本文原创，如需转载请注明出处 我需要什么做了Sudoku项目后，很头疼的问题就是代码维护，很大一部分原因是回调嵌套太多，影响代码的可读性,增加了维护难度,尤其是后端的数据库操作，用nodeJs通常会写许多回调嵌套。这次终于打算揭竿起义。 第二次修改,废话不多说，直接进入正题先看下面这段代码12345678910111213function do()&#123; //查找数据库 setTimeout(()=&gt;&#123; console.log('收到数据'); //修改字段，并保存 setTimeout(()=&gt;&#123; console.log('保存成功') //发送响应给前端 &#125;,1000) setTimeout &#125;,1000)&#125;do() 模拟了非常简单的一个从前端接受请求到发送响应回到前端的过程，这个代码是非常简单的，不过看起来并不是，而且一旦需求更复杂，这样风格的代码肯定会让我非常头疼 我需要的代码风格 每个异步过程独立成块，不再是嵌套风格 异步返回结果的处理过程独立于异步过程 可伸缩，直接扩展异步结果处理过程,并不与之前的混在一起,实现细分，独立成块 每个异步过程存在依赖 好吧，发现promise满足我的所有需求，拿来现成用？这一点都不好玩，所以研究了一下promise的用法，下面是我简易的需求说明 需求说明（参考ES6的实现效果） 每个promise实例 resolve动作 reject动作 promise实例 then方法注册resolve回调，reject回调 A实例执行完回调，then()会返回一个B实例 B实例跟A一样，同样有 resolve动作 reject动作 调用B的then()方法同样会注册resolve回调，reject回调 影响B动作的因素有4个(下面详细讲解) 有catch同then一样，但是只能注册一个错误回调 a实例如过程上依赖于另外一个b实例,则可被当做其resolve参数传递，并且b实例成功好事滚粗依赖于 a 的状态 一旦实例状态发生改变,状态不会再改变 ##影响B实例的因素 1.A的resolve回调和reject回调是否有异常抛出是：B执行reject动作 否：B执行resolve动作 2.A的reject动作是否有回调是：回到1. 、 否：B执行reject动作 3.A的resolve动作是否有回调是：回到1 否： B执行resolve动作 4.A的回调中return 另一个promise实例CC resolve: B resolve C reject: B reject 具体实现Promise实例所有的属性12345678910111213141516171819class Promise&#123; //构造函数 fn为构建实例的异步过程 constructor(fn)&#123; //必须为函数类型 if(typeof fn !== 'function') throw new Error('not a function'); this.success = []; this.sucArg = null; this.fail = []; this.failArg = null; this.state = 0; this.parent = null; //fork promise分支 this.fork = []; //传递的error setTimeout(()=&gt;&#123; fn(myPromise.resolve.bind(this),myPromise.reject.bind(this)) &#125;,0); &#125;&#125; Promise实例的方法，then(),catch()123456789101112131415161718192021222324 //onFulfilled成功处理函数，onRejected滚粗处理函数 then(onFulfilled,onRejected)&#123; /*参数格式限制*/let fork = new myPromise(()=&gt;&#123;&#125;);if(typeof onFulfilled ==='function')&#123; this.success.push(onFulfilled); fork.forkSuc = onFulfilled;&#125;if(typeof onRejected ==='function')&#123; this.fail.push(onRejected); fork.forkRej = onRejected;&#125; this.fork.push(fork);return fork; &#125; catch(onRejected)&#123; //参数必须函数let fork = new myPromise(()=&gt;&#123;&#125;);if(typeof onRejected !=='function') return this;this.fail.push(onRejected);fork.forkRej = onRejected; this.fork.push(fork);return fork; &#125; Promise静态方法resolve,reject123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596 static resolve(value)&#123; if(this.state!==0) return;//参数不是myPromise实例if(value instanceof myPromise)&#123; //如参数是一个promise实例 value.parent = this; if(value.state===1)&#123; //实例状态为成功 myPromise.resolve.call(this,value.successArg); &#125;else if(value.state===-1)&#123; //实例状态为失败 myPromise.reject.call(this,value.failArg); &#125;&#125;else&#123; if(!this.success.length)&#123; for(let fn of this.fork)&#123; myPromise.resolve.call(fn,value); &#125; &#125;else&#123; this.sucArg = value; let cur = 0; for(let fn of this.success)&#123; if(this.fork.length&amp;&amp;fn===this.fork[cur].forkSuc)&#123; let error,preArg,bool; try&#123; preArg = fn(value); if(preArg instanceof myPromise)&#123; let index = cur; bool = true; preArg.success.push(()=&gt;&#123; myPromise.resolve.call(this.fork[index],preArg.sucArg); &#125;); preArg.fail.push(()=&gt;&#123; myPromise.reject.call(this.fork[index],preArg.failArg); &#125;) &#125; &#125;catch(err)&#123; error = err||null; &#125; if(!bool)&#123; error? myPromise.reject.call(this.fork[cur],error): myPromise.resolve.call(this.fork[cur],preArg); &#125; cur++; &#125;else&#123; fn(value); &#125; &#125; &#125; //当前promise变为fulfilled this.state = 1; //如存在parent,则parent.resolve(value) if(this.parent) myPromise.resolve.call(this.parent,value);&#125; &#125; static reject(value)&#123; if(this.state!==0) return;//参数是myPromise实例if(value instanceof myPromise)&#123; value.parent = this; myPromise.reject.call(this);&#125;else&#123; if(!this.fail.length)&#123; for(let fn of this.fork)&#123; myPromise.reject.call(fn,value) &#125; &#125;else&#123; this.failArg = value; let cur = 0; for(let fn of this.fail)&#123; if(this.fork.length&amp;&amp;fn===this.fork[cur].forkRej)&#123; let error,preArg,bool; try&#123; preArg = fn(value); if(preArg instanceof myPromise)&#123; let index = cur; bool = true; preArg.success.push(()=&gt;&#123; myPromise.resolve.call(this.fork[index],preArg.sucArg); &#125;); preArg.fail.push(()=&gt;&#123; myPromise.reject.call(this.fork[index],preArg.failArg); &#125;) &#125; &#125;catch(err)&#123; error = err||null; &#125; if(!bool)&#123; error? myPromise.reject.call(this.fork[cur],error): myPromise.resolve.call(this.fork[cur],preArg); &#125; cur++; &#125;else&#123; fn(value); &#125; &#125; &#125; this.state = -1; if(this.parent) myPromise.reject.call(this.parent,value);&#125; &#125; 好了，就这么多，这是个简易的Promise实现，如有错误，或者什么建议QQ:387857274欢迎讨论","categories":[{"name":"技术原创","slug":"技术原创","permalink":"http://jabbla.github.io/categories/技术原创/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://jabbla.github.io/tags/javascript/"},{"name":"promise","slug":"promise","permalink":"http://jabbla.github.io/tags/promise/"}]},{"title":"Sublime效率开发实践","slug":"Sublime效率开发实践","date":"2016-05-14T08:21:00.000Z","updated":"2017-12-20T11:22:07.514Z","comments":true,"path":"2016/05/14/Sublime效率开发实践/","link":"","permalink":"http://jabbla.github.io/2016/05/14/Sublime效率开发实践/","excerpt":"如何让写代码更有快感呢，那就是多使用快捷键，练习传说中的微操会持续更新·····","text":"如何让写代码更有快感呢，那就是多使用快捷键，练习传说中的微操会持续更新····· 快捷键只列了自己不熟悉的功能，Preferences–&gt;key binding中有全面的 1234567891011121314151617181920ctr+shift+o 新建窗口ctr+o 提示打开文件ctr+n 新建文件ctr+s 保存文件ctr+shift+s 另存为ctr+F4 关闭文件ctr+w 关闭标签ctr+k+b (喜欢ctr按住)侧边栏隐藏/显示F11 全屏模式shift+F11 加强版全屏模式ctr+shift+z 恢复修改ctr+k+v (喜欢ctr按住)选择复制Home 去到一行的开头End 去到一行的结尾ctr+Home 去到文件的开头ctr+End 去到文件的结尾ctr+pageup 上一个标签ctr+pagedown下一个标签 快速生成代码片段在package Control中寻找相应的Snippets进行安装 Bootstrap3 Snippets Balbel Snippets 安装Emmet插件 写Html结构的利器(太酷了,强烈推荐) Emmet官网","categories":[{"name":"杂记","slug":"杂记","permalink":"http://jabbla.github.io/categories/杂记/"}],"tags":[{"name":"效率工具","slug":"效率工具","permalink":"http://jabbla.github.io/tags/效率工具/"}]},{"title":"Hexo常用指令","slug":"Hexo常用指令","date":"2016-05-10T07:24:00.000Z","updated":"2017-12-20T11:22:44.831Z","comments":true,"path":"2016/05/10/Hexo常用指令/","link":"","permalink":"http://jabbla.github.io/2016/05/10/Hexo常用指令/","excerpt":"Hexo常用指令大部分都是从官网复制粘贴，会持续更新此后会写一篇，修改Hexo主题的教程，或者Hexo工作流程剖析","text":"Hexo常用指令大部分都是从官网复制粘贴，会持续更新此后会写一篇，修改Hexo主题的教程，或者Hexo工作流程剖析 Hexo的目录结构:12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes 1234567891011121314151617181920package.json&#123; \"name\": \"hexo-site\", \"version\": \"0.0.0\", \"private\": true, \"hexo\": &#123; \"version\": \"\" &#125;, \"dependencies\": &#123; \"hexo\": \"^3.0.0\", \"hexo-generator-archive\": \"^0.1.0\", \"hexo-generator-category\": \"^0.1.0\", \"hexo-generator-index\": \"^0.1.0\", \"hexo-generator-tag\": \"^0.1.0\", \"hexo-renderer-ejs\": \"^0.1.0\", \"hexo-renderer-stylus\": \"^0.2.0\", \"hexo-renderer-marked\": \"^0.2.4\", \"hexo-server\": \"^0.1.2\" &#125;&#125; scaffoldsScaffold folder. When you create a new post, Hexo bases the new file on the scaffold. sourceSource folder. This is where you put your site’s content. Hexo ignores hidden files and files or folders whose names are prefixed with _ (underscore) - except the _posts folder. Renderable files (e.g. Markdown, HTML) will be processed and put into the public folder, while other files will simply be copied. themesTheme folder. Hexo generates a static website by combining the site contents with the theme. Commandsnew1$ hexo new [layout] &lt;title&gt; Creates a new article. If no layout is provided, Hexo will use the default_layout from _config.yml. If the title contains spaces, surround it with quotation marks. generate1$ hexo generate Generates static files. Option Description12-d, --deploy Deploy after generation finishes-w, --watch Watch file changes publish1$ hexo publish [layout] &lt;filename&gt; Publishes a draft. server1$ hexo server Starts a local server. By default, this is at http://localhost:4000/. Option Description123-p, --port Override default port-s, --static Only serve static files-l, --log Enable logger. Override logger format. deploy1$ hexo deploy Deploys your website. Option Description1-g, --generate Generate before deployment render1$ hexo render &lt;file1&gt; [file2] ... Renders files. Option Description1-o, --output Output destination migrate1$ hexo migrate &lt;type&gt; Migrates content from other blog systems. clean1$ hexo clean Cleans the cache file (db.json) and generated files (public). list1$ hexo list &lt;type&gt; Lists all routes. version1$ hexo version Displays version information. Customize config file path1$ hexo --config custom.yml Uses a custom config file (instead of _config.yml). Display drafts1$ hexo --draft Displays draft posts (stored in the source/_drafts folder). Customize CWD1$ hexo --cwd /path/to/cwd Customizes the path of current working directory.","categories":[{"name":"杂记","slug":"杂记","permalink":"http://jabbla.github.io/categories/杂记/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://jabbla.github.io/tags/hexo/"}]},{"title":"常见的几种数组排序算法JS实现","slug":"常见的几种数组排序算法JS实现","date":"2016-03-24T12:09:00.000Z","updated":"2017-12-20T11:23:07.522Z","comments":true,"path":"2016/03/24/常见的几种数组排序算法JS实现/","link":"","permalink":"http://jabbla.github.io/2016/03/24/常见的几种数组排序算法JS实现/","excerpt":"常见的几种数组排序算法JS实现一些简单的排序js实现(小菜一只，大神勿喷)","text":"常见的几种数组排序算法JS实现一些简单的排序js实现(小菜一只，大神勿喷) 快速排序 从给定的数据中，随机抽出一项，这项的左边放所有比它小的，右边放比它大的，然后再分别这两边执行上述操作，采用的是递归的思想，总结出来就是 实现一层，分别给两边递归，设置好出口 1234567891011121314151617181920212223242526272829303132333435function fastSort(array,head,tail)&#123; //考虑到给每个分区操作的时候都是在原有的数组中进行操作的，所以这里head,tail来确定分片的位置 /*生成随机项*/ var randomnum = Math.floor(ranDom(head,tail)); var random = array[randomnum]; /*将小于random的项放置在其左边 策略就是通过一个临时的数组来储存分好区的结果，再到原数组中替换*/ var arrayTemp = []; var unshiftHead = 0; for(var i = head;i &lt;= tail;i++)&#123; if(array[i]&lt;random)&#123; arrayTemp.unshift(array[i]); unshiftHead++; &#125;else if(array[i]&gt;random)&#123; arrayTemp.push(array[i]); &#125; /*当它等于的时候放哪，这里我想选择放到队列的前面，也就是从unshift后的第一个位置放置*/ if(array[i]===random)&#123; arrayTemp.splice(unshiftHead,0,array[i]); &#125; &#125; /*将对应项覆盖原来的记录*/ for(var j = head , u=0;j &lt;= tail;j++,u++)&#123; array.splice(j,1,arrayTemp[u]); &#125; /*寻找中间项所在的index*/ var nowIndex = array.indexOf(random); /*设置出口，当要放进去的片段只有2项的时候就可以收工了*/ if(arrayTemp.length &lt;= 2)&#123; return; &#125; /*递归，同时应用其左右两个区域*/ fastSort(array,head,nowIndex); fastSort(array,nowIndex+1,tail); &#125; 插入排序 思想就是在已经排好序的数组中插入到相应的位置，以从小到大排序为例，扫描已经排好序的片段的每一项，如大于，则继续往后，直到他小于一项时，将其插入到这项的前面 12345678910111213141516171819function insertSort(array)&#123; /*start根据已排列好的项数决定*/ var start=1; /*按顺序，每一项检查已排列好的序列*/ for(var i=start; i&lt;array.length; start++,i++)&#123; /*跟已排好序的序列做对比，并插入到合适的位置*/ for(var j=0; j&lt;start; j++)&#123; /*小于或者等于时（我们是升序）插入到该项前面*/ if(array[i]&lt;=array[j])&#123; console.log(array[i]+' '+array[j]); array.splice(j,0,array[i]); /*删除原有项*/ array.splice(i+1,1); break; &#125; &#125; &#125; &#125; 冒泡排序 故名思意 ，就是一个个冒泡到最前端或者最后端，主要是通过两两依次比较，以升序为例，如果前一项比后一项大则交换顺序，一直比到最后一对 12345678910111213function bubbleSort(array)&#123; /*给每个未确定的位置做循环*/ for(var unfix=array.length-1; unfix&gt;0; unfix--)&#123; /*给进度做个记录，比到未确定位置*/ for(var i=0; i&lt;unfix;i++)&#123; if(array[i]&gt;array[i+1])&#123; var temp = array[i]; array.splice(i,1,array[i+1]); array.splice(i+1,1,temp); &#125; &#125; &#125; &#125; 选择排序 将当前未确定块的min或者max取出来插到最前面或者后面 123456789101112131415161718function selectSort(array)&#123; /*给每个插入后的未确定的范围循环，初始是从0开始*/ for(var unfixed=0; unfixed&lt;array.length; unfixed++)&#123; /*设置当前范围的最小值和其索引*/ var min = array[unfixed]; var minIndex = unfixed; /*在该范围内选出最小值*/ for(var j=unfixed+1; j&lt;array.length; j++)&#123; if(min&gt;array[j])&#123; min = array[j]; minIndex = j; &#125; &#125; /*将最小值插入到unfixed，并且把它所在的原有项替换成*/ array.splice(unfixed,0,min); array.splice(minIndex+1,1); &#125; &#125; 总结一下，实现思想是很简单的,难点在于如何创造思想，还有就是个人的测试能力，和编程习惯，做注释其实不是仅仅为了别人看得更方便，而是自己思路的记录，有些人编着编着容易断片，注释起到了很好的引导作用","categories":[{"name":"技术原创","slug":"技术原创","permalink":"http://jabbla.github.io/categories/技术原创/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://jabbla.github.io/tags/javascript/"},{"name":"算法","slug":"算法","permalink":"http://jabbla.github.io/tags/算法/"}]},{"title":"我所理解的JS执行环境和作用域链","slug":"我所理解的JS执行环境和作用域链","date":"2016-03-22T12:45:00.000Z","updated":"2017-12-20T11:23:23.813Z","comments":true,"path":"2016/03/22/我所理解的JS执行环境和作用域链/","link":"","permalink":"http://jabbla.github.io/2016/03/22/我所理解的JS执行环境和作用域链/","excerpt":"看了一些网上的关于JS机制的文章,结合自己在书上看的和自己的理解,把吸收到的捋捋直","text":"看了一些网上的关于JS机制的文章,结合自己在书上看的和自己的理解,把吸收到的捋捋直执行流 JS包含在HTML文件里的外部文件里或者内嵌script中,每个文件或者代码块都是单独扫描的1234&lt;script&gt; fn1() //fn1 function fn1()&#123;alert('fn1');&#125;&lt;/script&gt; 123456&lt;script&gt; fn1() //error&lt;/script&gt;&lt;script&gt; function fn1()&#123;alert('fn1');&#125;&lt;/script&gt; 浏览器扫描此代码块 然后将具名函数的声明做预处理,然后代码按顺序执行 注意是在同一代码块中哦,浏览器对每个代码块或者文件都是单独扫描的,也就是说预处理的作用范围是单个代码块 之后按照全局顺序开始执行代码,执行流下行 执行环境每个函数都有自己的执行环境,当执行流进入函数时,会为函数生成一个执行环境和执行环境关联的变量对象,变量对象中存着定义在执行环境中的所有变量和函数,JS的全局环境是window对象执行环境栈 为保证代码有序地执行,通过执行流流过的顺序,执行环境依次入栈出栈12345var a = 0;function hello()&#123; a = a+1;&#125;hello() 全局环境入栈-&gt;执行到第5行把hello()执行环境推到栈顶-&gt;hello()出栈,执行流重新回到上一层环境 作用域链12345var a = 0;function hello()&#123; a = a+1;&#125;hello() 当执行流到达第2行时,它不会进入hello()因为它还没有被调用,只是把hello()函数上的作用域链的钩子指向全局函数的变量对象 当执行流到达第5行时,创建hello()的执行环境,生成自己的变量对象,并将作用域链的钩子挂到此时的 全局变量对象上 其实也就这么点东西,还是得多做做题,加深对这些概念的理解,深入学习,下午看的主要结论就是,概念看了谁都懂,主要还是得做一些不那么常规的题巩固记忆,和加深对概念的认识,OK.","categories":[{"name":"技术原创","slug":"技术原创","permalink":"http://jabbla.github.io/categories/技术原创/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://jabbla.github.io/tags/javascript/"}]},{"title":"当我们说Line-Height时候,都会谈论到神马","slug":"当我们说line-height时候-都会谈论到神马","date":"2016-03-20T07:14:00.000Z","updated":"2017-12-20T11:24:02.662Z","comments":true,"path":"2016/03/20/当我们说line-height时候-都会谈论到神马/","link":"","permalink":"http://jabbla.github.io/2016/03/20/当我们说line-height时候-都会谈论到神马/","excerpt":"作为一个初入前端的小鲜肉,这几天被line-height折腾得够呛所以本着 你丫欺负我,我就刨你家祖坟的精神 今天就查查你家户口本","text":"作为一个初入前端的小鲜肉,这几天被line-height折腾得够呛所以本着 你丫欺负我,我就刨你家祖坟的精神 今天就查查你家户口本文中如果有什么不对的地方加我QQ387857274欢迎指正哦,前端爱好者也可以加一下,相互交流嘛个人认为,要想把这货彻底弄清楚就要,得先认识一下’基线’ 什么是基线红色这条线就是基线12是不是很像英语作业本中的线格,没错就是那玩意基线就是用来定位文字在一行中的显示位置,也就是说,一旦一行的基线的位置固定了,文字的位置也就固定了 line-height与基线的关系讲一讲绿线是什么鬼1绿线其实是我意淫出来的0.0 绿线的用处主要就是确定每行content_area,应该和好多文章中所提到的行内框相似12绿线的跨度是由该行内font-size最大的那个元素决定绿线的跨度的改变也会影响基线的位置&apos;好比姚明很高,所以他的屁股也会很高&apos; 绿线跟line-height有什么关系上方区域和下方区域的高度是一致的,我手残只能这样了12那么上方区域或者下方区域是如何计算的呢,就是&apos;((line-height)-绿线的跨度)/2&apos;也就是说这行的上方区域和上一行的下方区域共同组成&apos;行间距一号&apos;,同样下方区域和下一行的上方区域组成&apos;行间距二号&apos; 好吧这里好像跟基线并没有半毛钱关系,我承认,不过也可认为是姚明和他屁股的关系,line-height 会决定本行的位置,同时也就是会影响基线 基线会影响谁呢大家都知道,有inline,inline-block,block三种东西 一. inline我们把它看做一个由内容撑开的元素,被基线影响 二. inline-block中存在基线,其中的inline元素也被基线影响,不过inline-block会继承父元素的line-height1这里大家可能会产生疑问,看图,红色是父级元素p p设置line-height之前 p设置line-height:600px后;两个盒子的基线被拉到下面 这里有一些关于一行的基线到底归谁管的问题,请往下看 三. block跟inline-block是一样一样的区别在于block这货一下占一行 一行的基线到底归谁管1你可以笼统地说是`line-height`,这句话本身是没什么问题的,不过现实情况要比想象的要复杂一点,还有就是图片和空的`inline-block`也会影响基线的位置(**很诡异吧,我也觉得**) 情况11还是上面的图,当两个`inlin-block`不设置任何`line-height`的时候 p元素设置`line-height:600px;`可以看到第一行的基线沉下去了 情况21当只有黄色`inline-block`设置`line-height`的时候,同时绿色的本身&gt; 基线会向整体基线靠拢 情况31当两个货都设置不同的`line-height`呢绿色会调整自己的位置使自身基线向行基线靠拢 情况41当存在空的inline-bolck时,也会把基线下沉 情况51当行中加入图片后,本行的基线会随图片的高度而下沉,其它元素的基线也同时超主基线靠拢 这里得到的结论是:该行的line-height最终结果是子元素中最大的line-height,然后其它元素的line-height设置完成之后基线会朝整行基线靠拢心得就是还是慎用inline-block,个人认为float比inline-block好太多,能不用就不用以上都是个人观点 这是我研究一早上的结果,想交流的小伙伴可以加我qq387857274,共同进步关于更详细的知识内容见下面的参考资料参考链接CSS深入理解之line-height","categories":[{"name":"技术原创","slug":"技术原创","permalink":"http://jabbla.github.io/categories/技术原创/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://jabbla.github.io/tags/CSS/"},{"name":"HTML","slug":"HTML","permalink":"http://jabbla.github.io/tags/HTML/"}]}]}